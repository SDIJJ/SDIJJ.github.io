[{"title":"并查集(Union Find)","url":"/2018/10/22/并查集(Union Find)/","content":" **仰望星空,脚踏实地,暗无天日,登峰造极**<Excerpt in index | 首页摘要>\n学习算法思想,修炼编程内功!\n\n<!-- more -->\n<The rest of contents | 余下全文>\n# 并查集(Union Find)\n\n## 1.什么是并查集\n\n> * 是一种很不一样的树形结构\n> * 适合解决链接问题\n> * 网络中节点的链接状态\n> * 数学中集合类的实现(并集)\n>\n>\n\n## 2.并查集1.0版本的实现(Quick find 查的快,并的慢)\n\n```c++\n#include <iostream>\n#include <cassert>\n\nusing namespace std;\n\nclass UnionFind {\nprivate :\n    int *id;\n    int count;\npublic:\n    UnionFind(int n) {\n        count = n;\n        id = new int[n];\n        for (int i = 0; i < n; i++)\n            id[i] = i;\n    }\n\n    ~UnionFind() {\n        delete[]id;\n    }\n    int find(int p){\n        assert(p>=0&&p<count);\n        return id[p];\n    }\n    bool isConnected(int p,int q){\n        return find(p)==find(q);\n    }\n    void unionElements(int p ,int q){\n        int pid=find(p);\n        int qid=find(q);\n        if(q!=p){\n            for(int i=0;i<count;i++){\n                if(id[i]==pid)\n                    id[i]=qid;\n            }\n        }\n    }\n};\n```\n\n## 3.使用指向父亲节点实现并查集\n\n![1539598030956](/img/1539598030956.png)\n\n```c++\n#include <assert.h>\n#ifndef ARITHMETIC_IMOOC_UNIONFIND2_H\n#define ARITHMETIC_IMOOC_UNIONFIND2_H\n\n#endif //ARITHMETIC_IMOOC_UNIONFIND2_H\nnamespace UP2 {\n\n    class UnionFind {\n    private:\n        int *parent;\n        int count;\n    public:\n        UnionFind(int count) {\n            parent = new int[count];\n            this->count = count;\n            for (int i = 0; i < count; i++) {\n                parent[i] = i;\n            }\n        }\n        ~UnionFind() {\n            delete[] parent;\n        }\n        int find(int p){\n            assert(p>=0&&p<count);\n            while(p!=parent[p])\n                p=parent[p];\n            return p;\n        }\n        bool isConnection(int p,int q){\n            return find(p)==find(q);\n        }\n        void unionElements(int p,int q){\n            int pRoot=find(p);\n            int qRoot=find(q);\n            if(pRoot!=qRoot)\n                parent[pRoot]=parent[qRoot];\n        }\n    };\n}\n```\n\n## 4.并查集的优化(判断元素的层级尺寸再合并)\n\n```c++\n//\n// Created by JIA on 2018/10/15.\n//\n#include <assert.h>\n#ifndef ARITHMETIC_IMOOC_UNIONFIND2_H\n#define ARITHMETIC_IMOOC_UNIONFIND2_H\n\n#endif //ARITHMETIC_IMOOC_UNIONFIND2_H\nnamespace UP3 {\n\n    class UnionFind {\n    private:\n        int *parent;\n        int *sz;\n        int count;\n    public:\n        UnionFind(int count) {\n            parent = new int[count];\n            sz=new int[count];\n            this->count = count;\n            for (int i = 0; i < count; i++) {\n                parent[i] = i;\n                sz[i]=1;\n            }\n        }\n        ~UnionFind() {\n            delete[] parent;\n        }\n        int find(int p){\n            assert(p>=0&&p<count);\n            while(p!=parent[p])\n                p=parent[p];\n            return p;\n        }\n        bool isConnection(int p,int q){\n            return find(p)==find(q);\n        }\n        void unionElements(int p,int q){\n            int pRoot=find(p);\n            int qRoot=find(q);\n            if(pRoot==qRoot)\n                return ;\n            if(sz[pRoot]<sz[qRoot]){\n                parent[pRoot]=qRoot;\n                sz[qRoot]+=sz[pRoot];\n            }else{\n                parent[qRoot]=pRoot;\n                sz[pRoot]+=sz[qRot];\n            }\n\n        }\n    };\n}\n```\n\n## 5.通过路径压缩算法实现并查集的优化\n\n```c++\n      int find(int p){\n            assert(p>=0&&p<count);\n            while(p!=parent[p]){\n                p=parent[p];\n                parent[p]=parent[parent[p]];//路径压缩的实现\n            }\n            return p;     \n          //第二个版本的路径压缩算法,使用递归实现\n            if (p != parent[p])\n                parent[p] != find(parent[p]);\n            return parent[p];\n        }\n\n```\n\n\n\n\n\n ","tags":["算法"],"categories":["算法学习"]},{"title":"用第三方sdk解决微信授权","url":"/2018/10/22/用第三方sdk解决微信授权/","content":" **好身材才是男人最美丽的衣服**<Excerpt in index | 首页摘要>\n 运用sdk快速解决微信授权,解决大量的微信文档!\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n##1.引入依赖:\n```\n<dependency>\n\t\t\t<groupId>com.github.binarywang</groupId>\n\t\t\t<artifactId>weixin-java-mp</artifactId>\n\t\t\t<version>2.7.0</version>\n\t\t</dependency>\n```\n\n##2.建立一个Controller\n```\npackage com.imooc.controller;\n\nimport com.imooc.config.ProjectUrlConfig;\nimport com.imooc.enums.ResultEnum;\nimport com.imooc.exception.SellException;\nimport lombok.extern.slf4j.Slf4j;\nimport me.chanjar.weixin.common.api.WxConsts;\nimport me.chanjar.weixin.common.exception.WxErrorException;\nimport me.chanjar.weixin.mp.api.WxMpService;\nimport me.chanjar.weixin.mp.bean.result.WxMpOAuth2AccessToken;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\n\nimport java.net.URLEncoder;\n\n/**\n * Created by 廖师兄\n * 2017-07-03 01:20\n */\n@Controller\n@RequestMapping(\"/wechat\")\n@Slf4j\npublic class WechatController {\n\n    @Autowired\n    private WxMpService wxMpService;\n\n    @Autowired\n    private WxMpService wxOpenService;\n\n    @Autowired\n    private ProjectUrlConfig projectUrlConfig;\n\n    @GetMapping(\"/authorize\")\n    public String authorize(@RequestParam(\"returnUrl\") String returnUrl) {\n        //1. 配置\n        //2. 调用方法\n        String url = projectUrlConfig.getWechatMpAuthorize() + \"/sell/wechat/userInfo\";\n        String redirectUrl = wxMpService.oauth2buildAuthorizationUrl(url, WxConsts.OAUTH2_SCOPE_BASE, URLEncoder.encode(returnUrl));\n        return \"redirect:\" + redirectUrl;\n    }\n\n    @GetMapping(\"/userInfo\")\n    public String userInfo(@RequestParam(\"code\") String code,\n                         @RequestParam(\"state\") String returnUrl) {\n        WxMpOAuth2AccessToken wxMpOAuth2AccessToken = new WxMpOAuth2AccessToken();\n        try {\n            wxMpOAuth2AccessToken = wxMpService.oauth2getAccessToken(code);\n        } catch (WxErrorException e) {\n            log.error(\"【微信网页授权】{}\", e);\n            throw new SellException(ResultEnum.WECHAT_MP_ERROR.getCode(), e.getError().getErrorMsg());\n        }\n\n        String openId = wxMpOAuth2AccessToken.getOpenId();\n\n        return \"redirect:\" + returnUrl + \"?openid=\" + openId;\n    }\n\n    @GetMapping(\"/qrAuthorize\")\n    public String qrAuthorize(@RequestParam(\"returnUrl\") String returnUrl) {\n        String url = projectUrlConfig.getWechatOpenAuthorize() + \"/sell/wechat/qrUserInfo\";\n        String redirectUrl = wxOpenService.buildQrConnectUrl(url, WxConsts.QRCONNECT_SCOPE_SNSAPI_LOGIN, URLEncoder.encode(returnUrl));\n        return \"redirect:\" + redirectUrl;\n    }\n\n    @GetMapping(\"/qrUserInfo\")\n    public String qrUserInfo(@RequestParam(\"code\") String code,\n                             @RequestParam(\"state\") String returnUrl) {\n        WxMpOAuth2AccessToken wxMpOAuth2AccessToken = new WxMpOAuth2AccessToken();\n        try {\n            wxMpOAuth2AccessToken = wxOpenService.oauth2getAccessToken(code);\n        } catch (WxErrorException e) {\n            log.error(\"【微信网页授权】{}\", e);\n            throw new SellException(ResultEnum.WECHAT_MP_ERROR.getCode(), e.getError().getErrorMsg());\n        }\n        log.info(\"wxMpOAuth2AccessToken={}\", wxMpOAuth2AccessToken);\n        String openId = wxMpOAuth2AccessToken.getOpenId();\n\n        return \"redirect:\" + returnUrl + \"?openid=\" + openId;\n    }\n}\n\n```\n##3.配置文件\n```\nimport me.chanjar.weixin.mp.api.WxMpConfigStorage;\nimport me.chanjar.weixin.mp.api.WxMpInMemoryConfigStorage;\nimport me.chanjar.weixin.mp.api.WxMpService;\nimport me.chanjar.weixin.mp.api.impl.WxMpServiceImpl;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.stereotype.Component;\n\n/**\n * Created by 廖师兄\n * 2017-07-03 01:25\n */\n@Component\npublic class WechatMpConfig {\n\n    @Autowired\n    private WechatAccountConfig accountConfig;\n\n    @Bean\n    public WxMpService wxMpService() {\n        WxMpService wxMpService = new WxMpServiceImpl();\n        wxMpService.setWxMpConfigStorage(wxMpConfigStorage());\n        return wxMpService;\n    }\n\n    @Bean\n    public WxMpConfigStorage wxMpConfigStorage() {\n        WxMpInMemoryConfigStorage wxMpConfigStorage = new WxMpInMemoryConfigStorage();\n        wxMpConfigStorage.setAppId(accountConfig.getMpAppId());\n        wxMpConfigStorage.setSecret(accountConfig.getMpAppSecret());\n        return wxMpConfigStorage;\n    }\n}\n\n```\n","tags":["java"],"categories":["开发工具"]},{"title":"SpringMvc的一些方法","url":"/2018/10/22/SpringMvc的一些方法/","content":"\n** 失败者找理由,成功者找方法!** <Excerpt in index | 首页摘要>\n对SpringMvc的一些常用方法\n<!-- more -->\n<The rest of contents | 余下全文>\n\n##1.Spring-mvc中关于表单中String日期转换为Date的工具类(实现*Converter*接口)\n> 需要实现一个接口,并重写一个方法,如下:\n\n```\npackage com.itheima.springmvc.utils;\n\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\nimport org.springframework.core.convert.converter.Converter;\n\npublic class DateConvert2 implements Converter<String, Date>{\n\n\t@Override\n\tpublic Date convert(String arg0) {\n\t\tDate date=null;\n\t\ttry {\n\t\t\tSimpleDateFormat df=new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n\t\t\tdate=df.parse(arg0);\n\t\t} catch (ParseException e) {\n\t\t\te.printStackTrace();\n\t\t}\t\t\n\t\treturn date;\n\t}\n}\n```\n> 使用这个转换器需要在spring的配置文件中添加相应的bean,如下:\n\n     <!-- 配置注解驱动，相当于同时使用最新处理器映射跟处理器适配器,对json数据响应提供支持 -->\n\t<!-- 使用自定义转换器 -->\n\t<mvc:annotation-driven conversion-service=\"MyConvert\" />\n\t\n\t<!-- 定义转换器 -->\n\t<bean id=\"MyConvert\" class=\"org.springframework.format.support.FormattingConversionServiceFactoryBean\">\n\t\t<property name=\"converters\">\n\t\t\t<set>\n\t\t\t\t<bean class=\"com.itheima.springmvc.utils.DateConvert\" />\n\t\t\t</set>\n\t\t</property>\n\t</bean>\n##2.web端关于get和post请求乱码的解决方案(web.xml中添加过滤器)\n\t\t<!-- 解决post乱码问题 -->\n\t<filter>\n\t\t<filter-name>encoding</filter-name>\n\t\t<filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>\n\t\t<!-- 设置编码参是UTF8 -->\n\t\t<init-param>\n\t\t\t<param-name>encoding</param-name>\n\t\t\t<param-value>UTF-8</param-value>\n\t\t</init-param>\n\t</filter>\n\t<filter-mapping>\n\t\t<filter-name>encoding</filter-name>\n\t\t<url-pattern>/*</url-pattern>\n\t</filter-mapping>\n***\n>修改tomcat中server.xml 文件解决get请求乱码(最方便的方法)\n>- **URLEncoding=\"utf-8\"** 为添加部分\n```\n  <Connector URLEncoding=\"utf-8\" connectionTimeout=\"20000\" port=\"8080\" protocol=\"HTTP/1.1\" redirectPort=\"8443\"/>\n```\n***\n\n>也可以使用自定义的拦截器实现(get和post请求均解决乱码问题):\n>- 运用动态代理的设计模式\n\n```\npackage com.jia.filter;\n\nimport java.io.IOException;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\n\nimport javax.servlet.Filter;\nimport javax.servlet.FilterChain;\nimport javax.servlet.FilterConfig;\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.annotation.WebFilter;\nimport javax.servlet.http.HttpServletRequest;\n\npublic class Filter04 implements Filter {\n\n\tpublic void destroy() {\n\t}\n\n\tpublic void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n\t\tHttpServletRequest req=(HttpServletRequest)request;\n\t\tProxy.newProxyInstance(Filter04.class.getClassLoader(), xxx.class.getInterfaces(), new InvocationHandler() {\n\n\t\t\t@Override\n\t\t\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\t\t\t\tif(method.getName().equalsIgnoreCase(\"getAttribute\")) {\n\t\t\t\t\tString md=req.getMethod();\n\t\t\t\t\tif(\"get\".equals(md)) {\n\t\t\t\t\t\tString reuslt=(String)method.invoke(req, args);\n\t\t\t\t\t\tString str=new String(reuslt.getBytes(\"iso-8858-1\"),\"utf-8\");\n\t\t\t\t\t\treturn str;\n\n\t\t\t\t\t}else {\n\t\t\t\t\t\treq.setCharacterEncoding(\"utf-8\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t});\n\t}  \n\tpublic void init(FilterConfig fConfig) throws ServletException {\n\t}\n}\n```\n##3.在Controller中返回值为String时可以跳转到相应的页面\n>直接跳转到固定页面:\n```\nRequestMapping(\"itemEdit\")\n\tpublic String itemEdit(Model model, @RequestParam(value = \"id\", required = true, defaultValue = \"1\") Integer ids) {\n\t\t// 查询商品信息\n\t\tItem item = itemService.getItemById(ids);\n\t\t// model返回数据模型\n\t\tmodel.addAttribute(\"item\", item);\n\t\t// mav.addObject(\"item\", item);\n\t\treturn \"itemEdit\";\n\t}\n```\n***\n>请求跳转到其他页面\n>- \"forward:xxx.action\"\n>\n>重定向到其他页面\n>- \"redirect:yyy.action\"\n***\n##4.HandlerExceptionResolver 接口处理全局异常\n***\n##5.springmvc上传文件写法(图片)\n![Alt text](/img/1534579880860.png)\n>需要加载的jar包\n![Alt text](/img/1534579925554.png)\n>配置多媒体解析器\n```\n<!-- 配置多媒体处理器 -->\n\t<!-- 注意：这里id必须填写：multipartResolver -->\n\t<bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\">\n\t\t<!-- 最大上传文件大小 -->\n\t\t<property name=\"maxUploadSize\" value=\"8388608\" />\n\t</bean>\n\n```\n>前端代码\n```\n<!-- 上传图片是需要指定属性 enctype=\"multipart/form-data\" -->\n\t<!-- <form id=\"itemForm\" action=\"\" method=\"post\" enctype=\"multipart/form-data\"> -->\n\t<form id=\"itemForm\"\taction=\"${pageContext.request.contextPath }/updateItem.action\" enctype=\"multipart/form-data\" method=\"post\">\n\t\t<input type=\"hidden\" name=\"id\" value=\"${item.id }\" /> 修改商品信息：\n\t\t<table width=\"100%\" border=1>\t\t\t\n\t\t\t<tr>\n\t\t\t\t<td>商品图片</td>\n\t\t\t\t<td>\n\t\t\t\t\t<c:if test=\"${item.pic !=null}\">\n\t\t\t\t\t\t<img src=\"/pic/${item.pic}\" width=100 height=100/>\n\t\t\t\t\t\t<br/>\n\t\t\t\t\t</c:if>\n\t\t\t\t\t<input type=\"file\"  name=\"pictureFile\"/> \n\t\t\t\t</td>\n\t\t\t</tr>\t\t\t\n\t\t</table>\n\t</form>\n```\n>上传文件后端代码\n```\n//图片上传用MultipartFile接收文件\n\t@RequestMapping(value = \"updateItem\", method = { RequestMethod.POST, RequestMethod.GET })\n\tpublic String updateItem(Item item, Model model, MultipartFile picFile) throws Exception {\n\n\t\t// 图片新名字\n\t\tString name = UUID.randomUUID().toString();\n\t\t// 图片原名字\n\t\tString oldName = picFile.getOriginalFilename();\n\t\t// 后缀名\n\t\tString exeName = oldName.substring(oldName.lastIndexOf(\".\"));\n\n\t\tFile pic = new File(\"D:\\\\WebWork\\\\\" + name + exeName);\n\t\t// 保存图片到本地磁盘\n\t\tpicFile.transferTo(pic); \n\t\t// 更新商品图片信息\n\t\titem.setPic(name + exeName);\n\n\t\titemServices.update(item);\n\t\tmodel.addAttribute(\"item\", item);\n\t\tmodel.addAttribute(\"msg\", \"修改商品成功\");\n\t\treturn \"itemEdit\";\n\t}\n\n```","tags":["java"],"categories":["开源框架"]},{"title":"二分搜索树(Binary Seacher  Tree)","url":"/2018/10/14/二分搜索树(Binary Seacher  Tree)/","content":" **仰望星空,脚踏实地,暗无天日,登峰造极**<Excerpt in index | 首页摘要>\n学习算法思想,修炼编程内功!\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n### 1.二分查找\n\n> 一份为二,折半查找\n>\n> **要求**:待查找数组必须有序\n\n```c++\nusing namespace std;\ntemplate <typename T>\nint binarySearch(T arr[],int n,T target){\n    int l=0,r=n-1;\n    while(l<=r){\n        //int mid=(l+r)/2;  这样写存在bug,可能会溢出\n        int mid=l+(r-l)/2;\n        if(arr[mid]==target)\n            return mid;\n        if(target<mid)\n            r=mid-1;\n        else\n            l=mid+1;\n    }\n    return -1;\n}\n```\n\n> 递归实现二分查找\n\n```c++\ntemplate<typename T>\nint reBinarySearch(T arr[], T k, int l, int r) {\n    int mid = (l + r) / 2;\n    if (l > r)\n        return -1;\n    if (arr[mid] == k)\n        return mid;\n    else if (k < arr[mid])\n        reBinarySearch(arr, k, l, mid - 1);\n    else\n        reBinarySearch(arr, k, mid + 1, r);\n}\n```\n\n### 2.二分搜索树\n\n#### 2.1二分搜索树的优势:\n\n- 高效:\n\n  ​\t在查找,插入,删除都能以O(lgn)的时间复杂度完成\n\n- min,max,floor,ceil,rank,select 实现都将很方便\n\n- 在实际应用中,比如要查找一篇文章中某个词出现的次数,用二分搜索树效率将会异常的高\n\n![1539167904772](/img/1539167904772.png)\n\n#### 2.2 二分搜索树的定义:\n\n> - 在定义中天然的包括了递归结构\n> - 二分搜索树不一定是一颗完全二叉树\n\n![1539168446767](/img/1539168446767.png)\n\n#### 2.3向二叉搜索树中插入新的健值对的实现\n\n```c++\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <ctime>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\ntemplate<typename Key, typename Value>\nclass BST {\nprivate:\n    struct Node {\n        Key key;\n        Value value;\n        Node *left;\n        Node *right;\n\n        Node(Key key, Value value) {\n            this->key = key;\n            this - value = value;\n            this->right = this->left = NULL;\n        }\n    };\n    Node *root;//存根\n    int count;//存一共有的节点个数\n\npublic:\n    BST() {\n        root = NULL;\n        count = 0;\n    }\n    ~BST(){\n        //TODO\n    }\n    int size(){\n        return count;\n    }\n    bool isEmpty(){\n        return count==0;\n    }\n    void insert(Key key,Value value){\n        root = insert(root ,key,value);\n    }\nprivate:\n    //以node为根的二叉搜索树中插入节点(key,value)\n    //放回插入新节点后的二叉搜索树的根\n    Node* insert(Node *node,Key key,Value value){\n        if(node->key==NULL){\n            count++;\n//            node->key=key;\n//            node->value=value;\n            return new Node(key,value);\n        }\n        if(node->key==key)\n            node->value=value;\n        else if(node->key<key)\n            node->left=insert(node->left,key,value);\n        else\n            node->right=insert(node->right,key,value);\n        return node;\n    }\n};\n```\n\n### 2.4二分搜索树实现搜素和是否存在某个值得函数\n\n```c++\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <ctime>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\ntemplate<typename Key, typename Value>\nclass BST {\nprivate:\n    struct Node {\n        Key key;\n        Value value;\n        Node *left;\n        Node *right;\n\n        Node(Key key, Value value) {\n            this->key = key;\n            this - value = value;\n            this->right = this->left = NULL;\n        }\n    };\n    Node *root;//存根\n    int count;//存一共有的节点个数\n\npublic:\n    BST() {\n        root = NULL;\n        count = 0;\n    }\n    ~BST(){\n        //TODO\n    }\n    int size(){\n        return count;\n    }\n    bool isEmpty(){\n        return count==0;\n    }\n    void insert(Key key,Value value){\n        root = insert(root ,key,value);\n    }\n    //查找二叉搜索树是否存在key\n    bool contain(Key key){\n        return contain(root,key);\n    }\n    //查找key相应节点所对应的Value地址\n    Value* search(Key key){\n        return search(root,key);\n    }\nprivate:\n    //以node为根的二叉搜索树中插入节点(key,value)\n    //放回插入新节点后的二叉搜索树的根\n    Node* insert(Node *node,Key key,Value value){\n        if(node->key==NULL){\n            count++;\n//            node->key=key;\n//            node->value=value;\n            return new Node(key,value);\n        }\n        if(node->key==key)\n            node->value=value;\n        else if(node->key<key)\n            node->left=insert(node->left,key,value);\n        else\n            node->right=insert(node->right,key,value);\n        return node;\n    }\n    bool contain(Node* node ,Key key){\n        if(node==NULL)\n            return false;\n        if(node->key==key)\n            return true;\n        else if(key<node->key)\n            return contain(node->key,key);\n        else\n            return contain(node->right.key);\n    }\n    Value* search(Node* node,Key key){\n        if(node==NULL)\n            return NULL;\n        if(node->key==key)\n            return &(node->value);\n        else if(key<node->key)\n            return search(node->left,key);\n        else\n            return search(node->right,key);\n\n    }\n};\n```\n\n### 2.5二分搜索树的前,中,后序遍历,以及二分搜素树的销毁\n\n```c++\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <ctime>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\ntemplate<typename Key, typename Value>\nclass BST {\nprivate:\n    struct Node {\n        Key key;\n        Value value;\n        Node *left;\n        Node *right;\n        Node(Key key, Value value) {\n            this->key = key;\n            this - value = value;\n            this->right = this->left = NULL;\n        }\n    };\n    Node *root;//存根\n    int count;//存一共有的节点个数\npublic:\n    BST() {\n        root = NULL;\n        count = 0;\n    }\n    ~BST() {\n        destory(root);\n    }\n    int size() {\n        return count;\n    }\n    bool isEmpty() {\n        return count == 0;\n    }\n    void insert(Key key, Value value) {\n        root = insert(root, key, value);\n    }\n    //查找二叉搜索树是否存在key\n    bool contain(Key key) {\n        return contain(root, key);\n    }\n    //查找key相应节点所对应的Value地址\n    Value *search(Key key) {\n        return search(root, key);\n    }\n    //前序遍历\n    void preOreder() {\n        preOreder(root);\n    }\n    //中序遍历\n    void inOrder() {\n        inOrder(root);\n    }\n    //后序遍历\n    void postOrder() {\n        postOrder(root);\n    }\nprivate:\n//以node为根的二叉搜索树中插入节点(key,value)\n//放回插入新节点后的二叉搜索树的根\n    Node *insert(Node *node, Key key, Value value) {\n        if (node->key == NULL) {\n            count++;\n//            node->key=key;\n//            node->value=value;\n            return new Node(key, value);\n        }\n        if (node->key == key)\n            node->value = value;\n        else if (node->key < key)\n            node->left = insert(node->left, key, value);\n        else\n            node->right = insert(node->right, key, value);\n        return node;\n    }\n    bool contain(Node *node, Key key) {\n        if (node == NULL)\n            return false;\n        if (node->key == key)\n            return true;\n        else if (key < node->key)\n            return contain(node->key, key);\n        else\n            return contain(node->right.key);\n    }\n    Value *search(Node *node, Key key) {\n        if (node == NULL)\n            return NULL;\n        if (node->key == key)\n            return &(node->value);\n        else if (key < node->key)\n            return search(node->left, key);\n        else\n            return search(node->right, key);\n    }\n    void preOrder(Node *node) {\n        if (node != NULL) {\n            cout << node.key << \" \";\n            preOreder(node->left);\n            preOrder(node->right);\n        }\n    }\n    void inOrder(Node *node) {\n        if (node != NULL) {\n            inOrder(node->left);\n            cout << node->key << \" \";\n            inOrder(node->right);\n        }\n    }\n    void postOrder(Node *node) {\n        if (node != NULL) {\n            postOrder(node->left);\n            postOrder(node->right);\n            cout << node->key << \" \";\n        }\n    }\n    void destory(Node *node) {\n        if (node != NULL) {\n            destory(node->left);\n            destory(node->right);\n            delete node;\n            count--;\n        }\n    }\n};\n```\n\n### 2.6二分搜索树的广度优先遍历(层序遍历)\n\n![1539226708430](/img/1539226708430.png)\n\n> 代码实现\n\n```c++\n//二叉搜索树的程序遍历\n    void levelOrder() {\n        queue<Node *> q;\n        q.push(root);\n        while (!q.empty()) {\n            Node node = q.front();\n            q.pop();\n            count << node->key << \" \" << node->value << \"  \";\n            if (node.left)\n                q.push(node.left);\n            if (node.right)\n                q.push(node.left);\n        }\n    }\n\n```\n\n### 2.7找出最大值和最小值函数实现\n\n```c++\n Key minimum() {\n        assert(count != 0);\n        Node node = root;\n        while (node.left != NULL)\n            node = node.left;\n        return node.key;\n    }\n\n    Key maximum() {\n        assert(count != 0);\n        Node node = root;\n        while (node.right != NULL)\n            node = node.right;\n        return node;\n    }\n```\n\n### 2.8二分搜素树的删除节点\n> 删除最大值和最小值函数的实现:\n\n```c++\n//删除二分搜索树的最小节点\n    void removeMin(){\n        if(root)\n            root = removeMin(root);\n    }\n    //删除二分搜索树的最大节点\n    void removeMax(){\n        if(root)\n            root=removeMax(root);\n    }\nprivate:\nNode* removeMin(Node* node){\n        if(node->left==NULL){\n           Node* rightNode=node->right;\n           delete  node;\n           count--;\n           return rightNode;\n        }\n        node->left=removeMin(node->left);\n        return node;\n    }\n    Node* removeMax(Node* node){\n        if(node->right==NULL){\n            Node* leftNode=node->left;\n            delete node;\n            count--;\n            return leftNode;\n        }\n        node->right=removeMax(node->right);\n        return node;\n    }\n```\n\n> 二分搜索树删除指定节点:\n\n![1539588249714](/img/1539588249714.png)\n\n```c++\n //删除二叉树的指定节点\n    void remove(Key key) {\n        root = remove(root, key);\n    }\nprivate:    \n    Node *remove(Node *node, Key key) {\n        if (node == NULL)\n            return NULL;\n        if (key < node->key) {\n            node->left = remove(node->left, key);\n            return node;\n        } else if (key > node->key) {\n            node->right = remove(node->right, key);\n            return node;\n        } else {   //key=node.key的情况\n            if (node->left == NULL) {\n                Node *rightNode = node->right;\n                delete node;\n                count--;\n                return rightNode;\n            }\n            if (node->right == NULL) {\n                Node *leftNode = node->left;\n                delete node;\n                count--;\n                return leftNode;\n            }\n            //node.left!=null&&node.right!=null;\n            Node *successor = new Node(minimum(node->right));\n            count++;\n            successor->right = removeMin(node->right);\n            successor->left = node->left;\n            delete node;\n            count--;\n            return successor;\n        }\n    }\n```\n\n### 2.9二分查找树的局限性\n\n\n\n\n","tags":["算法"],"categories":["算法学习"]},{"title":"堆排序(heapSort)","url":"/2018/10/13/堆排序(heapSort)/","content":" **仰望星空,脚踏实地,暗无天日,登峰造极**<Excerpt in index | 首页摘要>\n学习算法思想,修炼编程内功!\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n## 堆排序(heapSort)\n\n### 1.堆排序的实现:\n\n```c++\n#include <string>\n#include <ctime>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\ntemplate<typename T>\n\nvoid __shiftDown(T arr[],int n,int k){\n    while(2*k+1<n){\n        int j=2*k+1;\n        if(j+1<n&&arr[j+1]>arr[j])\n            j+=1;\n        if(arr[k]>arr[j])\n            break;\n            swap(arr[j],arr[k]);\n            k=j;\n    }\n}\ntemplate<typename T>\nvoid heapSort(T arr[],int n){\n    for(int i=(n-1)/2;i>=0;i--)\n    __shiftDown(arr,n,i);\n    for(int i=n-1;i>0;i--){\n        swap(arr[0],arr[i]);\n        __shiftDown(arr,i,0);\n    }\n}\n```\n\n### 2.排序算法总结:\n\n> 排序苏算法的稳定性:对于相等的元素,在排序后,原来靠前的元素依然靠前.相等元素的相对位置没有发生改变.\n>\n> 在某次场景会考虑到排序算法的稳定性.比如:学生的姓名是按字典序排列的,根据分数排序后,相同分数的学生还应该按照字典序排列.(插入排序和归并排序是稳定的排序算法)\n>\n> ![1539159816193](/img/1539159816193.png)\n\n![1539159633630](/img/1539159633630.png)\n\n","tags":["算法"],"categories":["算法学习"]},{"title":"堆(Heap)","url":"/2018/10/13/堆的学习(Heap)/","content":" **仰望星空,脚踏实地,暗无天日,登峰造极**<Excerpt in index | 首页摘要>\n学习算法思想,修炼编程内功!\n\n<!-- more -->\n<The rest of contents | 余下全文>\n## 堆的学习(Heap)\n\n> 什么是优先队列:\n>\n> > 普通队列:先进先出;后进后出\n> >\n> > 优先队列:出队列和入队列和优先级有关(动态)\n>\n> ![1539084361286](/img/1539084361286.png)\n\n#### 1二叉堆\n\n![1539085506624](/img/1539085506624.png)\n\n### 1.1用数组储存二叉堆\n\n![1539085717026](/img/1539085717026.png)![1539085824560](/img/1539085824560.png)### 1.2定义一个基本的堆\n\n```c++\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <ctime>\n#include <cmath>\n#include <cassert>\nusing namespace std;\ntemplate <typename Item>\nclass Maxheap{\nprivate:\n    Item *data;\n    int count;\npublic:\n    Maxheap(int capacity){\n        data =new Item[capacity+1];\n        count=0;\n    }\n    ~Maxheap(){\n        delete[] data;\n    }\n    int size(){\n        return count;\n    }\n    bool isEmpty(){\n        return count == 0;\n    }\n};\n\nint main() {\n    Maxheap<int> maxheap = Maxheap<int>(100);\n    cout<<maxheap.size()<<endl;\n    return 0;\n}\n```\n\n### 1.3Shit Up的实现(向堆中插入元素)\n\n```c++\n//\n// Created by JIA on 2018/10/9.\n//\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <ctime>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\ntemplate<typename Item>\nclass Maxheap {\nprivate:\n    Item *data;\n    int count;\n\n    void shiftUp(int k) {\n        while (k > 1 && data[k / 2] < data[k]) {\n            swap(data[k / 2, data[k]]);\n\n            k /= 2;\n        }\n    }\n\npublic:\n    Maxheap(int capacity) {\n        data = new Item[capacity + 1];\n        count = 0;\n    }\n\n    ~Maxheap() {\n        delete[] data;\n    }\n\n    int size() {\n        return count;\n    }\n\n    bool isEmpty() {\n        return count == 0;\n    }\n\n    void insert(Item item) {\n        data[count + 1] = item;\n        count++;\n        shiftUp(count);\n    }\n};\n\nint main() {\n    Maxheap<int> maxheap = Maxheap<int>(100);\n    srand(time(NULL));\n    for (int i = 0; i < 15; i++) {\n        maxheap.insert(rand() % 100);\n    }\n    for (int i = 0; i < 15; i++) {\n        cout << maxheap.data[i] << \" \";\n    }\n    return 0;\n}\n```\n\n### 1.4ShiftDown和queryMax()的实现(取出堆中最大的元素)\n\n```c++\n//\n// Created by JIA on 2018/10/9.\n//\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <ctime>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\ntemplate<typename Item>\nclass Maxheap {\nprivate:\n    Item *data;\n    int count;\n\n    void shiftUp(int k) {\n        while (k > 1 && data[k / 2] < data[k]) {\n            swap(data[k / 2, data[k]]);\n\n            k /= 2;\n        }\n    }\n    void shiftDown(int k){\n//        while(data[k]>data[2*k]||data[k]>data[2*k+1])\n          while(2*k<=count){\n              int j=2*k;\n              if(j+1<count&&data[j]<data[j+1])\n                  j+=1;\n              if(data[k]>data[j])\n                  break;\n              swap(data[k],data[j]);\n              k=j;\n          }\n    }\n\n\npublic:\n    Maxheap(int capacity) {\n        data = new Item[capacity + 1];\n        count = 0;\n    }\n\n    ~Maxheap() {\n        delete[] data;\n    }\n\n    int size() {\n        return count;\n    }\n\n    bool isEmpty() {\n        return count == 0;\n    }\n\n    void insert(Item item) {\n        data[count + 1] = item;\n        count++;\n        shiftUp(count);\n    }\n    int queryMax(){\n\n        Item ret=data[1];\n        swap(ret ,data[count]);\n        count--;\n        shiftDown(1);\n        return ret;\n    }\n};\n\nint main() {\n    Maxheap<int> maxheap = Maxheap<int>(100);\n    srand(time(NULL));\n    for (int i = 0; i < 15; i++) {\n        maxheap.insert(rand() % 100);\n    }\n    for (int i = 0; i < 15; i++) {\n        cout << maxheap.data[i] << \" \";\n    }\n    return 0;\n}\n```\n\n## 3.堆排序\n\n> 借助大顶堆,每次将对顶元素取出;\n\n```c++\ntemplate <typename T>\nvoid HeapSort(T arr[],int n){\n    Maxheap<T> maxheap=new Maxheap<T>(n);\n    for (int i =n-1 ; i>=0  ; i--) {\n        arr[i]=maxheap.queryMax();\n    }\n}\n```\n\n### 1.5堆排序的优化\n\n> 直接将待排序的数组初始化成一个大顶堆堆\n\n```c++\nMaxheap(Item arr[],int n){\n        data=new Item[n+1];\n        capacity=n;\n        for (int i = 0; i <n ; i++) {\n            data[i+1]=arr[i];\n            count=n;\n            for(int i=count/2;i>=1;i--)\n                shiftDown(i);\n        }\n    }\n```\n\n### 1.6Heapify的算法复杂度\n\n![1539091417707](/img/1539091417707.png)## 2索引堆(Index Heap)\n\n> Heapify时只讲数组的索引堆化  \n>\n> 为什么使用索引堆:\n>\n>   Heapify的过程会进行频繁的交换,当元素足够复杂时,交换元素将会异常的耗费资源\n\n### 2.1 最大索引堆得代码实现\n\n```c++\nusing namespace std;\n\ntemplate<typename Item>\nclass IndexMaxheap {\nprivate:\n    int* indexes;\n    Item *data;\n    int count;\n    int cacacity;\n    void shiftUp(int k) {\n        while (k > 1 && data[indexes[k / 2]] < data[indexes[k]]) {\n            swap(indexes[k / 2], indexes[k]);\n\n            k /= 2;\n        }\n    }\n    void shiftDown(int k){\n//        while(data[k]>data[2*k]||data[k]>data[2*k+1])\n        while(2*k<=count){\n            int j=2*k;\n            if(j+1<count&&data[indexes[j]]<data[indexes[j+1]])\n                j+=1;\n            if(data[indexes[k]>data[indexes[j]])\n                break;\n            swap(indexes[k],indexes[j]);\n            k=j;\n        }\n    }\n\n\npublic:\n    IndexMaxheap(int capacity) {\n        data = new Item[capacity + 1];\n        this->indexes=new int[capacity];\n        count = 0;\n        this->cacacity=capacity;\n    }\n\n    ~IndexMaxheap() {\n        delete[] data;\n        delete[] indexes;\n    }\n\n    int size() {\n        return count;\n    }\n\n    bool isEmpty() {\n        return count == 0;\n    }\n\n    void insert(int i,Item item) {\n\n        data[i+1]=item;\n        indexes[count+1]=i;\n        count++;\n        shiftUp(count);\n    }\n    Item queryMax(){\n        Item ret=data[indexes[1]];\n        swap(indexes[1] ,indexes[count]);\n        count--;\n        shiftDown(1);\n        return ret;\n    }\n    int queryMaxIdex(){\n        int ret =indexes[1]-1;\n        swap(indexes[1] ,indexes[count]);\n        count--;\n        shiftDown(1);\n        return ret;\n    }\n    Item getItem(int i){\n        return data[i-1];\n    }\n    void change(int i,Item item){\n        i+=1;\n        data[i]=item;\n        for(int j=1;j<=count;j++){\n            if(indexes[j]==i){\n                shiftDown(indexes[j]);\n                shiftUp(indexes[j]);\n                return ;\n            }\n        }\n    }\n};\n```\n\n### 2.2 反向查找","tags":["算法"],"categories":["算法学习"]},{"title":"高级排序算法(n*logN)","url":"/2018/10/11/高级排序算法/","content":" **仰望星空,脚踏实地,暗无天日,登峰造极**<Excerpt in index | 首页摘要>\n学习算法思想,修炼编程内功!\n\n<!-- more -->\n<The rest of contents | 余下全文>\n# 高级排序算法(n*logN)\n## 1.归并排序(Merge Sort)\n\n> 将待排序的数组无数次分成两部分,最后将剩下的排序(减少了时间复杂度,增加了空间复杂度),归并的过程需要开辟新的数组 \n\n![1539061916200](/img/1539061916200.png)\n\n![1539062061025](/img/1539062061025.png)\n\n### 实现代码\n\n* 注释出代码为接近有序的代码进行优化:如果左面比右面小就不用归并操作\n\n```c++\n//将arr[l,mid]和[mid+1,r]进行归并\ntemplate<typename T>\nvoid __marge(T arr[], int l, int mid, int r) {\n    T aux[r - l + 1];\n    for (int i = l; i <= r; i++)\n        aux[i - l] = arr[i];\n\n    int i = l;\n    int j = mid + 1;\n    for (int k = l; k <= r; k++) {\n        if (i > mid) {\n            arr[k] = aux[j - l];\n            j++;\n        } else if (j > r) {\n            arr[k] = aux[i - l];\n            i++;\n        } else if (aux[i - l] < aux[j - l]) {\n            arr[k] = aux[i - l];\n            i++;\n        } else {\n            arr[k] = aux[j - l];\n            j++;\n        }\n    }\n}\n//对arr[l....r]的范围进行排序\ntemplate<typename T>\nvoid __mergeSort(T arr[], int l, int r) {\n    if (l >= r)\n        return;\n    int mid = (l + r) / 2;\n    __mergeSort(arr, l, mid);\n    __mergeSort(arr, mid+1, r);\n    //if (arr[mid] > arr[mid + 1])  //对接近有序的数组进行优化\n    __marge(arr, l, mid, r);\n\n}\ntemplate <typename T>\nvoid mergeSort(T arr[], int n) {\n    __mergeSort(arr, 0, n - 1);\n}\n\n```\n\n### 自底向上实现归并排序(不用进行递归操作)\n\n```c++\n#include <iostream>\n\nusing namespace std;\n\n//将arr[l,mid]和[mid+1,r]进行归并\ntemplate<typename T>\nvoid __marge(T arr[], int l, int mid, int r) {\n    T aux[r - l + 1];\n    for (int i = l; i <= r; i++)\n        aux[i - l] = arr[i];\n    int i = l;\n    int j = mid + 1;\n    for (int k = l; k <= r; k++) {\n        if (i > mid) {\n            arr[k] = aux[j - l];\n            j++;\n        } else if (j > r) {\n            arr[k] = aux[i - l];\n            i++;\n        } else if (aux[i - l] < aux[j - l]) {\n            arr[k] = aux[i - l];\n            i++;\n        } else {\n            arr[k] = aux[j - l];\n            j++;\n        }\n    }\n}\n\ntemplate<typename T>\nvoid mergerSortBU(T arr[], int n) {\n    for (int sz = 1; sz <= n; sz += sz) {\n        for (int i = 0; i + sz < n; i+= sz + sz) {\n            __marge(arr, i, i + sz - 1, min(i + sz + sz - 1, n - 1));\n        }\n    }\n}\n```\n\n## 2.快速排序(Quick Sort)\n\n> 最好理解,实现最容易的排序算法,但是如果数组接近有序时,性能将会异常的差\n>\n> 使用: swap(arr[l],arr[rand()%(h-l+1)+l]);  随机取一个数可以对代码进行优化\n\n```c++\n#include <iostream>\n\nusing namespace std;\n\nint __privo(int arr[], int l, int h) {\n    int p = arr[l];\n    while (l < h) {\n        swap(arr[l],arr[rand()%(h-l+1)+l]);   //对代码的优化\n        while (l < h && arr[h] >= p) --h;\n        swap(arr[l], arr[h]);\n        while (l < h && p > arr[l]) ++l;\n        swap(arr[l], arr[h]);\n    }\n\n    return l;\n}\n\nvoid quickSort(int arr[], int l, int h) {\n    if (l > h){\n        return;}\n    int p = __privo(arr, l, h);\n    quickSort(arr, l, p - 1);\n    quickSort(arr, p + 1, h);\n\n}\n\nint main() {\n    cout << \"abc\" << endl;\n    int a[] = {3,1,2,4,7,8,23,6,0};\n    quickSort(a, 0, 8);\n    for (int i = 0; i < 9; i++) {\n        cout << a[i] << \" \";\n    }\n    cout << endl;\n    cout<<\"))))\";\n    return 0;\n}\n\n\n```\n\n","tags":["算法"],"categories":["算法学习"]},{"title":"基础排序算法","url":"/2018/10/10/基础的排序算法/","content":" **仰望星空,脚踏实地,暗无天日,登峰造极**<Excerpt in index | 首页摘要>\n学习算法思想,修炼编程内功!\n\n<!-- more -->\n<The rest of contents | 余下全文>\n# 基础排序算法\n\n## 1选择排序(Selection Sort)\n\n### 基本思想\n\n> 基本思想,从0开始每一次找第n小的元素与当前第n位置的元素交换.时间复杂度O(n2) ,无论怎样的数组必须都将两层循环跑完.\n\n![1539000224817](/img/1539000224817.png)\n\n### 实现代码\n```c++\n#include<iostream>\nusing namespace std;\nvoid selectionSort( int arr[],int n){\n    for(int i=0; i<n; i++){\n        //寻找[i,n)区间最小值\n        int minIndex=i;\n        for(int j=i+1; j<n; j++){\n            if(arr[minIndex]>arr[j]){\n                minIndex=j;\n            }\n            swap(arr[minIndex],arr[i]);\n        }\n    }\n}\nint main(){\n    int a[]={1,2,3,5,4,6,8,7,9,10};\n    selectionSort(a,10);\n    for(int i=0;i<10;i++){\n        cout<<a[i]<<\" \";\n    }\n    cout<<endl;\n    return 0;\n}\n\n```\n\n### 使用c++模板进行扩展\n\n```c++\n#include<iostream>\n#include \"Student.h\"\nusing namespace std;\n//c++模板,或者泛型\ntemplate<typename T>\nvoid selectionSort( T arr[],int n){\n    for(int i=0; i<n; i++){\n        //寻找[i,n)区间最小值\n        int minIndex=i;\n        for(int j=i+1; j<n; j++){\n            if(arr[j]<arr[minIndex]){\n                minIndex=j;\n            }\n            swap(arr[minIndex],arr[i]);\n        }\n    }\n}\nint main(){\n    int a[]={1,2,3,5,4,6,8,7,9,10};\n    selectionSort(a,10);\n    for(int i=0;i<10;i++){\n        cout<<a[i]<<\" \";\n    }\n    cout<<endl;\n    float b[]={1.2,2.4,5,6,2.2};\n    selectionSort(b,5);\n    for(int i=0;i<5;i++){\n        cout<<b[i]<<\"  \";\n    }\n     cout<<endl;\n     string c[]={\"d\",\"b\",\"c\",\"a\",\"f\"};\n     for(int i=0;i<5;i++){\n        cout<<c[i]<<\"  \";\n     }\n      cout<<endl;\n      Student d[3]={{\"A\",90},{\"B\",80},{\"C\",85}};\n      selectionSort(d,3);\n      for(int i=0;i<3;i++){\n        cout<<d[i]<<\" \";\n      }\n      cout<<endl;\n    return 0;\n}\n\n```\n\n---\n\n```c++\n#ifndef STUDENT_H_INCLUDED\n#define STUDENT_H_INCLUDED\n\n\n#include<iostream>\n#include<string>\nusing namespace std;\nstruct Student{\n    string name;\n    int score;\n    bool operator<(const Student &otherStudent){\n        return score < otherStudent.score;\n    }\n    friend ostream& operator<<(ostream &os ,const Student &student){\n        os<<\"Student: \"<<student.name<<\" \"<<student.score<<endl;\n        return os;\n    }\n};\n\n\n#endif // STUDENT_H_INCLUDED\n\n```\n\n## 2.插入排序(Insertion Sort)\n\n> 再循环中每次将元素与前面位置元素比较,如果小就交换位置.时间复杂度O(n2).插入排序对接近有序的数组排序性能将会更好\n\n![1539003860047](/img/1539003860047.png)\n\n### 实现代码:\n\n```c++\n#include <iostream>\nusing namespace std;\ntemplate <typename T>\nvoid insertionSort(T arr [],int n){\n\n    for(int i=1;i<n;i++){\n        for(int j=i+1;j>0&&arr[j]<arr[j-1];j--){\n            swap(arr[j],arr[j-1]);\n        }\n    }\n\n}\n\n```\n\n---\n\n### 优化代码:\n\n> 每次循环标记元素的值,将每一次交换改成赋值操作,\n\n```c++\n#include <iostream>\n\nusing namespace std;\ntemplate <typename T>\nvoid insertionSortOpt(T arr[], int n) {\n    for (int i = 1; i < n; i++) {\n        T e = arr[i];\n        int j;\n        for ( j = i; j > 0 && arr[j - 1] > e; j--) {\n            arr[j] = arr[j - 1];\n        }\n        arr[j] = e;\n    }\n}\n\n```\n\n","tags":["算法"],"categories":["算法学习"]},{"title":"SpringCloud微服务学习总结","url":"/2018/10/04/SpringCloud微服务学习总结/","content":"\n** 骗的了别人骗不了自己,做什么都要用心!** <Excerpt in index | 首页摘要>\n对SpringCloud学习做一个总结,供以后应用查看\n<!-- more -->\n<The rest of contents | 余下全文>\n\n微服务的特点:\n\n> * 一系列微小的服务共同组成\n> * 单独部署,跑在自己的进程里\n> * 每个服务为独立的业务开发\n> * 分布式的管理\n\n传统vs微服务\n\n![1538629111529](/img/1538629111529.png)\n\n> 业务形态上不适合微服务的场景\n>\n> * 系统中包含很多很多强事务的场景\n> * 业务相对稳定,迭代周期长\n> * 访问压力不大,可用性要求不高\n> * ...\n\n![1538628687788](/img/1538628687788.png)\n\n![1538628921984](/img/1538628921984.png)\n\n## 1.Eureka服务注册中心\n\n### 1.1构建项目\n\n> 选择eureka Server\n\n![1538625976475](/img/1538625976475.png) \n\n### 1.2 启动类上添加```@EnableEurekaServer```注解\n\n```java\n\npackage com.jia.eureka;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;\n\n@SpringBootApplication\n@EnableEurekaServer\npublic class EurekaApplication {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(EurekaApplication.class, args);\n\t}\n}\n```\n\n### 1.3 application.yml配置\n\n>* register-with-eureka: false       是否注册到服务注册中心,因为自己就是服务注册注册中心,所以false\n>* enable-self-preservation: false      关闭心跳检测保留链接(开发环境为了查看服务状态)\n\n```java\n\neureka:\n  client:\n    service-url:\n      defaultZone: http://localhost:8761/eureka/\n    register-with-eureka: false\n  server:\n    enable-self-preservation: false\nspring:\n  application:\n    name: eureka\nserver:\n  port: 8761\n```\n\n### 1.4启动效果\n\n![1538626591475](/img/1538626591475.png)### 1.5小结\n\n> eureka服务注册中心在生产环境中可以做到高可用,启动多个eureka服务注册中心,彼此相互注册,每个客户端服务再分别注册到这些eureka服务注册中心.即使一个eureka垮掉,整个微服务也可以正常运行.\n>\n> ![1538628284808](/img/1538628284808.png)\n\n## 2.Eureka客户端的使用\n\n### 2.1构建项目\n\n> 选择Eureka Discovery\n\n![1538627464924](/img/1538627464924.png)2.2 启动类上添加@EnableDiscoveryClient注解\n\n```java\npackage com.jia.client;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.cloud.client.discovery.EnableDiscoveryClient;\n\n@SpringBootApplication\n@EnableDiscoveryClient\npublic class ClientApplication {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(ClientApplication.class, args);\n\t}\n}\n\n```\n\n### 2.3 application.yml的配置\n\n>*  instance:\n>\n>  ​        hostname: clientName     客户端服务跳转的名字\n\n```java\neureka:\n  client:\n    service-url:\n      defaultZone: http://localhost:8761/eureka/\n#  instance:\n#    hostname: clientName\nspring:\n  application:\n    name: client\nserver:\n  port: 10001\n```\n\n### 2.4 启动效果\n\n![1538628237602](/img/1538628237602.png)\n\n### 2.5小结\n\n> * @EnableEurekaServer @EnabeEurekaClient\n> * 心跳检测,健康检查,负载均衡等功能\n> * Eureka的高可用,生产上建议使用两台\n> * 分布式系统中,服务注册中心是重要的基础部分\n\n## 3.统一配置中心config\n\n### 3.1.为什么需要统一配置中心\n\n* 不方便维护\n* 配置内容安全与权限\n* 更新配置项目启动\n\n### 3.2.统一配置中心总体架构\n\n![1538630591518](/img/1538630591518.png)\n\n### 3.3.统一配置中心的Server端\n\n> * 项目构建 \n>\n> ![1538630687494](/img/1538630755571.png)\n>\n> * 启动类上添加注解@EnableConfigServer\n>\n>   ```java\n>   package com.jia.config;\n>   \n>   import org.springframework.boot.SpringApplication;\n>   import org.springframework.boot.autoconfigure.SpringBootApplication;\n>   import org.springframework.cloud.client.discovery.EnableDiscoveryClient;\n>   import org.springframework.cloud.config.server.EnableConfigServer;\n>   \n>   @SpringBootApplication\n>   @EnableDiscoveryClient\n>   @EnableConfigServer\n>   public class ConfigApplication {\n>   \n>   \tpublic static void main(String[] args) {\n>   \t\tSpringApplication.run(ConfigApplication.class, args);\n>   \t}\n>   }\n>   ```\n>\n>   * gitee上创建一个仓库用来存放配置文件\n>\n>   * > gitee地址:https://gitee.com/shltj/config-repo\n>\n>     ![1538631315904](/img/1538631315904.png)\n>\n>     * application.yml的配置\n>\n>       ```java\n>       spring:\n>         application:\n>           name: config\n>         cloud:\n>           config:\n>             server:\n>               git:\n>                 uri: https://gitee.com/shltj/config-repo\n>                 username: shltj\n>                 password: xxxxxxxx\n>                 basedir: e:/config\n>       eureka:\n>         client:\n>           service-url:\n>             defaultZone: http://localhost:8761/eureka/\n>       ```\n>\n>       * 启动效果\n>\n>         ![1538633264680](/img/1538633264680.png)\n\n### 3.4统一配置中心Client端\n\n> * 添加依赖\n>   \n>   ```java\n>   \t<dependency>\n>   \t\t\t<groupId>org.springframework.cloud</groupId>\n>   \t\t\t<artifactId>spring-cloud-config-client</artifactId>\n>   \t</dependency>\n>   ```\n>\n>   * gitee上新建client-dev.yml\n>\n>   ```java\n>   eureka:\n>     client:\n>       service-url:\n>         defaultZone: http://localhost:8761/eureka/\n>   #  instance:\n>   #    hostname: clientName\n>   spring:\n>     application:\n>       name: client\n>   server:\n>     port: 10001\n>   ```\n>\n>   * 将applicatiion.yml 修改为bootstrap.yml springboot默认先加载applicatiion.yml \n>\n>     ```java\n>     spring:\n>       cloud:\n>         config:\n>           discovery:\n>             enabled: true\n>             service-id: config\n>           profile: dev\n>       application:\n>         name: client\n>     ```\n>\n\n  ## 4.SpringCloud Bus 自动刷新配置\n\n### 4.1自动刷新配置原理\n\n![1538635206179](/img/1538635206179.png)### 4.2在config服务端添加amqp的依赖\n\n```java\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.cloud</groupId>\n\t\t\t<artifactId>spring-cloud-starter-bus-amqp</artifactId>\n\t\t</dependency>\n```\n\n### 4.3  在application.yml 中添加rabbitmq的配置并且暴露访问端口(后期可由git服务器的webhook 访问)\n\n```java\n  rabbitmq:\n    port: 5672\n    host: 101.200.44.222\n    username: tong\n    password: tong\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: \"*\"    \n```\n\n### 4.4在client服务端添加rabbitmap的依赖\n\n```java\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-bus-amqp</artifactId>\n        </dependency>\n```\n\n### 4.5注意将springboot和springcloud的版本改成BUILD-SNAPSHOT,M3存在bug.\n\n> **别忘记需要在更新配置的地方添加@RefreshScope注解**\n\n> 访问http://localhost:8080/actuator/bus-refresh(用post请求方式)可以实现动态更新配置,github上的webhook已经支持访问改接口\n\n## 5.mq的使用\n\n### 5.1 mq的应用场景\n\n> * 异步处理\n> * 流量削峰\n> * 日志处理\n> * 应用解耦\n\n## 6.服务网关Zuul\n\n### 6.1服务网关所应具备的要素\n\n> * 稳定性,高可用(7*25小时服务)\n> * 性能,并发性\n> * 安全性\n> * 扩展性\n\n### 6.2常见的服务网关\n\n![1538648760855](/img/1538648760855.png)### 6.3Zuul的特点\n\n> * 路由+过滤器=zuul\n>\n> * 核心是一些列的过滤器\n>\n>   ![1538648953468](/img/1538648953468.png)![1538649013623](/img/1538649013623.png)\n\n### 6.4Zuul的使用\n\n> * 项目的构建\n>\n>   ![1538649205460](/img/1538649205460.png)*  再启动类上添加@EnableZuulProxy注解\n>\n>   ```java\n>   package com.jia.apigetway;\n>   \n>   import org.springframework.boot.SpringApplication;\n>   import org.springframework.boot.autoconfigure.SpringBootApplication;\n>   import org.springframework.cloud.client.discovery.EnableDiscoveryClient;\n>   import org.springframework.cloud.netflix.zuul.EnableZuulProxy;\n>   \n>   @SpringBootApplication \n>   @EnableDiscoveryClient\n>   @EnableZuulProxy\n>   public class ApiGetwayApplication {\n>   \n>   \tpublic static void main(String[] args) {\n>   \t\tSpringApplication.run(ApiGetwayApplication.class, args);\n>   \t}\n>   }\n>   \n>   ```\n>\n>   * 经过服务网关和直接访问服务写法对比(网关+服务+方法)\n>\n>\n>\n>     > ![1538650336849](/img/1538650336849.png)\n>     >\n>     > ![1538650399065](/img/1538650399065.png)\n\n>* 自定义路由bootstrap.yml添加配置\n>\n>  ```java\n>  management:\n>    security:\n>      enabled: false\n>  zuul:\n>    routes:\n>      aaaaa:\n>        path: /myclient/**\n>        serviceId: client\n>  ```\n>\n>  ---\n>\n>  简介写法:\n>\n>  ![1538650911129](/img/1538650911129.png)\n\n> * 排除某些路由的写法:\n>\n>   ![1538651042319](/img/1538651042319.png)* Zuul默认服务间不能传递cookie,传递cookId配置方法\n>\n>   ![1538651174961](/img/1538651174961.png)\n\n### 6.5Zuul典型的使用场景\n\n* 前置过滤器: 限流,鉴权,参数校验调整\n* 后置过滤器:统计,日志\n\n### 6.6Zuul的权限校验 \n\n> 规定请求的参数必须带Token.如果Token为空,校验不通过,实现代码如下:\n>\n> > 注意: shouldFilter方法返回值设置为true\n> >\n> > ​         filterType()方法中配置参数类型\n> >\n> > ​          filterOrder()方法中配置拦截器的优先级\n\n```java\npackage com.jia.apigetway.filter;\n\nimport com.netflix.zuul.ZuulFilter;\nimport com.netflix.zuul.context.RequestContext;\nimport org.apache.http.HttpStatus;\nimport org.springframework.stereotype.Component;\nimport org.springframework.util.StringUtils;\n\nimport javax.servlet.http.HttpServletRequest;\n\nimport static org.springframework.cloud.netflix.zuul.filters.support.FilterConstants.PRE_DECORATION_FILTER_ORDER;\nimport static org.springframework.cloud.netflix.zuul.filters.support.FilterConstants.PROXY_KEY;\n\n@Component\npublic class Tocken extends ZuulFilter {\n    @Override\n    public String filterType() {\n        return PROXY_KEY;\n    }\n\n    @Override\n    public int filterOrder() {\n        return PRE_DECORATION_FILTER_ORDER-1;\n    }\n\n    @Override\n    public boolean shouldFilter() {\n        return true;\n    }\n\n    @Override\n    public Object run() {\n        RequestContext requestContext = RequestContext.getCurrentContext();\n        HttpServletRequest request=requestContext.getRequest();\n        String token=request.getParameter(\"token\");\n        if(StringUtils.isEmpty(token)){\n            requestContext.setSendZuulResponse(false);\n            requestContext.setResponseStatusCode(HttpStatus.SC_UNAUTHORIZED);\n        }\n\n        return null;\n    }\n}\n\n```\n\n### 6.7Zuul的限流\n\n> Zuul使用的是Google开发的令牌桶限流,具体如下图:\n>\n> ![1538652781643](/img/1538652781643.png)\n\n> 代码如下\n>\n> ```java\n> package com.jia.apigetway.filter;\n> \n> import com.google.common.util.concurrent.RateLimiter;\n> import com.netflix.zuul.ZuulFilter;\n> import org.springframework.stereotype.Component;\n> \n> import static org.springframework.cloud.netflix.zuul.filters.support.FilterConstants.PRE_TYPE;\n> import static org.springframework.cloud.netflix.zuul.filters.support.FilterConstants.SERVLET_DETECTION_FILTER_ORDER;\n> \n> @Component\n> public class RateLimiterFilter extends ZuulFilter {\n>     //每秒钟放100令牌\n>     private static final RateLimiter RATE_LIMITER=RateLimiter.create(100);\n> \n>     @Override\n>     public String filterType() {\n>         return PRE_TYPE;\n>     }\n> \n>     @Override\n>     public int filterOrder() {\n>         return SERVLET_DETECTION_FILTER_ORDER-1;\n>     }\n> \n>     @Override\n>     public boolean shouldFilter() {\n>         return true;\n>     }\n> \n>     @Override\n>     public Object run() {\n>         if(!RATE_LIMITER.tryAcquire()){\n>            throw new RuntimeException();   //通过令牌桶限流,如果拿不到令牌就抛出一个异常,感觉好像有bug\n>         }\n>         return null;\n>     }\n> }\n> \n> ```\n\n### 6.8Zuul的权限校验\n\n> 通过Zuul的拦截器实现如下鉴权功能\n>\n> ![1538654024968](/img/1538654024968.png)\n>\n> 在拦截器中具体代码实现如下:\n>\n> ![1538654539209](/img/1538654539209.png)\n\n### 6.8Zuul的跨域解决方法\n\n> 基本解决跨域\n\n```java\npackage com.jia.apigetway;\n\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.cors.CorsConfiguration;\nimport org.springframework.web.cors.UrlBasedCorsConfigurationSource;\nimport org.springframework.web.filter.CorsFilter;\n\nimport java.util.Arrays;\n\n/**\n * 跨域配置\n * C-Cross O-Origin  R-Resource S-Sharing\n */\n@Configuration\npublic class CorsConfig  {\n    public CorsFilter corsFilter(){\n        final UrlBasedCorsConfigurationSource source=new UrlBasedCorsConfigurationSource();\n        final CorsConfiguration config=new CorsConfiguration();\n        config.setAllowCredentials(true);\n        config.setAllowedOrigins(Arrays.asList(\"*\")); //http://www.a.com\n        config.setAllowedHeaders(Arrays.asList(\"*\"));\n        config.setAllowedMethods(Arrays.asList(\"*\"));\n        config.setMaxAge(300l);\n        source.registerCorsConfiguration(\"/**\",config);\n        return  new CorsFilter(source)\n    }\n}\n\n```\n\n> 通用跨域解决方案\n>\n> ![1538655791286](/img/1538655791286.png)\n\n## 7.服务容错Hystrix\n\n> 同步等待会造成资源耗尽\n\n### 7,1Hystrix的功能\n\n> * 服务降级\n> * 依赖隔离\n> * 服务熔断\n> * 监控(Hystrix Dashboard)\n\n### 7.2服务降级\n\n> 优先核心服务,非核心服务不可用或若可用\n>\n> 通过HystrixCommand注解指定\n>\n> fallbackMethod(回退函数)中具体实现降级逻辑\n\n### 7,3Hystrix的使用\n\n> 在client服务去访问client2服务的getMessage方法\n>\n> * 在client服务端添加Hystrix依赖\n>\n>   ```java\n>   \t\t<dependency>\n>   \t\t\t<groupId>org.springframework.cloud</groupId>\n>   \t\t\t<artifactId>spring-cloud-starter-hystrix</artifactId>\n>   \t\t</dependency>\n>   ```\n>\n>   * 启动类上添加@EnableCircuitBreaker注解\n>\n>     ```java\n>     package com.jia.client;\n>     \n>     import org.springframework.boot.SpringApplication;\n>     import org.springframework.boot.autoconfigure.SpringBootApplication;\n>     import org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker;\n>     import org.springframework.cloud.client.discovery.EnableDiscoveryClient;\n>     import org.springframework.cloud.netflix.hystrix.EnableHystrix;\n>     \n>     @SpringBootApplication\n>     @EnableDiscoveryClient\n>     @EnableCircuitBreaker\n>     public class ClientApplication {\n>     \n>     \tpublic static void main(String[] args) {\n>     \t\tSpringApplication.run(ClientApplication.class, args);\n>     \t}\n>     }\n>     ```\n>\n>     * 定义HystrixController实验服务降级\n>\n>       >在方法上添加  @HystrixCommand(fallbackMethod = \"fallback\")注解当方法出现异常或者超时会自动调用fallback();\n>       >\n>       >如果想所有的方法都实现服务降级,可以在Controller上添加@DefaultProperties(defaultFallback=\"xxxxx\") xxxxx为自定义服务降级走的方法\n>\n>       ```java\n>       package com.jia.client.controller;\n>       \n>       import com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;\n>       import org.springframework.web.bind.annotation.GetMapping;\n>       import org.springframework.web.bind.annotation.RestController;\n>       import org.springframework.web.client.RestTemplate;\n>       \n>       @RestController\n>       public class HystrixController {\n>       \n>            RestTemplate restTemplate=new RestTemplate();\n>       \n>            @GetMapping(\"/get\")\n>            @HystrixCommand(fallbackMethod = \"fallback\")\n>            public String getMsg(){\n>                String msg=restTemplate.getForObject(\"http://localhost:10005/getMessage\",String.class);\n>                try {\n>                    Thread.sleep(2000);\n>                } catch (InterruptedException e) {\n>                    e.printStackTrace();\n>                }\n>                return \"from client2 message\"+msg;\n>            }\n>            private  String fallback(){\n>                return \"人太多,挤爆了\";\n>            }\n>       \n>       }\n>       \n>       ```\n\n### 7,4Hystrix服务的熔断\n\n> 断路器实现服务熔断:\n>\n> ![1538702279205](/img/1538702279205.png)\n>\n>    访问getMessage方法,当参数为奇数是抛异常,当异常达到一定次数是(60%)启动断路开关\n\n```java\npackage com.imooc.client3.controller;\n\nimport com.netflix.hystrix.contrib.javanica.annotation.DefaultProperties;\nimport com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;\nimport com.netflix.hystrix.contrib.javanica.annotation.HystrixProperty;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.RestController;\nimport org.springframework.web.client.RestTemplate;\n\n@RestController\n@DefaultProperties(defaultFallback = \"defaultFallback\")\npublic class HystrixController {\n    private RestTemplate restTemplate = new RestTemplate();\n//    服务的超时配置\n\n//    @HystrixCommand(fallbackMethod = \"fallback\",commandProperties ={\n//            @HystrixProperty(name = \"execution.isolation.thread.timeoutInMilliseconds\",value=\"3500\")\n//    } )\n    @HystrixCommand(commandProperties = {\n            @HystrixProperty(name=\"circuitBreaker.enabled\",value = \"true\"),   //设置熔断\n            @HystrixProperty(name=\"circuitBreaker.requestVolumeThreshold\",value = \"10\"),\n            @HystrixProperty(name=\"circuitBreaker.sleepWindowInMilliseconds\",value = \"10000\"),\n            @HystrixProperty(name=\"circuitBreaker.errorThresholdPercentage\",value = \"60\")\n    })\n    @GetMapping(\"/messageT\")\n    public String getMessage(@RequestParam(\"number\") Integer number ) {\n        String result=null;\n        if(number%2==0){\n             result = this.restTemplate.getForObject(\"http://localhost:10006/tong\",String.class);\n\n        }else{\n            int a=1/0;\n             result=\"1111\";\n        }\n\n        System.out.println(result);\n        return result;\n    }\n\n    private String fallback() {\n        return \"出故障了!!!\";\n    }\n\n    @HystrixCommand\n    @GetMapping(\"/messageT1\")\n    public String getMessage1() throws RuntimeException {\n        String result = this.restTemplate.getForObject(\"http://localhost:10006/tong\", String.class);\n\n        System.out.println(result);\n        int a = 1 / 0;\n        return result;\n\n\n    }\n\n    private String defaultFallback() {\n        return \"默认方法出故障了!!!!!\";\n    }\n\n}\n\n```\n\n### 7.5feign和Hystrix的使用\n\n> feign的使用(内置ribbon):\n>\n> * 添加依赖\n>\n>   ```java\n>   <dependency>\n>       <groupId>org.springframework.cloud</groupId>\n>       <artifactId>spring-cloud-starter-openfeign</artifactId>\n>   </dependency>\n>   ```\n>\n> * 启动类上添加注解@EnableFeignClients\n>\n>   ```java\n>   package com.jia.client;\n>   \n>   import org.springframework.boot.SpringApplication;\n>   import org.springframework.boot.autoconfigure.SpringBootApplication;\n>   import org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker;\n>   import org.springframework.cloud.client.discovery.EnableDiscoveryClient;\n>   import org.springframework.cloud.openfeign.EnableFeignClients;\n>   \n>   @SpringBootApplication\n>   @EnableDiscoveryClient\n>   @EnableCircuitBreaker\n>   @EnableFeignClients\n>   public class ClientApplication {\n>   \n>   \tpublic static void main(String[] args) {\n>   \t\tSpringApplication.run(ClientApplication.class, args);\n>   \t}\n>   }\n>   ```\n>\n>   * 访问远程服务的方法\n>\n>     ```java\n>     package com.jia.client.controller;\n>     \n>     \n>     import org.springframework.cloud.openfeign.FeignClient;\n>     import org.springframework.web.bind.annotation.PostMapping;\n>     \n>     @FeignClient(\"client2\")\n>     public interface Client2Feign {\n>         @PostMapping(\"/client2/getMessage\")\n>         String get();\n>     }\n>     \n>     ```\n>\n>     ----\n>\n>     feign和Hystrix结合使用:\n>\n>     > bootstrap.yml中添加配置\n>     >\n>     > ```java\n>     > feign:\n>     >   hystrix:\n>     >     enable: true\n>     > ```\n>     >\n>     >\n>\n>     > 如果发生异常执行class中的方法\n>\n>     ```java\n>     package com.jia.client.controller;\n>     \n>     \n>     import org.springframework.cloud.openfeign.FeignClient;\n>     import org.springframework.stereotype.Component;\n>     import org.springframework.web.bind.annotation.PostMapping;\n>     \n>     @FeignClient(value = \"client2\",fallback = Client2Feign.Client2Fallback.class)\n>     public interface Client2Feign {\n>         @PostMapping(\"/client2/getMessage\")\n>         String get();\n>         @Component\n>         class Client2Fallback implements Client2Feign{\n>             @Override\n>             public String get() {\n>                 return null;\n>             }\n>         }\n>     }\n>     \n>     ```\n\n### 7.6Hystrix-dashboard可视化组件的使用\n\n> * 添加依赖\n>\n>   ```java\n>        <dependency>\n>           <groupId>org.springframework.cloud</groupId>\n>           <artifactId>spring-cloud-starter-hystrix-dashboard</artifactId>\n>        </dependency>\n>        <dependency>\n>            <groupId>org.springframework.boot</groupId>\n>            <artifactId>spring-boot-starter-actuator</artifactId>\n>         </dependency>\n>   ```\n>\n>   * 启动类上添加注解@EnableHystrixDashboard\n>\n>     ```java\n>     package com.jia.client;\n>     \n>     import org.springframework.boot.SpringApplication;\n>     import org.springframework.boot.autoconfigure.SpringBootApplication;\n>     import org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker;\n>     import org.springframework.cloud.client.discovery.EnableDiscoveryClient;\n>     import org.springframework.cloud.netflix.hystrix.dashboard.EnableHystrixDashboard;\n>     import org.springframework.cloud.openfeign.EnableFeignClients;\n>     \n>     @SpringBootApplication\n>     @EnableDiscoveryClient\n>     @EnableCircuitBreaker\n>     @EnableFeignClients\n>     @EnableHystrixDashboard\n>     public class ClientApplication {\n>     \n>     \tpublic static void main(String[] args) {\n>     \t\tSpringApplication.run(ClientApplication.class, args);\n>     \t}\n>     }\n>     \n>     ```\n>\n>     * 访问/hystrix路径\n>\n>       ![1538707724714](/img/1538707724714.png)* client服务端添加如下配置:\n>\n>       ```java\n>       management:\n>         context-path: /\n>       ```\n>\n>       * 监控视图\n>\n>         ![1538708343150](/img/1538708343150.png)\n\n## 8.服务的追踪(链路监控Sleuth)\n\n> * 添加依赖\n>\n>   ```java\n>   \t\t<dependency>\n>   \t\t\t<groupId>org.springframework.cloud</groupId>\n>   \t\t\t<artifactId>spring-cloud-starter-sleuth</artifactId>\n>   \t\t</dependency>\n>   ```\n>\n>  * 使用**OpenZIPkin**查看服务的追踪\n>\n>     > * 用docker安装软件\n>     >\n>     >   docker pull openzipkin/zipkin\n>     >\n>     >   docker run -d -p 9411:9411 zipkin\n>     >\n>     >   浏览器访问:http://101.200.44.222:9411/zipkin/\n>     >\n>     >   ![1538710627440](/img/1538710627440.png)\n>\n>  * client服务添加相应依赖\n>\n>     ```java\n>     <dependency>\n>        <groupId>org.springframework.cloud</groupId>\n>        <artifactId>spring-cloud-sleuth-zipkin</artifactId>\n>     </dependency>\n>     ```\n>\n>   * bootstrap.yml中添加配置\n>\n>       ```java\n>       zipkin:\n>         base-url: http://101.200.44.222:9411\n>       ```\n>\n>           * 设置抽样观察百分比为1\n>\n>         ```java\n>         sleuth:\n>           sampler:\n>             percentage: 1f\n>         ```\n>\n> * 展示效果\n>\n>      ![1538711526837](/img/1538711526837.png)\n>\n\n##  9.分布式追踪系统\n\n### 9.1核心步骤(OpenTracing规范)\n\n![1538711826394](/img/1538711826394.png)\n\n> * 数据采集\n> * 数据存储\n> * 查询展示\n\n## 10.使用docker部署项目\n\n### 10.1docker部署eureka服务注册中心\n\n> * Docerfile文件内容\n>\n> ```dockerfile\n> FROM hub.c.163.com/library/java:8-alpine\n> ADD app.jar  app.jar\n> EXPOSE 8761\n> ENTRYPOINT [\"java\",\"-jar\",\"/app.jar\"]\n> ```\n>\n> * 构建命令:docker build -t springcloud2/eureka .\n>\n> * 运行命令:docker run -d -p 8761:8761 springcloud2/eureka\n>\n> * 网易云上传镜像:https://www.163yun.com/help/documents/15587826830438400\n>\n> * 访问成功:\n>\n>   ![1538714796176](/img/1538714796176.png)\n\n### 10.2 rancher的使用\n\n> Rancher是一个开源的企业级全栈化容器部署管理平台(为了更方便的管理docker)\n>\n> > 安装rancher命令:sudo docker run -d --restart=unless-stopped -p 8080:8080 rancher/server:stable\n>\n> ![1538717959699](/img/1538717959699.png)\n>\n>* 需添加一台主机\n","tags":["java"],"categories":["开源框架"]},{"title":"自定义注解+反射实现orm框架的映射与查询功能","url":"/2018/10/04/自定义注解+反射实现orm框架的映射与查询功能/","content":"\n**积极一点,耐心一点,你想要的,时光都会慢慢带到你面前!**<Excerpt in index | 首页摘要>\n对注解和反射的加深学习,对ORM框架的加深理解 \n<!-- more -->\n<The rest of contents | 余下全文>\n\n> **自定义orm框架例如:Mybatis,hibernate的@Table,@Column注解,通过反射解析注解实现对应表的查询功能,对注解加深学习,对orm框架的思想进行理解.**\n*将定义的注解进行解析取出数据库表的名字,表对应字段的名字,以及字段对应的value进行sql的拼装,最后通过jdbc进行查询.* \n具体代码如下:\n\n## 数据表\n\n```java\n@Table(\"user\")\npublic class Filter {\n    @Column(\"id\")\n    private int id;\n    @Column(\"userName\")\n    private String userName;\n    @Column(\"nickName\")\n    private  String nickName;\n    @Column(\"age\")\n    private int age;\n    @Column(\"city\")\n    private String city;\n    @Column(\"email\")\n    private String email;\n    @Column(\"mobile\")\n    private String mobile;\n    public int getId() {\n        return id;\n    }\n\n    public void setId(int id) {\n        this.id = id;\n    }\n\n    public String getUserName() {\n        return userName;\n    }\n\n    public void setUserName(String userName) {\n        this.userName = userName;\n    }\n\n    public String getNickName() {\n        return nickName;\n    }\n\n    public void setNickName(String nickName) {\n        this.nickName = nickName;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public String getCity() {\n        return city;\n    }\n\n    public void setCity(String city) {\n        this.city = city;\n    }\n\n    public String getEmail() {\n        return email;\n    }\n\n    public void setEmail(String email) {\n        this.email = email;\n    }\n\n    public String getMobile() {\n        return mobile;\n    }\n\n    public void setMobile(String mobile) {\n        this.mobile = mobile;\n    }\n}\n\n```\n\n\n\n## 自定义注解\n\n```java\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Table {\n    String value();\n}\n\n```\n\n------\n\n```java\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Target(ElementType.FIELD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Column {\n    String value();\n}\n\n```\n\n## 对注解的解析和测试类\n\n```java\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\n\npublic class Test {\n    public static void main(String[] args) {\n        Filter f1 = new Filter();\n        f1.setAge(10);\n        Filter f2 = new Filter();\n        f2.setNickName(\"congcong\");\n        Filter f3 = new Filter();\n        f3.setEmail(\"111@qq.com,222@163.com,333@outlook.com\");\n        String sql1 = query(f1);\n        String sql2 = query(f2);\n        String sql3 = query(f3);\n        System.out.println(sql1);\n        System.out.println(sql2);\n        System.out.println(sql3);\n    }\n    public static String query(Filter filter) {\n        StringBuilder sb = new StringBuilder();\n        //1.获取Class\n        Class clazz = filter.getClass();\n        //2.获取Table注解\n        if (!clazz.isAnnotationPresent(Table.class)) {\n            return null;\n        }\n        Table table = (Table) clazz.getAnnotation(Table.class);\n        String tableName = table.value();\n        sb.append(\"select * from \").append(tableName).append(\" where 1=1 \");\n        //3.获取表中的字段\n        Field[] fields = clazz.getDeclaredFields();\n        for (Field f : fields) {\n            //4.处理每个字段对应的SQL\n            if (!f.isAnnotationPresent(Column.class)) {\n                continue;\n            }\n            //4.1获取字段上的注解\n            Column column = f.getAnnotation(Column.class);\n            String columnName = column.value();\n            //4.2获取字段的值\n            String fieldName = f.getName();\n            //4.3获取字段的get方法\n            String getMethodName = \"get\" + fieldName.substring(0, 1).toUpperCase()\n                    + fieldName.substring(1);\n            Object fieldValue = null;\n            try {\n                Method getMethod = clazz.getDeclaredMethod(getMethodName);\n                fieldValue = getMethod.invoke(filter);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            //4.4拼装SQL\n            if (fieldValue == null || (fieldValue instanceof Integer && (Integer) fieldValue == 0)) {\n                continue;\n            }\n            if (fieldValue instanceof String) {\n                sb.append(\"and \").append(columnName).append(\"=\");\n                if (((String) fieldValue).contains(\",\")) {\n                    String[] values = ((String) fieldValue).split(\",\");\n                    sb.append(\" in(\");\n                    for (String v : values) {\n                        sb.append(\"'\").append(v).append(\"'\").append(\",\");\n                    }\n                    sb.deleteCharAt(sb.length() - 1);\n                    sb.append(\")\");\n                }\n            } else {\n                sb.append(\"'\").append(fieldValue)\n                        .append(\"'\").append(\" \");\n            }\n            if (fieldValue instanceof Integer) {\n                sb.append(\"and \").append(columnName).append(\"=\").append(fieldValue).append(\" \");\n            }\n        }\n        return sb.toString();\n    }\n}\n```\n\n> 通过jdbc可实现表的完整查询功能功能,在此略过","tags":["java"],"categories":["开源框架"]},{"title":"初识Docker","url":"/2018/10/03/初识Docker/","content":" **读书,健身,努力工作,关心身体,保持好心情,成为最棒的自己!**<Excerpt in index | 首页摘要>\n docker是一个神奇的开发工具!\n\n<!-- more -->\n<The rest of contents | 余下全文>\n## 1.什么是docker\n\n> docker是一个世界领先的容器化平台.网上对他的定义有很多,说法过于复杂化了.我是通过学习springcloud认识的docker的,感觉它就是一个神器.个人理解的docker就是一个背包,你可以把你需要的东西放在这个背包里,然后这个背包你可以分享给任何人.你也可以从免费的商店里获得别人的背包,无论你咋什么样的环境下都可以正常使用这个背包.\n>\n> docker是跨平台的,支持windows,maxos,linux\n\n## 2.docker思想\n\n![1538544866753](/img/1538544866753.png)\n\n## 3.docker解决了哪些问题\n\n### 3.1换一个运行环境程序跑不起来\n\n> 自己本地运行好好的程序放在别人的电脑上就不行了,曾经亲自体会过,非常苦恼.一是苦恼还得在别人的电脑上调bug,更可怕的是时时刻刻担心自己的程序放在第三台电脑上也会down掉了.这种恐惧远胜过修改bug.相信这种问题无论是哪个程序员都或多或少遇到过.docker的出现完美的解决了这个问题,它将你写好的代码,运行环境都放在一个\"集装箱\"里,给别人的不只是代码,而是一整套的程序所需的运行环境.在你的机器上怎们运行,在别人的电脑或者服务器上就会怎样运行.\n\n### 3.2完美实现了隔离\n> docker再启动是为每个容器限定的CPU,硬盘和网络,不会出现一个程序进入了死循环,从而影响到其他程序的事情发生.\n\n### 3.3弹性伸缩变得简单\n> 就电商来说:双十一几亿人同时在线,按照平时的资源配置肯定吃不消.如果按照双十一的业务量来配置资源平时又是极大的浪费.所以就要弹性的加减服务器,写过java程序的小伙伴们到知道,要想在一台电脑上跑java程序需要安装至少需要安装jre,配置环境,再把代码拷过来运行,中间可能还会出现问题.使用docker扩展服务器将变成按一下按钮秒秒钟添加n台服务器那么容易.\n\n## 4.走进docker\n\n> docker的三个关键字:镜像,仓库,容器\n>\n> docker的三个关键单词:Build,Ship,Run\n\n![1538546571188](/img/1538546571188.png)\n\n> -镜像:\n>\n> -容器:\n>\n> -仓库:\n>\n> * 官网仓库:hub.docker.com \n> * 网易仓库:c.163.com\n\n## 5.docker的安装\n\n> 网上教程很多,懒得再详细总结\n\n## 6.第一个docker镜像\n\n###  6.1docker工作流程\n\n![1538548365242](/img/1538548365242.png)\n\n### 6.2常用的命令\n\n> * docker pull [OPTIONS] NAME[:TAG]  拉去镜像   举例:docker pull hello-world\n> * docker images [OPTIONS]_[ REPOSITORY[:TAG]] 查看镜像\n> * docker run hello-world\n> * docker ps\n> * docker exec -it [代号] bash   :进入容器(正在运行的)\n> * which nginx : 查看Nginx的位置\n> * netstat -na|grep 10001 : 检查端口是否开放\n> * docker run -d -p 10001:80 nginx   :开放容器的80端口映射到本机的10001端口\n> * docker run -d -P  nginx :随机开放端口映射过来\n> * docker build .   : 在当前目录运行构建的Dockerfile 文件\n> * docker build  -t  Jpress:latest  .   :给镜像起一个名字和版本\n\n## 7.运行Nginx服务器镜像\n\n![1538548580593](/img/1538548580593.png)\n\n## 8.docker的网络\n\n![1538549437822](/img/1538549437822.png)![1538549459787](./img/1538549459787.png)\n\n## 9.制作自己的镜像\n\n> * Dockerfille : 制作镜像\n> * docker build : 构建镜像","tags":["docker"],"categories":["开发工具"]},{"title":"突破算法第11天-红黑树","url":"/2017/10/30/test2/","content":"** 累了选择休息而不是选择放弃!** <Excerpt in index | 首页摘要>\n红黑树\n<!-- more -->\n<The rest of contents | 余下全文>\n{% blockquote %}\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem.\n{% endblockquote %}\n\n\n\n{% blockquote David Levithan, Wide Awake %}\nDo not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy.\n{% endblockquote %}\n\n\n{% codeblock %}\npublic static void main\n{% endcodeblock %}\n","tags":["开发工具"],"categories":["开发工具"]}]