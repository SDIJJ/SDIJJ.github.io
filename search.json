[{"title":"MySql复习","url":"/2018/11/02/MySql复习/","content":" **仰望星空,脚踏实地**<Excerpt in index | 首页摘要>\n\n\n<!-- more -->\n<The rest of contents | 余下全文>\n### MySql 复习\n\n#### 完成对MYSQL数据库的多表查询及建表的操作\n\n#### 掌握MYSQL中多表的创建及多表的查询\n\n#### 掌握MYSQL中的表关系分析并能正确建表\n\n```sql\n-- 编写顺序\nS..F..W..G..H..O\nselect .. from .. where .. group by .. having .. order by\n-- 执行顺序\nF .. W .. G .. H .. S .. O\nfrom .. where .. group by .. having .. select .. order by\n```\n\n内容:\n\n​\t数据库的创建 : create database 数据库的名 character set 字符集  collate 校对规则\n\n​\t数据库的删除: drop database 数据库名\n\n​\t修改: alter database 数据库 character set 字符集(utf8)\n\n​\t查询:  show databases;\n\n​\t\t  show create database 数据库的名字\n\n​\t\t  select database();\n\n​\t切换数据库 :\n\n​\t\t\tuse 数据库的名字\n\n​\t\n\n​\t表结构的操作:\n\n​\t\t创建:  create table 表名(\t\n\n​\t\t\t\t列名 列的类型  列的约束,\n\n​\t\t\t\t列名 列的类型  列的约\n\n​\t\t\t)\n\n​\t\t\t列的类型: char / varchar   \n\n​\t\t\t列的约束: \n\n​\t\t\t\t\tprimary key 主键约束\n\n​\t\t\t\t\tunique : 唯一约束\n\n​\t\t\t\t\tnot null 非空约束\n\n​\t\t      自动增长 : auto_increment\n\n​\t     删除 :  drop table 表名\n\n​\t    修改:   alter table 表名 (add, modify, change , drop)\n\n​\t\t\trename table 旧表名  to 新表名\n\n​\t\t\talter table 表名 character set 字符集\n\n​\t   查询表结构:\n\n​\t\t\tshow tables; 查询出所有的表\n\n​\t\t\tshow create table 表名: 表的创建语句, 表的定义\n\n​\t\t\tdesc 表名:　表的结构\n\n\n\n​\t表中数据的操作\n\n​\t\t插入：　 insert into 表名(列名,列名) values(值1,值2);\n\n​\t\t删除:        delete from 表名 [where 条件]\n\n​\t\t修改:        update 表名 set 列名='值' ,列名='值' [where 条件];\n\n​\t\t查询:    select [distinct]  * [列名1,列名2] from 表名 [where 条件]\n\n​\t\t\t  as关键字: 别名\n\n​\t\t\t   where条件后面:\n\n​\t\t\n\n​\t\t\t\t\t关系运算符:  > >= < <= !=  <>\n\n​\t\t\t\t\t\t--判断某一列是否为空:  is null    is not null\n\n​\t\t\t\t\t\tin 在某范围内\n\n​\t\t\t\t\t\tbetween...and\n\n​\t\t\t\t\t逻辑运算符: and or not\n\n​\t\t\t\t\t模糊查询:  like    \n\n​\t\t\t\t\t\t\t_ : 代表单个字符\n\n​\t\t\t\t\t\t\t%: 代表的是多个字符\n\n​\t\t\t\t\t分组: group by \n\n​\t\t\t\t\t分组之后条件过滤:  having\n\n​\t\t\t\t\t聚合函数: sum()  ,avg() , count()  ,max(), min()\n\n​\t\t\t\t\t排序: order by  (asc 升序, desc 降序)\t\t\t\t\t\n\n​\t\t\t\t\t\n\nSQL 会创建多表及多表的关系\n\n#### 需求:\n\n分类表和商品表之间是不是有关系? 如果有关系,在数据库中如何表示这种关系\n\n```sql\ncreate table category(\n  cid int primary key auto_increment,\n  cname varchar(10),\n  cdesc varchar(31)\n);\n\ninsert into category values(null,'手机数码','电子产品,黑马生产');\ninsert into category values(null,'鞋靴箱包','江南皮鞋厂倾情打造');\ninsert into category values(null,'香烟酒水','黄鹤楼,茅台,二锅头');\ninsert into category values(null,'酸奶饼干','娃哈哈,蒙牛酸酸乳');\ninsert into category values(null,'馋嘴零食','瓜子花生,八宝粥,辣条');\n\nselect * from category;\nselect cname,cdesc from category;\n\n--所有商品\n1.商品ID\n2.商品名称\n3.商品的价格\n4.生产日期\n5.商品分类ID\n\n商品和商品分类 : 所属关系\ncreate table product(\n\tpid int primary key auto_increment,\n  \tpname varchar(10),\n  \tprice double,\n  \tpdate timestamp,\n  \tcno int\n);\n\ninsert into product values(null,'小米mix4',998,null,1);\ninsert into product values(null,'锤子',2888,null,1);\ninsert into product values(null,'阿迪王',99,null,2);\ninsert into product values(null,'老村长',88,null,3);\ninsert into product values(null,'劲酒',35,null,3);\ninsert into product values(null,'小熊饼干',1,null,4);\ninsert into product values(null,'卫龙辣条',1,null,5);\ninsert into product values(null,'旺旺大饼',1,null,5);\n\n//插入数据会失败\ninsert into product values(null,'充气的',1,null,12);\n\n```\n\n \n\n#### 技术分析:\n\n- 多表之间的关系如何来维护\n\n  外键约束: foreign key\n\n  - 给product中的这个cno 添加一个外键约束\n\n    alter table product add foreign key(cno)  references  category(cid);\n\n  - 自己挖坑\n\n  - 从分类表中,删除分类为5信息,\n\n    - delete from category where cid =5;  //删除失败\n    - 首先得去product表, 删除所有分类ID5  商品\n\n- 建数据库原则:\n\n  - 通常情况下,一个项目/应用建一个数据库\n\n\n- 多表之间的建表原则\n\n  - 一对多 : 商品和分类\n\n    - 建表原则: 在多的一方添加一个外键,指向一的一方的主键\n\n      ​\n\n  - 多对多: 老师和学生, 学生和课程\n\n    建表原则: 建立一张中间表,将多对多的关系,拆分成一对多的关系,中间表至少要有两个外键,分别指向原来的那两张表\n\n    ​\n\n  - 一对一: 班级和班长, 公民和身份证, 国家和国旗\n\n    - 建表原则:  \n\n      - 将一对一的情况,当作是一对多情况处理,在任意一张表添加一个外键,并且这个外键要唯一,指向另外一张表\n      - 直接将两张表合并成一张表\n      - 将两张表的主键建立起连接,让两张表里面主键相等\n\n    - 实际用途: 用的不是很多.    (拆表操作  )\n\n      - 相亲网站: \n        - 个人信息 : 姓名,性别,年龄,身高,体重,三围,兴趣爱好,(年收入,  特长,学历, 职业, 择偶目标,要求)\n        - 拆表操作 : 将个人的常用信息和不常用信息,减少表的臃肿, \n\n      ​\n\n\n\n\n\n​\n\n\n\n \n\n- 网上商城表实例的分析:  用户购物流程\n\n  ​\n\n\n- 用户表 (用户的ID,用户名,密码,手机)\n\n  ```sql\n  create table user(\n  \tuid int primary key auto_increment,\n    \tusername varchar(31),\n    \tpassword varchar(31),\n    \tphone  varchar(11)\n  );\n\n  insert into user values(1,'zhangsan','123','13811118888');\n  ```\n\n- 订单表 (订单编号,总价,订单时间 ,地址,外键用户的ID)\n\n  ```sql\n    create table orders(\n    \toid int primary key auto_increment,\n      \tsum int not null,\n        otime timestamp,\n      \taddress varchar(100),\n      \tuno int,\n      \tforeign key(uno) references user(uid)\n    );\n    insert into orders values(1,200,null,'黑马前台旁边小黑屋',1);\n    insert into orders values(2,250,null,'黑马后台旁边1702',1);\n  ```\n\n\n\n-   商品表 (商品ID, 商品名称,商品价格,外键cno)\n\n    ```sql\n    create table product(\n    \tpid int primary key auto_increment,\n      \tpname varchar(10),\n      \tprice double,\n      \tcno int,\n      \tforeign key(cno) references category(cid)\n    );\n\n    insert into product values(null,'小米mix4',998,1);\n    insert into product values(null,'锤子',2888,1);\n    insert into product values(null,'阿迪王',99,2);\n    insert into product values(null,'老村长',88,3);\n    insert into product values(null,'劲酒',35,3);\n    insert into product values(null,'小熊饼干',1,4);\n    insert into product values(null,'卫龙辣条',1,5);\n    insert into product values(null,'旺旺大饼',1,5);\n    ```\n\n    ​\n\n\n\n- 订单项: 中间表(订单ID,商品ID,商品数量,订单项总价)\n\n  ```sql\n  create table orderitem(\n  \tono int,\n    \tpno int,\n    \tforeign key(ono) references orders(oid),\n    \tforeign key(pno) references product(pid),\n    \tocount int,\n    \tsubsum double\n  );\n  --给1号订单添加商品 200块钱的商品\n  insert into orderitem values(1,7,100,100);\n  insert into orderitem values(1,8,101,100);\n  \n  --给2号订单添加商品 250块钱的商品 ()\n  insert into orderitem values(2,5,1,35);\n  insert into orderitem values(2,3,3,99);\n  ```\n\n  ​\n\n\n\n\n-   商品分类表(分类ID,分类名称,分类描述)\n\n    ```sql\n    create table category(\n    \tcid int primary key auto_increment,\n      \tcname varchar(15),\n      \tcdesc varchar(100)\n    );\n\n    insert into category values(null,'手机数码','电子产品,黑马生产');\n    insert into category values(null,'鞋靴箱包','江南皮鞋厂倾情打造');\n    insert into category values(null,'香烟酒水','黄鹤楼,茅台,二锅头');\n    insert into category values(null,'酸奶饼干','娃哈哈,蒙牛酸酸乳');\n    insert into category values(null,'馋嘴零食','瓜子花生,八宝粥,辣条');\n    ```\n\n\n\n  \n\n\n- 多表之间的关系如何维护: 外键约束 :   foreign key\n- 添加一个外键: alter table product add foreign key(cno)  references category(cid);\n  - ​\t\tforeign key(cno) references category(cid)\n  - 删除的时候, 先删除外键关联的所有数据,再才能删除分类的数据\n- 建表原则:\n  - 一对多:\n    - 建表原则: 在多的一方增加一个外键,指向一的一方\n  - 多对多:\n    - 建表原则: 将多对多转成一对多的关系,创建一张中间表\n  - 一对一: 不常用, 拆表操作\n    - 建表原则:  将两张表合并成一张表\n      - 将两张表的主键建立起关系\n      - 将一对一的关系当作一对多的关系去处理\n\n\n\n\n主键约束: 默认就是不能为空, 唯一\n\n-  外键都是指向另外一张表的主键\n-  主键一张表只能有一个\n\n唯一约束:  列面的内容, 必须是唯一, 不能出现重复情况, 为空\n\n- 唯一约束不可以作为其它表的外键\n- 可以有多个唯一约束\n\n\n\n一对多 : 建表原则: 在多的一方添加一个外键,指向一的一方\n\n多对多: 建表原则:\n\n​\t\t拆成一对多\n\n​\t\t创建一张中间表, 至少要有两个外键, 指向原来的表\n\n一对一: 建表原则: 合并一张表, 将主键建立关系 , 将它当作一对多的情况来处理\n\n\n\n\n\n- 数据库客户端软件\n\n  ​\n\n\n\n### 使用商城表完成对商品信息的多表查询\n\n#### 需求分析:\n\n在我们的商城案例中,我的订单中包含很多信息.打开我的订单需要去查询表\n\n#### 技术分析:\n\n#### 多表查询\n\n- 交叉连接查询  笛卡尔积\n\n```sql\nSELECT * FROM USER ,orders ;\n```\n\n\n\n- 内连接查询\n\n```sql\nSELECT * FROM `user` u JOIN orders  o ON u.uid=o.oid;\n```\n\n\n\n- 左外连接\n\n\n\n\n\n- 右外连接  \n\n\n\n\n\n\n\n\n\n\n#### 分页查询\n\n- 每页数据数据3\n\n- 起始索引从0 \n\n- 第1页: 0\n\n- 第2页: 3\n\n  起始索引:  index 代表显示第几页 页数从1开始\n\n  每页显示3条数据\n\n  startIndex  = (index-1)*3\n\n  ​\n\n第一个参数是索引 \n\n第二个参数显示的个数\n\nselect * from product limit 0,3;\n\nselect * from product limit 3,3;\n\n\n\n#### 子查询(了解的内容,非常重要)\n\n查询出(商品名称,商品分类名称)信息\n\n```sql\n\n```\n\n  查询分类名称为手机数码的所有商品\n\n```sql\nselect * from product where cname ='手机数码';\n\n```\n\n#### 练习题\n\n- 按照商品分类的名称统计商品的个数:\n\n```sql\n \n```\n\n- 查询1号订单的订单项信息和商品信息\n\n```sql\n\n```\n\n\n#### 多表查询练习数据\n\n- 员工信息表\n\n```sql\n--员工信息表\nCREATE TABLE emp(\n\tempno INT,\n\tename VARCHAR(50),\n\tjob VARCHAR(50),\n\tmgr\tINT,\n\thiredate DATE,\n\tsal\tDECIMAL(7,2),\n\tcomm DECIMAL(7,2),\n\tdeptno INT\n) ;\n\nINSERT INTO emp values(7369,'SMITH','CLERK',7902,'1980-12-17',800,NULL,20);\nINSERT INTO emp values(7499,'ALLEN','SALESMAN',7698,'1981-02-20',1600,300,30);\nINSERT INTO emp values(7521,'WARD','SALESMAN',7698,'1981-02-22',1250,500,30);\nINSERT INTO emp values(7566,'JONES','MANAGER',7839,'1981-04-02',2975,NULL,20);\nINSERT INTO emp values(7654,'MARTIN','SALESMAN',7698,'1981-09-28',1250,1400,30);\nINSERT INTO emp values(7698,'BLAKE','MANAGER',7839,'1981-05-01',2850,NULL,30);\nINSERT INTO emp values(7782,'CLARK','MANAGER',7839,'1981-06-09',2450,NULL,10);\nINSERT INTO emp values(7788,'SCOTT','ANALYST',7566,'1987-04-19',3000,NULL,20);\nINSERT INTO emp values(7839,'KING','PRESIDENT',NULL,'1981-11-17',5000,NULL,10);\nINSERT INTO emp values(7844,'TURNER','SALESMAN',7698,'1981-09-08',1500,0,30);\nINSERT INTO emp values(7876,'ADAMS','CLERK',7788,'1987-05-23',1100,NULL,20);\nINSERT INTO emp values(7900,'JAMES','CLERK',7698,'1981-12-03',950,NULL,30);\nINSERT INTO emp values(7902,'FORD','ANALYST',7566,'1981-12-03',3000,NULL,20);\nINSERT INTO emp values(7934,'MILLER','CLERK',7782,'1982-01-23',1300,NULL,10);\nINSERT INTO emp values(7981,'MILLER','CLERK',7788,'1992-01-23',2600,500,20);\n```\n\n- 部门信息表\n\n```sql\nCREATE TABLE dept(\n\tdeptno\t\tINT,\n\tdname\t\tvarchar(14),\n\tloc\t\tvarchar(13)\n);\n\nINSERT INTO dept values(10, 'ACCOUNTING', 'NEW YORK');\nINSERT INTO dept values(20, 'RESEARCH', 'DALLAS');\nINSERT INTO dept values(30, 'SALES', 'CHICAGO');\nINSERT INTO dept values(40, 'OPERATIONS', 'BOSTON');\n```\n\n- 基本查询\n\n```sql\n--所有员工的信息\nselect *from emp;\n--薪资大于等于1000并且小于等于2000的员工信息\nSELECT * FROM emp WHERE sal > 1000 AND sal <2000;\n--从员工表中查询出所有的部门编号\nSELECT emp.`deptno` FROM emp GROUP BY emp.deptno;\n--查询出名字以A开头的员工的信息\nSELECT * FROM emp WHERE emp.`ename` LIKE 'A%';\n--查询出名字第二个字母是L的员工信息\nSELECT * FROM emp WHERE emp.`ename` LIKE '_L%';\n--查询出没有奖金的员工信息\nSELECT * FROM emp WHERE emp.`comm` IS NULL;\n--所有员工的平均工资\nSELECT AVG(emp.`sal`) 平均工资  FROM emp;\n--所有员工的工资总和\nSELECT SUM(emp.`sal`) 平均工资  FROM emp;\n--所有员工的数量\nSELECT COUNT(emp.`empno`)   FROM emp;\n--最高工资\nSELECT  MAX(emp.`sal`) FROM emp;\n--最少工资\nSELECT  MIN(emp.`sal`) FROM emp;\n--最高工资的员工信息\n--最低工资的员工信息\nSELECT * FROM emp HAVING  emp.`sal` = MIN(emp.`sal`);\n```\n\n- 分组查询\n\n```sql\n--每个部门的平均工资\n```\n\n- 子查询\n\n```sql\n-- 单行子查询(> < >= <= = <>)\n\t-- 查询出高于10号部门的平均工资的员工信息\n\t\n-- 多行子查询(in  not in any all)    >any  >all\n\t-- 查询出比10号部门任何员工薪资高的员工信息\n\n-- 多列子查询(实际使用较少)   in\n\t-- 和10号部门同名同工作的员工信息\n-- Select接子查询\n\t-- 获取员工的名字和部门的名字\n-- from后面接子查询\n\t-- 查询emp表中经理信息\n-- where 接子查询\n\t-- 薪资高于10号部门平均工资的所有员工信息\n-- having后面接子查询\n\t-- 有哪些部门的平均工资高于30号部门的平均工资\n\n-- 工资>JONES工资\n-- 查询与SCOTT同一个部门的员工\n-- 工资高于30号部门所有人的员工信息\n-- 查询工作和工资与MARTIN完全相同的员工信息\n-- 有两个以上直接下属的员工信息\n-- 查询员工编号为7788的员工名称,员工工资,部门名称,部门地址\n```\n\n- SQL查询的综合案例\n1. 查询出高于本部门平均工资的员工信息\n\n\n2. 列出达拉斯加工作的人中,比纽约平均工资高的人\n3. 查询7369员工编号,姓名,经理编号和经理姓名\n4. 查询出各个部门薪水最高的员工所有信息\n\n\n#### 面试题\n\n```sql\nCREATE TABLE test(\n  name CHAR(20),\n  kecheng CHAR(20),\n  fenshu CHAR(20)\n);\n\nINSERT INTO test VALUES('张三','语文',81),\n('张三','数学',75),\n('李四','语文',76),\n('李四','数学',90),\n('王五','语文',81),\n('王五','数学',82);\n\n--请用一条Sql语句查处分数大于80的学生\n```\n\n  ```sql\n- 交叉连接查询  笛卡尔积\nSELECT * FROM product;\nSELECT * FROM category;\n\n笛卡尔积 ,查出来是两张表的乘积 ,查出来的结果没有意义\nSELECT * FROM product,category;\n\n--过滤出有意义的数据\nSELECT * FROM product,category WHERE cno=cid;\n\nSELECT * FROM product AS p,category AS c WHERE p.cno=c.cid;\nSELECT * FROM product p,category c WHERE p.cno=c.cid;\n\n\n--数据准备\nINSERT INTO product VALUES(NULL,'耐克帝',10,NULL);\n\n- 内连接查询\n-- 隐式内链接\n  SELECT * FROM product p,category c WHERE p.cno=c.cid;\n-- 显示内链接\n  SELECT * FROM product p INNER JOIN category c ON p.cno=c.cid;\t\n-- 区别:\n\t隐式内链接: 在查询出结果的基础上去做的WHERE条件过滤\n\t显示内链接: 带着条件去查询结果, 执行效率要高\n\n- 左外连接\n  左外连接,会将左表中的所有数据都查询出来, 如果右表中没有对应的数据,用NULL代替\n  SELECT * FROM product p LEFT OUTER JOIN category c ON p.cno=c.cid;\n\n- 准备工作\n  INSERT INTO category VALUES(100,'电脑办公','电脑叉叉差');\n- 右外连接: 会将右表所有数据都查询出来, 如果左表没有对应数据的话, 用NULL代替\n  \n  SELECT * FROM product p RIGHT OUTER JOIN category c ON p.cno=c.cid;\n  \n  \n  \n-- 查询分类名称为手机数码的所有商品\n   1.查询分类名为手机数码的ID\n   SELECT cid FROM category WHERE cname='手机数码';\n   2.得出ID为1的结果\n   SELECT * FROM product WHERE cno = (SELECT cid FROM category WHERE cname='手机数码');\n   \n-- 查询出(商品名称,商品分类名称)信息\n   --左连接\n   SELECT p.pname,c.cname FROM product p LEFT OUTER JOIN category c ON p.cno = c.cid;\n   \n   --子查询\n   SELECT pname ,(SELECT cname FROM category c WHERE  p.cno=c.cid ) AS 商品分类名称  FROM product p;\n   \n\t\n\nCREATE TABLE emp(\n\tempno INT,\n\tename VARCHAR(50),\n\tjob VARCHAR(50),\n\tmgr\tINT,\n\thiredate DATE,\n\tsal\tDECIMAL(7,2),\n\tcomm DECIMAL(7,2),\n\tdeptno INT\n) ;\n\nINSERT INTO emp VALUES(7369,'SMITH','CLERK',7902,'1980-12-17',800,NULL,20);\nINSERT INTO emp VALUES(7499,'ALLEN','SALESMAN',7698,'1981-02-20',1600,300,30);\nINSERT INTO emp VALUES(7521,'WARD','SALESMAN',7698,'1981-02-22',1250,500,30);\nINSERT INTO emp VALUES(7566,'JONES','MANAGER',7839,'1981-04-02',2975,NULL,20);\nINSERT INTO emp VALUES(7654,'MARTIN','SALESMAN',7698,'1981-09-28',1250,1400,30);\nINSERT INTO emp VALUES(7698,'BLAKE','MANAGER',7839,'1981-05-01',2850,NULL,30);\nINSERT INTO emp VALUES(7782,'CLARK','MANAGER',7839,'1981-06-09',2450,NULL,10);\nINSERT INTO emp VALUES(7788,'SCOTT','ANALYST',7566,'1987-04-19',3000,NULL,20);\nINSERT INTO emp VALUES(7839,'KING','PRESIDENT',NULL,'1981-11-17',5000,NULL,10);\nINSERT INTO emp VALUES(7844,'TURNER','SALESMAN',7698,'1981-09-08',1500,0,30);\nINSERT INTO emp VALUES(7876,'ADAMS','CLERK',7788,'1987-05-23',1100,NULL,20);\nINSERT INTO emp VALUES(7900,'JAMES','CLERK',7698,'1981-12-03',950,NULL,30);\nINSERT INTO emp VALUES(7902,'FORD','ANALYST',7566,'1981-12-03',3000,NULL,20);\nINSERT INTO emp VALUES(7934,'MILLER','CLERK',7782,'1982-01-23',1300,NULL,10);\nINSERT INTO emp VALUES(7981,'MILLER','CLERK',7788,'1992-01-23',2600,500,20);\n\nCREATE TABLE dept(\n\tdeptno\t\tINT,\n\tdname\t\tVARCHAR(14),\n\tloc\t\tVARCHAR(13)\n);\n\nINSERT INTO dept VALUES(10, 'ACCOUNTING', 'NEW YORK');\nINSERT INTO dept VALUES(20, 'RESEARCH', 'DALLAS');\nINSERT INTO dept VALUES(30, 'SALES', 'CHICAGO');\nINSERT INTO dept VALUES(40, 'OPERATIONS', 'BOSTON');\n\n\n\n--最高工资\nSELECT MAX(sal) FROM emp;\n--最少工资\nSELECT MIN(sal) FROM emp;\n--最高工资的员工信息\nSELECT * FROM emp WHERE sal = (SELECT MAX(sal) FROM emp);\n\n--最低工资的员工信息\nSELECT * FROM emp WHERE sal = (SELECT MIN(sal) FROM emp);\n\n\n\n-- 单行子查询(> < >= <= = <>)\n\t-- 查询出高于10号部门的平均工资的员工信息\n   \t1.10号部门的平均工资\n   \tSELECT AVG(sal) FROM emp WHERE deptno = 10;\n   \t2. 高于上面结果员工信息 \n\tSELECT * FROM emp WHERE sal > (SELECT AVG(sal) FROM emp WHERE deptno = 10);\n   \t\n\t\n-- 多行子查询(in  not in any all)    >any  >all\n\t-- 查询出比10号部门任何员工薪资高的员工信息\n\t1. 查询出10号部门最高工资\n\tSELECT MAX(sal) FROM emp WHERE deptno = 10;\n\t2. 得出结果\n\tSELECT * FROM emp WHERE sal > (SELECT MAX(sal) FROM emp WHERE deptno = 10);\n\t-- 查询出比10号部门任意一个员工薪资高的所有员工信息 : 只要比其中随便一个工资都可以\n\tSELECT sal FROM emp WHERE deptno = 10;\n\t\n\tSELECT * FROM emp WHERE sal >ANY(SELECT sal FROM emp WHERE deptno = 10) AND deptno != 10;\n\t\n\t\n-- 多列子查询(实际使用较少)   in\n\t-- 和10号部门同名同工作的员工信息\n\t1. 查询出10号部门所有人 名字和工作\n\tSELECT ename,job FROM emp WHERE deptno=10;\n\t2. 得出结果\n\tSELECT * FROM emp WHERE (ename,job) IN (SELECT ename,job FROM emp WHERE deptno=10) AND deptno !=10;\n-- Select后面接子查询\n\t-- 获取员工的名字和部门的名字\n\tSELECT ename,deptno FROM emp ;\n\t\n\tSELECT ename,(SELECT dname FROM dept d WHERE d.deptno = e.deptno ) 部门名称 FROM emp e ;\n-- from后面接子查询\n\t-- 查询emp表中所有管理层的信息\n\tSELECT DISTINCT mgr FROM emp;\n\t\n\t- 得出结果\n\tSELECT * FROM emp e,(SELECT DISTINCT mgr FROM emp) mgrtable WHERE e.empno = mgrtable.mgr;\n\t\t\t\n\t\n-- where 接子查询\n\t-- 薪资高于10号部门平均工资的所有员工信息\n\t1. 10号部门平均工资\n\tSELECT AVG(sal) FROM emp WHERE deptno=10;\n\t2. 得出结果\n\tSELECT * FROM emp WHERE sal > (SELECT AVG(sal) FROM emp WHERE deptno=10);\n      \t\t\t\n\t\n-- having后面接子查询\n\t-- 有哪些部门的平均工资高于30号部门的平均工资\n\t1. 统计所有的部门的平均工资\n\tSELECT deptno, AVG(sal) FROM emp GROUP BY deptno;\n\t2. 30号部门的平均工资\n\tSELECT AVG(sal) FROM emp WHERE deptno=30;\n\t3.得出结果:\n\tSELECT deptno, AVG(sal) FROM emp GROUP BY deptno HAVING AVG(sal) > (SELECT AVG(sal) FROM emp WHERE deptno=30);\n\n\n\n-- 列出达拉斯加工作的人中,比纽约平均工资高的人\n   1. 查处达拉斯加工作的人\n      1. 查询出达拉斯的部门编号\n      SELECT deptno FROM dept WHERE loc ='DALLAS';\n      2. SELECT * FROM emp WHERE deptno = ( SELECT deptno FROM dept WHERE loc ='DALLAS');\n   \n   2. 查出纽约工作的人的平均工资\n      1. 查处纽约的部门编号\n       SELECT deptno FROM dept WHERE loc ='NEW YORK';\n      2. SELECT AVG(sal) FROM emp WHERE deptno = (SELECT deptno FROM dept WHERE loc ='NEW YORK');\n      \n   3. 得出最终结果:\n     SELECT * FROM emp WHERE deptno = ( SELECT deptno FROM dept WHERE loc ='DALLAS')\n      AND \n      sal > (SELECT AVG(sal) FROM emp WHERE deptno = (SELECT deptno FROM dept WHERE loc ='NEW YORK'));\n\t\n\n\n  \t\n\n\n\n  ```\n\n#### 条件表达式: case...when    (MySql和Oracle 通用)\n\n```sql\nselect \n\tcase ename\n\twhen 'KING' then '彤彤'\n    when 'ALLEN' then '老子'\n    else \n    \t'其他'\n    end \"中文名\"\t\nfrom emp;   \t\n```\n\n","tags":["MySql"],"categories":["开发工具"]},{"title":"IntelliJ IDEA的高效使用","url":"/2018/10/25/IEDA高效使用/","content":" **读书,健身,努力工作,关心身体,保持好心情,成为最棒的自己!**<Excerpt in index | 首页摘要>\n\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n# IEDA高效使用\n\n ## 1.无处不在的跳转\n\n* 项目之间跳转: Ctrl + Alt + [ / ]\n* 文件之间跳转: Ctrl + E (个人更喜欢: Ctrl + Tab)\n* 跳转已经打开的文件:Ctrl + Alt + 左/右\n\n## 2.高校定位代码\n\n* 新建书签 ：F11 (带有数字的书签:Ctrl + F11)\n* 添加收藏:Shift + Alt + F\n\n## 3.精准搜索\n\n* 搜索指定类:Ctrl + N\n* 搜索指定文件:Shift + Ctrl + N\n* 寻找指定函数:Shift + Ctrl + Alt +N\n* 搜索指定的字符串: Ctrl + Shift + F\n\n## 4.列操作\n\n* 选中其他一样的符号:Shift + Ctrl + Alt + J\n\n## 5.Postfix\n\n* 快速写for循环: 100.fori\n* 快速输出: .sout\n* 构造器中快速生成属性: 属性名字.field\n* 快速返回: 返回值.retu..\n* 判断值是否不等于null: 值.null.. \n\n## 6.Alt + Enter\n\n* 快速创建没有的函数\n\n* 整理代码☞最简洁状态\n\n* 快速格式化代码串\n\n  ```java\n   String x= String.format(\"name:%s,age:%d\", name, age);\n  ```\n\n* 快速实现接口\n\n* 错误单词拼写提示(错的单词下方会有浪线提示)\n\n* 导包\n\n## 7.重构\n\n* 重构变量: Shift + F6\n* 重构函数:\n  - 重构参数: Ctrl + F6\n  - 直接填加参数修改方法:Alt + Enter(优)\n\n##  8.抽取\n\n* 抽取字符串成变量: Ctrl + Alt + V(与有道词典快捷键重复,非常纠结)\n* 抽取成静态常量: Ctrl + Alt + C\n* 抽取成成员变量: Ctrl + Alt + F\n* 抽取函数: Ctrl + Alt + M\n\n## 9.git的集成\n\n* 右击这行代码前方点击第一个显示作者信息\n* 查看与版本库中修改过的部分 : Ctrl + Shift + Alt + 上/下\n* 快速撤销:Alt + Ctrl + Z (QQ 冲突)\n\n## 10 .local history\n\n* \n\n## 11.关联一切\n\n* Spring :直达使用的类\n* 关联上数据库:书写SQL提示\n\n## 12.断点调试\n\n* 添加断点:Ctrl + F8\n* 断点运行: \n* 单步运行: F8\n* 下一个断点: F9\n* 查看所有断点:Shift + Ctrl +  F8\n* 禁止所有断点:\n* 条件断点: Shift + Ctrl +  F8\n* setValue: 位置按F2\n\n## 13.其他操作\n\n* 复制文件: F5\n* 移动文件: F6\n* 复制完整文件名: Shift + Ctrl + C\n* 调出剪切板: Ctrl + Shift + V\n\n## 14 .\n\n* 查看类的大纲: Ctrl +F12\n\n* 查看继承图:Ctrl + Shift + Alt + U\n\n* 查看类的继承关系: Ctrl + H\n\n* 方法调用层次:Ctrl + Alt + H\n\n\n\n\n","tags":["java"],"categories":["开发工具"]},{"title":"Java  基础大复习","url":"/2018/10/24/Java基础大复习/","content":" **读书,健身,努力工作,关心身体,保持好心情,成为最棒的自己!**<Excerpt in index | 首页摘要>\n 复习下Java基础!\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n## 1. 内存分析\n\n> Java虚拟机的内存可以分为三个区域:栈stack,堆heap,方法区method area\n\n### 1.1.栈的特点如下:\n\n![1539781422834](/img/1539781422834.png)\n\n###  1.2.堆的特点如下:\n\n![1539781521522](/img/1539781521522.png)\n\n### 1,3.方法区特点如下:\n\n![1539781599776](/img/1539781599776.png)\n\n### 1.4.分析流程\n\n![1539782448438](/img/1539782448438.png)     \n## 2. Java垃圾回收机制(Garbage Collection)\n\n### 2.1.垃圾回收算法: \n\n> * 引用计数法\n> * 引用可达法(根搜索算法)\n\n### 2.2.分代垃圾回收机制\n\n> * 年轻代\n> * 年老代\n> * 持久代\n\n## 3.StringBuilder和StringBuffer的主要区别:StringBuffer方法用synchronized修饰\n\n## 3.关于包装类的缓存问题\n\n```java\nInteger d=1234;\nINteget d1=1234;\nSystem.out.print(d==d1);     //结果false;\nSystem.out.print(d.equals(d1));    //结果:true\n\nInteger d2=123;\nIngeger d3=123;\nSystem.out.print(d2==d3);            //结果:true;        [-128,127]之间数.仍然当基本类型来处理\nSystem.out.print(d2.equals(d3));     //结果:true\n\n```\n\n## 4.容器\n\n### 4.1 接口层次示意图\n\n![1539949593458](C:\\Users\\JIA\\AppData\\Roaming\\Typora\\typora-user-images\\1539949593458.png)\n\n> ​               Collection                                                Map\n>\n> ​                /                  \\ \t\t\t\t\t\t    |\n>\n> ​          Set                  List                                         HashMap\n>\n> ​          |                        |            \\\n>\n> ​         HashSet          ArrayList      LinkedList\n### 4.1 List接口\n\n>有序的Collection，此接口的用户可以成对列表中的每个元素的插入位置进行精确的定位，用户可\n>以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表当中的元素。\n> 与set不同，列表通常允许重复的元素，更精确的讲列表通常允许满足e1.equals(e2)条件的元素e1，e2并存，并且如果列表本身允许null元素的话，通常他们允许多个null元素。\n\n#### 4.1.1 常用的三个子类\n\n> * ArrayList  : 底层实现原理Object数组   查询快,修改,插入,删除慢\n>\n> * LinkedList :   底层实现链表      查询慢.修改,插入,删除快\n>\n> * Vector: 线程安全 ,效率低\n>\n> * ```java\n>   List list= Collections.synchronizedList(new ArrayList());// 线程安全 \n>   ```\n#### 4.1.2 自己动手模拟ArrayList\n```java\npackage collection;\n\nimport java.util.*;\n\n/**\n * 自己实现ArrayList\n */\npublic class MyArrayList {\n    private Object[] elements;\n    private int size;\n\n    public int size() {\n        return this.size;\n    }\n\n    MyArrayList() {\n        this(10);\n    }\n\n    MyArrayList(int space) {\n        elements = new Object[space];\n    }\n\n    public void add(Object obj) {\n        if (size == elements.length) {\n            Object[] newElements = new Object[2 * size + 2];\n            System.arraycopy(elements, 0, newElements, 0, elements.length);\n            elements = newElements;\n        }\n        elements[size++] = obj;\n    }\n\n    public boolean isEmpty() {\n        return size == 0;\n    }\n\n    public Object get(int index) {\n        rangeCheck(index);\n        return elements[index];\n\n    }\n\n    public void remove(int index) {\n        rangeCheck(index);\n        System.arraycopy(elements, index + 1, elements, index, elements.length - index - 1);\n        size--;\n    }\n\n    public void remove(Object obj) {\n        for (int i = 0; i < size; i++)\n            if (get(i).equals(obj))\n                remove(i);\n    }\n\n    public Object set(int index, Object obj) {\n        rangeCheck(index);\n        Object o = elements[index];\n        elements[index] = obj;\n        return o;\n    }\n\n    public void add(int index, Object obj) {\n        rangeCheck(index);\n        System.arraycopy(elements, index, elements, index + 1, elements.length - index);\n        elements[index] = obj;\n        size++;\n    }\n\n    private void rangeCheck(int index) {\n        if (index < 0 || index >= size)\n            throw new ArrayIndexOutOfBoundsException();\n    }\n\n    public static void main(String[] args) {\n        MyArrayList list = new MyArrayList();\n        list.add(\"111\");\n        list.add(\"222\");\n        list.remove(\"111\");\n        System.out.println(list.size);\n        System.out.println(list.get(0));\n        list.set(0, \"3333\");\n        System.out.println(list.get(0));\n//        System.out.println(list.get(14));\n//        System.out.println(list.size());\n    }\n}\n\n```\n\n#### 4.1.3自己动手模拟LinkedList\n\n```java\npackage collection;\n\npublic class MyLinkedList {\n    private Node first;\n    private Node last;\n    private int size;\n\n    public int size() {\n        return size;\n    }\n\n    public boolean isEmpty() {\n        return size == 0;\n    }\n\n    public void add(Object obj) {\n        Node n = new Node();\n        n.setObj(obj);\n        if (first == null) {\n            first = n;\n            last = n;\n        } else {\n            last.setNextNode(n);\n            n.setPreNode(last);\n            last = n;\n        }\n        size++;\n    }\n\n    private void rangeCheck(int index) {\n        if (index >= size || index < 0)\n            throw new ArrayIndexOutOfBoundsException();\n    }\n\n    public Object get(int index) {\n        rangeCheck(index);\n        return node(index).getObj();\n    }\n\n    public void remove(int index) {\n\n        Node n = node(index);\n        Node up = n.getPreNode();\n        Node down = n.getNextNode();\n        up.setNextNode(down);\n        down.setPreNode(up);\n//        n.getPreNode().setNextNode(n.getNextNode());\n//        n.getNextNode().setPreNode(n.getPreNode());\n        size--;\n    }\n\n    private Node node(int index) {\n        if (first != null) {\n            Node temp = first;\n            for (int i = 0; i < index; i++)\n                temp = temp.getNextNode();\n            return temp;\n        }\n        return null;\n    }\n\n    public void add(int index, Object obj) {\n        rangeCheck(index);\n        Node newNode = new Node();\n        newNode.setObj(obj);\n        Node n = node(index);\n        Node up = n.getPreNode();\n        up.setNextNode(newNode);\n        newNode.setPreNode(up);\n        newNode.setNextNode(n);\n        n.setPreNode(newNode);\n        size++;\n    }\n\n\n    public static void main(String[] args) {\n        MyLinkedList list = new MyLinkedList();\n        list.add(\"111\");\n        list.add(\"222\");\n        list.add(\"333\");\n        list.add(1, \"AAA\");\n        System.out.println(list.size());\n        System.out.println(list.get(1));\n    }\n}\n\nclass Node {\n    private Node preNode;\n    private Object obj;\n    private Node nextNode;\n\n    public Node(Node preNode, Object obj, Node nextNode) {\n        this.preNode = preNode;\n        this.obj = obj;\n        this.nextNode = nextNode;\n    }\n\n    public Node() {\n    }\n\n    ;\n\n    public Node getPreNode() {\n        return preNode;\n    }\n\n    public void setPreNode(Node preNode) {\n        this.preNode = preNode;\n    }\n\n    public Object getObj() {\n        return obj;\n    }\n\n    public void setObj(Object obj) {\n        this.obj = obj;\n    }\n\n    public Node getNextNode() {\n        return nextNode;\n    }\n\n    public void setNextNode(Node nextNode) {\n        this.nextNode = nextNode;\n    }\n}\n\n```\n\n### 4.2Map \n\n> 实现原理:数组+链表\n\n#### 4.2.1常用实现类:\n\n> * HashMap       快,不安全\n> * HashTable      慢,安全\n\n#### 4.2.2 HashMap 的简单模拟\n\n```java\npackage collection;\n\nimport java.util.LinkedList;\n\n\npublic class MyMap {\n\n    private LinkedList[] arr = new LinkedList[999];\n    private int size;\n\n    public int size() {\n        return size;\n    }\n\n    public boolean isEmpty() {\n        return size == 0;\n    }\n\n    public void put(Object key, Object value) {\n        MyEntry entry = new MyEntry();\n        entry.value = value;\n        entry.key = key;\n        int hashKey = key.hashCode() % arr.length;\n        if (arr[hashKey] == null) {\n            arr[hashKey] = new LinkedList();\n            arr[hashKey].add(entry);\n            size++;\n        } else {\n            for (int i = 0; i < arr[hashKey].size(); i++) {\n                MyEntry e = ((MyEntry) arr[hashKey].get(i));\n                if (e.value.equals(value)) {\n                    e.value = value;\n                    return;\n                }\n                arr[hashKey].add(entry);\n                size++;\n            }\n        }\n    }\n\n    public Object get(Object key) {\n        int hashKey = key.hashCode() % arr.length;\n        for (int i = 0; i < arr[hashKey].size(); i++) {\n            MyEntry e = ((MyEntry) arr[hashKey].get(i));\n            if (e.key.equals(key))\n                return e.value;\n        }\n        return null;\n    }\n\n\n    public static void main(String[] args) {\n        MyMap map = new MyMap();\n        map.put(\"111\", \"wewe\");\n        map.put(\"222\", \"wewe1\");\n        map.put(\"333\", \"wewe2\");\n        map.put(\"444\", \"wewe2\");\n        map.put(\"555\", \"wewe2\");\n        System.out.println(map.size());\n        System.out.println(map.get(\"111\"));\n    }\n\n}\nclass MyEntry {\n    Object key;\n    Object value;\n}\n```\n\n#### 4.2.3 如果两个对象内容相同(equals为true),那么他们的hash一定相同\n\n### 4.3 Set \n\n> HashSet :底层用HashMap实现 \n\n### 5.线程\n\n#### 5.1多线程(多线程并行和并发的区别)(了解)\n\n* 并行就是两个任务同时运行，就是甲任务进行的同时，乙任务也在进行。(需要多核CPU)\n* 并发是指两个任务都请求运行，而处理器只能按受一个任务，就把这两个任务安排轮流进行，由于时间间隔较短，使人感觉两个任务都在运行。\n* 比如我跟两个网友聊天，左手操作一个电脑跟甲聊，同时右手用另一台电脑跟乙聊天，这就叫并行。\n* 如果用一台电脑我先给甲发个消息，然后立刻再给乙发消息，然后再跟甲聊，再跟乙聊。这就叫并发。\n\n#### 5.2JVM启动是多线程的(至少启动一个主线程和垃圾管理线程)\n\n#### 5.3多线程(Java程序运行原理和JVM的启动是多线程的吗)(了解)\n* A:Java程序运行原理\n  * Java命令会启动java虚拟机，启动JVM，等于启动了一个应用程序，也就是启动了一个进程。该进程会自动启动一个 “主线程” ，然后主线程去调用某个类的 main 方法。\n\n* B:JVM的启动是多线程的吗\n  * JVM启动至少启动了垃圾回收线程和主线程，所以是多线程的。\n\n* 继承Thread\n  * 好处是:可以直接使用Thread类中的方法,代码简单\n  * 弊端是:如果已经有了父类,就不能用这种方法\n* 实现Runnable接口\n  * 好处是:即使自己定义的线程类有了父类也没关系,因为有了父类也可以实现接口,而且接口是可以多实现的\n  * 弊端是:不能直接使用Thread中的方法需要先获取到线程对象后,才能得到Thread的方法,代码复杂\n\n#### 5,4线程匿名内部类的实现\n\n```java\npackage thread;\n\npublic class Demo03 {\n    public static void main(String[] args) {\n        new Thread(){\n            @Override\n            public void run() {\n                for(int i=0;i<1111;i++)\n                    System.out.println(\"aaaa\");\n            }\n        }.start();\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                for (int i = 0; i < 11111; i++) {\n                    System.out.println(\"b\");\n                }            }\n        }).start();\n    }\n}\n```\n\n#### 5.4 Sleep (不解释)\n\n#### 5.5 守护线程(被人挂掉自己也挂掉)\n\n> 比如: QQ正在传输文件(守护线程),关闭QQ程序文件传输马上停止.\n\n```java\npackage thread;\n\npublic class Demo05 {\n    public static void main(String[] args) {\n        Thread t1 = new Thread() {\n            @Override\n            public void run() {\n                for (int i = 0; i < 20; i++)\n                    System.out.println(\"aaaaa\");\n            }\n        };\n        Thread t2 = new Thread() {\n            @Override\n            public void run() {\n                for (int i = 0; i < 50; i++) {\n                    System.out.println(i + \" bb\");\n                }\n            }\n        };\n        t2.setDaemon(true);\n        t1.start();\n        t2.start();\n    }\n}\n\n```\n\n#### 5.6 join(插队)(join执行完其他线程再执行)\n\n* join(), 当前线程暂停, 等待指定的线程执行结束后, 当前线程再继续\n* join(int), 可以等待指定的毫秒之后继续(插队int毫秒)\n\n```java\npackage thread;\n\npublic class Demo06 {\n    public static void main(String[] args) {\n        final  Thread t1=new Thread(){\n            @Override\n            public void run() {\n                for (int i = 0; i <30 ; i++) {\n                    System.out.println(\"线程111\");\n                }\n            }\n        };\n        Thread t2=new Thread(){\n            @Override\n            public void run() {             \n                for (int i = 0; i <30 ; i++) {\n                    if(i>10) {\n                        try {\n                            t1.join();\n                        } catch (InterruptedException e) {\n                            e.printStackTrace();\n                        }\n                    }\n                    System.out.println(\"线程222\");\n                }\n            }\n        };\n         t1.start();\n         t2.start();\n    }\n}\n\n```\n\n#### 5.7 yield(礼让线程)\n\n> 让其他线程先执行\n\n####  5.8优先级(任然交替执行线程,但是优先级高的线程执行次数更多)\n\n> setPriority(1~10);\n\n#### 5.9Synchronized\n\n> * ``` Synchronized(对象){ }  ```      :同步代码块,可以传任意对象,但是必须是同一个对象\n> * ``` public Synchronized void method()  ```     :非静态的同步所对象是this\n> * ``` public static Synchronized void method()``` : 静态的同步方法使用的所对象是字节码对象(类名.class)\n\n#### 5.10死锁(哲学家进餐问题)\n\n> 为了避免死锁:尽量Synchronized 嵌套\n\n```java\npackage thread;\n\npublic class Demo07 {\n    private static Object s2 = \"筷子2\";\n    private static Object s1 = \"筷子1\";\n\n    public static void main(String[] args) {\n\n        new Thread() {\n            @Override\n            public void run() {\n                while (true) {\n                    synchronized (s1) {\n                        System.out.println(getName() + \":拿到s1\");\n                        synchronized (s2) {\n                            System.out.println(getName() + \":拿到s2   哲学家开始吃饭\");\n                        }\n                    }\n                }\n            }\n        }.start();\n        new Thread() {\n            @Override\n            public void run() {\n                while (true) {\n                    synchronized (s2) {\n                        System.out.println(getName() + \":拿到s2\");\n                        synchronized (s1) {\n                            System.out.println(getName() + \":拿到s1   哲学家开始吃饭\");\n                        }\n                    }\n                }\n            }\n        }.start();\n    }\n}\n```\n\n#### 5.11 三种单例设计模式\n\n> jdk中单例模式的类:Runtime,Timer\n\n#### 5.12线程之间的通讯\n\n> * wait() 当前线程等待\n> * notify() 随机唤醒一个等待的线程\n> * notifyAll()   唤醒所有等待线程\n\n```java\npackage thread;\n\npublic class Demo09 {\n    public static void main(String[] args) {\n        test t = new test();\n        new Thread() {\n            @Override\n            public void run() {\n                while (true)\n                    t.method();\n            }\n        }.start();\n        new Thread() {\n            @Override\n            public void run() {\n                while (true)\n\n                    t.method2();\n            }\n        }.start();\n    }\n}\n\nclass test {\n    private boolean flag;\n\n    public synchronized void method() {\n        if (flag != true) {\n            try {\n                this.wait();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        System.out.println(\"111111\");\n        flag = false;\n        this.notify();\n    }\n\n    public synchronized void method2() {\n        if (flag != false) {\n            try {\n                this.wait();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        System.out.println(\"222222\");\n        flag = true;\n        this.notify();\n    }\n}\n```\n\n#### 5.12ReentrantLock\n\n#### 5.13 线程组\n\n#### 5.14线程的五种状态\n\n![1540126331767](C:\\Users\\JIA\\AppData\\Roaming\\Typora\\typora-user-images\\1540126331767.png)\n\n#### 5.15线程池\n\n> 创建线程时需要耗费许多资源,线程池可以先创建几个线程,其他线程需要就过来用\n>\n>  **ExecutorService pool = Executors.newFixedThreadPool(2);**\n\n```java\npackage thread;\n\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class Demo10 {\n    public static void main(String[] args) {\n        ExecutorService pool = Executors.newFixedThreadPool(2);\n        pool.submit(new Runnable() {\n            @Override\n            public void run() {\n                for (int i = 0; i < 10; i++)\n                    System.out.println(Thread.currentThread().getName() + \"   \" + i);\n            }\n        });\n        pool.submit(new Runnable() {\n            @Override\n            public void run() {\n                for (int i = 0; i < 10; i++)\n                    System.out.println(Thread.currentThread().getName() + \"   \" + i);\n            }\n        });\n        pool.submit(new Runnable() {\n            @Override\n            public void run() {\n                for (int i = 0; i < 10; i++)\n                    System.out.println(Thread.currentThread().getName() + \"   \" + i);\n            }\n        });\n        pool.submit(new Runnable() {\n            @Override\n            public void run() {\n                for (int i = 0; i < 10; i++)\n                    System.out.println(Thread.currentThread().getName() + \"   \" + i);\n            }\n        });\n        pool.shutdownNow();\n    }\n}\n\n```\n\n#### 5.15 Callable\n\n> 线程的第三种实现方法\n\n```java\n// 创建线程池对象\n\t\tExecutorService pool = Executors.newFixedThreadPool(2);\n\n\t\t// 可以执行Runnable对象或者Callable对象代表的线程\n\t\tFuture<Integer> f1 = pool.submit(new MyCallable(100));\n\t\tFuture<Integer> f2 = pool.submit(new MyCallable(200));\n\t\n\t\t// V get()\n\t\tInteger i1 = f1.get();\n\t\tInteger i2 = f2.get();\n\t\n\t\tSystem.out.println(i1);\n\t\tSystem.out.println(i2);\n\t\n\t\t// 结束\n\t\tpool.shutdown();\n\t\n\t\tpublic class MyCallable implements Callable<Integer> {\n\t\n\t\t\tprivate int number;\n\t\t\n\t\t\tpublic MyCallable(int number) {\n\t\t\t\tthis.number = number;\n\t\t\t}\n\t\t\n\t\t\t@Override\n\t\t\tpublic Integer call() throws Exception {\n\t\t\t\tint sum = 0;\n\t\t\t\tfor (int x = 1; x <= number; x++) {\n\t\t\t\t\tsum += x;\n\t\t\t\t}\n\t\t\t\treturn sum;\n\t\t\t}\n\t\t\n\t\t}\n```\n\n### 6.反射\n\n#### 6.1 获取Class的三种方式\n\n> * 根据类名\n> * 根据class\n> * 根据对象的实例\n\n![154018482338](C:\\Users\\JIA\\AppData\\Roaming\\Typora\\typora-user-images\\154018482338.png)\n\n```java\npackage reflect;\n\npublic class Demo01 {\n    public static void main(String[] args) throws ClassNotFoundException {\n        Class clazz1 = Class.forName(\"reflect.Student\");\n        Class clazz2 = Student.class;\n        Student s = new Student();\n        Class clazz3 = s.getClass();\n        System.out.println(clazz1 == clazz2);\n        System.out.println(clazz1 == clazz3);\n    }\n}\n\nclass Student {\n}\n```\n\n#### 6.2 反射+配置 实现动态调用\n\n```properties\nreflect.Orange\n```\n\n```java\npackage reflect;\n\nimport java.io.BufferedReader;\nimport java.io.FileReader;\n\npublic class Demo02 {\n    public static void main(String[] args) throws Exception {\n        BufferedReader br = new BufferedReader(new FileReader(\"E:\\\\idea_workSpace\\\\java_review\\\\src\\\\fruit.properties\"));\n        Class clazz = Class.forName(br.readLine());\n\n        zzj z = new zzj();\n        z.run((Fruit) clazz.newInstance());\n    }\n}\n\nclass zzj {\n    public void run(Fruit r) {\n        r.juice();\n    }\n}\n\nclass Apple extends Fruit {\n    public void juice() {\n        System.out.println(\"苹果汁...\");\n    }\n}\n\nclass Orange extends Fruit {\n    public void juice() {\n        System.out.println(\"橘子汁...\");\n    }\n}\n\nclass Banana extends Fruit {\n    public void juice() {\n        System.out.println(\"香蕉汁...\");\n    }\n}\n\nclass Fruit {\n    public void juice() {\n    }\n}\n\n```\n\n#### 6.3 反射可以拿到私有的属性,方法\n\n#### 6.4 使用反射对泛型进行擦除\n\n````java\npackage reflect;\n\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Demo04 {\n    public static void main(String[] args) throws Exception {\n        List<Integer> list = new ArrayList();\n        list.add(111);\n        list.add(222);\n        System.out.println(list);\n        Class clazz = Class.forName(\"java.util.ArrayList\");\n        Method method = clazz.getMethod(\"add\", Object.class);\n        method.invoke(list, \"aaaa \");\n        System.out.println(list);\n    }\n}\n\n````\n\n#### 6.4 jdk 1,8后接口可以创建普通可执行方法,也可以创建静态方法\n\n```java\npackage reflect;\n\npublic class Demo05 {\n    public static void main(String[] args) {\n\n        new Inter() {\n\n        }.print();\n        Inter.print2();\n    }\n}\n\ninterface Inter {\n    default void print() {\n        System.out.println(\"jdk1.8 新特性\");\n\n    }\n\n    static void print2() {\n        System.out.println(\"jdk1.8 lllllllllllllll\");\n    }\n}\n\n```\n\n### 7.Socket(码头)\n\n#### 7.1 Socket进行消息通信\n\n>\n>1.发送Send\n>\n>- 创建DatagramSocket, 随机端口号\n>- 创建DatagramPacket, 指定数据, 长度, 地址, 端口\n>- 使用DatagramSocket发送DatagramPacket\n>- 关闭DatagramSocket\n>\n>\n>2.接收Receive\n>\n>- 创建DatagramSocket, 指定端口号\n>- 创建DatagramPacket, 指定数组, 长度\n>- 使用DatagramSocket接收DatagramPacket\n>- 关闭DatagramSocket\n>- 从DatagramPacket中获取数据\n>\n\n```java\npackage socket;\n\nimport javax.xml.crypto.Data;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\n/**\n * 1.发送Send\n\n - 创建DatagramSocket, 随机端口号\n - 创建DatagramPacket, 指定数据, 长度, 地址, 端口\n - 使用DatagramSocket发送DatagramPacket\n - 关闭DatagramSocket\n */\npublic class Send {\n    public static void main(String[] args) throws  Exception{\n        String msg=\"正在学习socket编程\";\n        DatagramSocket socket =new DatagramSocket();\n        DatagramPacket  packet=new\n                DatagramPacket(msg.getBytes(),msg.getBytes().length,\n                InetAddress.getLocalHost(),8888);\n        socket.send(packet);\n        socket.close();\n    }\n\n}\n\n```\n\n```java\npackage socket;\n\n\n\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\n/**\n * 2.接收Receive\n\n - 创建DatagramSocket, 指定端口号\n - 创建DatagramPacket, 指定数组, 长度\n - 使用DatagramSocket接收DatagramPacket\n - 关闭DatagramSocket\n - 从DatagramPacket中获取数据\n */\npublic class Receive {\n\n    public static void main(java.lang.String[] args) throws  Exception{\n        byte [] arr=new byte[1024];\n        DatagramSocket socket=new DatagramSocket(8888);\n        DatagramPacket packet=new DatagramPacket(arr,arr.length);\n        socket.receive(packet);\n        byte [] arr2=packet.getData();\n        int len=packet.getLength();\n        System.out.println(new java.lang.String(arr2,0,len));\n        socket.close();\n    }\n}\n\n```\n\n\n\n\n\n\n\n\n\n### 8.异常(Exception)\n\n﻿#### 8.01_异常(异常的概述和分类)\n* A:异常的概述\n  * 异常就是Java程序在运行过程中出现的错误。\n* B:异常的分类\n  * 通过API查看Throwable\n  * Error\n    * 服务器宕机,数据库崩溃等\n  * Exception\n    C:异常的继承体系\n  * Throwable\n    * Error\t\n    * Exception\n      * RuntimeException\n\n#### 8.02_异常(JVM默认是如何处理异常的)\n* A:JVM默认是如何处理异常的\n  * main函数收到这个问题时,有两种处理方式:\n  * a:自己将该问题处理,然后继续运行\n  * b:自己没有针对的处理方式,只有交给调用main的jvm来处理\n  * jvm有一个默认的异常处理机制,就将该异常进行处理.\n  * 并将该异常的名称,异常的信息.异常出现的位置打印在了控制台上,同时将程序停止运行\n* B:案例演示\n  * JVM默认如何处理异常\n\n#### 8.03_异常(try...catch的方式处理异常1)\n* A:异常处理的两种方式\n  * a:try…catch…finally\n    * try catch\n    * try catch finally\n    * try finally \n  * b:throws\n* B:try...catch处理异常的基本格式\n  * try…catch…finally\n* C:案例演示\n  * try...catch的方式处理1个异常\n\n#### 8.04_异常(try...catch的方式处理异常2)\n* A:案例演示\n  * try...catch的方式处理多个异常\n  * JDK7以后处理多个异常的方式及注意事项\n\n#### 8.05_异常(编译期异常和运行期异常的区别)\n* A:编译期异常和运行期异常的区别\n  * Java中的异常被分为两大类：编译时异常和运行时异常。\n  * 所有的RuntimeException类及其子类的实例被称为运行时异常，其他的异常就是编译时异常\n\n  * 编译时异常\n    * Java程序必须显示处理，否则程序就会发生错误，无法通过编译\n  * 运行时异常\n    * 无需显示处理，也可以和编译时异常一样处理\n* B:案例演示\n  * 编译期异常和运行期异常的区别\n\n#### 8.06_异常(Throwable的几个常见方法)\n* A:Throwable的几个常见方法\n  * a:getMessage()\n    * 获取异常信息，返回字符串。\n  * b:toString()\n    * 获取异常类名和异常信息，返回字符串。\n  * c:printStackTrace()\n    * 获取异常类名和异常信息，以及异常出现在程序中的位置。返回值void。\n* B:案例演示\n  * Throwable的几个常见方法的基本使用\n\n#### 8.07_异常(throws的方式处理异常)\n* A:throws的方式处理异常\n  * 定义功能方法时，需要把出现的问题暴露出来让调用者去处理。\n  * 那么就通过throws在方法上标识。\n* B:案例演示\n  * 举例分别演示编译时异常和运行时异常的抛出\n\n#### 8.08_异常(throw的概述以及和throws的区别)\n* A:throw的概述\n  * 在功能方法内部出现某种情况，程序不能继续运行，需要进行跳转时，就用throw把异常对象抛出。\n* B:案例演示\t\n  * 分别演示编译时异常对象和运行时异常对象的抛出\n* C:throws和throw的区别\n  * a:throws\n    * 用在方法声明后面，跟的是异常类名\n    * 可以跟多个异常类名，用逗号隔开\n    * 表示抛出异常，由该方法的调用者来处理\n  * b:throw\n    * 用在方法体内，跟的是异常对象名\n    * 只能抛出一个异常对象名\n    * 表示抛出异常，由方法体内的语句处理\n\n#### 8.09_异常(finally关键字的特点及作用)\n* A:finally的特点\n  * 被finally控制的语句体一定会执行\n  * 特殊情况：在执行到finally之前jvm退出了(比如System.exit(0))\n* B:finally的作用\n  * 用于释放资源，在IO流操作和数据库操作中会见到\n* C:案例演示\n  * finally关键字的特点及作用\n\n#### 8.10_异常(finally关键字的面试题)\n* A:面试题1\n  * final,finally和finalize的区别\n* B:面试题2\n  * 如果catch里面有return语句，请问finally的代码还会执行吗?如果会，请问是在return前还是return后。\n\n#### 8.11_异常(自定义异常概述和基本使用)\n* A:为什么需要自定义异常\n  * 举例：人的年龄\n* B:自定义异常概述\n  * 继承自Exception\n  * 继承自RuntimeException\n* C:案例演示\n  * 自定义异常的基本使用\n\n#### 8.12_异常(异常的注意事项及如何使用异常处理)\n* A:异常注意事项\n  * a:子类重写父类方法时，子类的方法必须抛出相同的异常或父类异常的子类。(父亲坏了,儿子不能比父亲更坏)\n  * b:如果父类抛出了多个异常,子类重写父类时,只能抛出相同的异常或者是他的子集,子类不能抛出父类没有的异常\n  * c:如果被重写的方法没有异常抛出,那么子类的方法绝对不可以抛出异常,如果子类方法内有异常发生,那么子类只能try,不能throws\n* B:如何使用异常处理\n  * 原则:如果该功能内部可以将问题处理,用try,如果处理不了,交由调用者处理,这是用throws\n  * 区别:\n    * 后续程序需要继续运行就try\n    * 后续程序不需要继续运行就throws\n\n  * 如果JDK没有提供对应的异常，需要自定义异常。\n\n#### 8.13_异常(练习)\n* 键盘录入一个int类型的整数,对其求二进制表现形式\n   * 如果录入的整数过大,给予提示,录入的整数过大请重新录入一个整数BigInteger\n    * 如果录入的是小数,给予提示,录入的是小数,请重新录入一个整数\n    * 如果录入的是其他字符,给予提示,录入的是非法字符,请重新录入一个整数\n\n### 9.File\n#### 9.1_File类(File类的概述和构造方法)\n* A:File类的概述\n  * File更应该叫做一个路径\n    * 文件路径或者文件夹路径  \n    * 路径分为绝对路径和相对路径\n    * 绝对路径是一个固定的路径,从盘符开始\n    * 相对路径相对于某个位置,在eclipse下是指当前项目下,在dos下\n  * 查看API指的是当前路径\n  * 文件和目录路径名的抽象表示形式\n* B:构造方法\n  * File(String pathname)：根据一个路径得到File对象\n  * File(String parent, String child):根据一个目录和一个子文件/目录得到File对象\n  * File(File parent, String child):根据一个父File对象和一个子文件/目录得到File对象\n* C:案例演示\n  * File类的构造方法\n\n#### 9.2_File类(File类的创建功能)\n* A:创建功能\n  * public boolean createNewFile():创建文件 如果存在这样的文件，就不创建了\n  * public boolean mkdir():创建文件夹 如果存在这样的文件夹，就不创建了\n  * public boolean mkdirs():创建文件夹,如果父文件夹不存在，会帮你创建出来\n* B:案例演示\n  * File类的创建功能\n\n  * 注意事项：\n    * 如果你创建文件或者文件夹忘了写盘符路径，那么，默认在项目路径下。\n\n#### 9.3_File类(File类的重命名和删除功能)\n* A:重命名和删除功能\n  * public boolean renameTo(File dest):把文件重命名为指定的文件路径\n  * public boolean delete():删除文件或者文件夹\n* B:重命名注意事项\n  * 如果路径名相同，就是改名。\n  * 如果路径名不同，就是改名并剪切。\n* C:删除注意事项：\n  * Java中的删除不走回收站。\n  * 要删除一个文件夹，请注意该文件夹内不能包含文件或者文件夹\n\n\n#### 9.4_File类(File类的判断功能)\n* A:判断功能\n  * public boolean isDirectory():判断是否是目录\n  * public boolean isFile():判断是否是文件\n  * public boolean exists():判断是否存在\n  * public boolean canRead():判断是否可读\n  * public boolean canWrite():判断是否可写\n  * public boolean isHidden():判断是否隐藏\n* B:案例演示\n  * File类的判断功能\n\n#### 9.5_File类(File类的获取功能)\n* A:获取功能\n  * public String getAbsolutePath()：获取绝对路径\n  * public String getPath():获取路径\n  * public String getName():获取名称\n  * public long length():获取长度。字节数\n  * public long lastModified():获取最后一次的修改时间，毫秒值\n  * public String[] list():获取指定目录下的所有文件或者文件夹的名称数组\n  * public File[] listFiles():获取指定目录下的所有文件或者文件夹的File数组 \n* B:案例演示\n  * File类的获取功能\n\n#### 9.6_File类(输出指定目录下指定后缀的文件名)\n* A:案例演示\n  * 需求：判断E盘目录下是否有后缀名为.jpg的文件，如果有，就输出该文件名称\n\n#### 9.7_File类(文件名称过滤器的概述及使用)\n* A:文件名称过滤器的概述\n  * public String[] list(FilenameFilter filter)\n  * public File[] listFiles(FileFilter filter)\n* B:文件名称过滤器的使用\n  * 需求：判断E盘目录下是否有后缀名为.jpg的文件，如果有，就输出该文件名称\n* C:源码分析\n  * 带文件名称过滤器的list()方法的源码\n\n### 10.IO\n\n####   10.01_IO流(IO流概述及其分类)\n\n* 1.概念\n  * IO流用来处理设备之间的数据传输\n  * Java对数据的操作是通过流的方式\n  * Java用于操作流的类都在IO包中\n  * 流按流向分为两种：输入流，输出流。\n  * 流按操作类型分为两种：\n    * 字节流 : 字节流可以操作任何数据,因为在计算机中任何数据都是以字节的形式存储的\n    * 字符流 : 字符流只能操作纯字符数据，比较方便。\n* 2.IO流常用父类\n  * 字节流的抽象父类：\n    * InputStream \n    * OutputStream\n  * 字符流的抽象父类：\n    * Reader \n    * Writer\t\t\n* 3.IO程序书写\n  * 使用前，导入IO包中的类\n  * 使用时，进行IO异常处理\n  * 使用后，释放资源\n\n####   10.02_IO流(FileInputStream)\n\n* read()一次读取一个字节\n* \n   FileInputStream fis = new FileInputStream(\"aaa.txt\");\t//创建一个文件输入流对象,并关联aaa.txt\n   ​\tint b;\t\t\t\t\t\t\t\t\t\t\t\t\t//定义变量,记录每次读到的字节\n   ​\twhile((b = fis.read()) != -1) {\t\t\t\t\t\t\t//将每次读到的字节赋值给b并判断是否是-1\n   ​\t\tSystem.out.println(b);\t\t\t\t\t\t\t\t//打印每一个字节\n   ​\t}\n   ​\t\n   ​\tfis.close();\t\t\t\t\t\t\t\t\t\t\t//关闭流释放资源\n\n####   10.03_IO流(read()方法返回值为什么是int)\n* read()方法读取的是一个字节,为什么返回是int,而不是byte\n* 因为字节输入流可以操作任意类型的文件,比如图片音频等,这些文件底层都是以二进制形式的存储的,如果每次读取都返回byte,有可能在读到中间的时候遇到111111111\n   ​\t那么这11111111是byte类型的-1,我们的程序是遇到-1就会停止不读了,后面的数据就读不到了,所以在读取的时候用int类型接收,如果11111111会在其前面补上\n   ​\t24个0凑足4个字节,那么byte类型的-1就变成int类型的255了这样可以保证整个数据读完,而结束标记的-1就是int类型\n####  10.04_IO流(FileOutputStream)\n* write()一次写出一个字节\n* FileOutputStream fos = new FileOutputStream(\"bbb.txt\");\t//如果没有bbb.txt,会创建出一个\n   ​\t//fos.write(97);\t\t\t\t\t\t//虽然写出的是一个int数,但是在写出的时候会将前面的24个0去掉,所以写出的是一个byte\n   ​\tfos.write(98);\n   ​\tfos.write(99);\n   ​\tfos.close();\n\n####   10.05_IO流(FileOutputStream追加)\n* A:案例演示\n\n  * FileOutputStream的构造方法写出数据如何实现数据的追加写入\n* \n   FileOutputStream fos = new FileOutputStream(\"bbb.txt\",true);\t//如果没有bbb.txt,会创建出一个\n   ​\t//fos.write(97);\t\t\t\t\t\t//虽然写出的是一个int数,但是在写出的时候会将前面的24个0去掉,所以写出的一个byte\n   ​\tfos.write(98);\n   ​\tfos.write(99);\n   ​\tfos.close();\n\n####   10.06_IO流(拷贝图片)\n* FileInputStream读取\n* FileOutputStream写出\n\n   FileInputStream fis = new FileInputStream(\"致青春.mp3\");\t//创建输入流对象,关联致青春.mp3\n   ​\tFileOutputStream fos = new FileOutputStream(\"copy.mp3\");//创建输出流对象,关联copy.mp3\n   ​\t\n   ​\tint b;\n   ​\twhile((b = fis.read()) != -1) {\n   ​\t\tfos.write(b);\n   ​\t}\n   ​\t\n   ```java\n   fis.close();\n   fos.close();\n   ```\n\n\n####  10.07_IO流(拷贝音频文件画原理图)\n* A:案例演示\n  * 字节流一次读写一个字节复制音频\n* 弊端:效率太低\n\n####  10.08_IO流(字节数组拷贝之available()方法)\n* A:案例演示\n  * int read(byte[] b):一次读取一个字节数组\n  * write(byte[] b):一次写出一个字节数组\n  * available()获取读的文件所有的字节个数\n* 弊端:有可能会内存溢出 \n\n   FileInputStream fis = new FileInputStream(\"致青春.mp3\");\n   ​\tFileOutputStream fos = new FileOutputStream(\"copy.mp3\");\n   ​\tbyte[] arr = new byte[fis.available()];\t\t\t\t\t//根据文件大小做一个字节数组\n   ​\tfis.read(arr);\t\t\t\t\t\t\t\t\t\t\t//将文件上的所有字节读取到数组中\n   ​\tfos.write(arr);\t\t\t\t\t\t\t\t\t\t\t//将数组中的所有字节一次写到了文件上\n   ​\tfis.close();\n   ​\tfos.close();\n   ​\t\n####  10.09_IO流(定义小数组)\n* write(byte[] b)\n* write(byte[] b, int off, int len)写出有效的字节个数\n\n  ​\t\n####  10.10_IO流(定义小数组的标准格式)\n* A:案例演示\n  * 字节流一次读写一个字节数组复制图片和视频\n    FileInputStream fis = new FileInputStream(\"致青春.mp3\");\n    FileOutputStream fos = new FileOutputStream(\"copy.mp3\");\n    int len;\n    byte[] arr = new byte[1024 * 8];\t\t\t\t\t//自定义字节数组\n\n    while((len = fis.read(arr)) != -1) {\n    ​\t//fos.write(arr);\n    ​\tfos.write(arr, 0, len);\t\t\t\t\t\t\t//写出字节数组写出有效个字节个数\n    }\n```java\n    fis.close();\n    fos.close();\n```\n\n    ####  10.11_IO流(BufferedInputStream和BufferOutputStream拷贝)\n* A:缓冲思想\n  * 字节流一次读写一个数组的速度明显比一次读写一个字节的速度快很多，\n  * 这是加入了数组这样的缓冲区效果，java本身在设计的时候，\n  * 也考虑到了这样的设计思想(装饰设计模式后面讲解)，所以提供了字节缓冲区流\n* B.BufferedInputStream\n  * BufferedInputStream内置了一个缓冲区(数组)\n  * 从BufferedInputStream中读取一个字节时\n  * BufferedInputStream会一次性从文件中读取8192个, 存在缓冲区中, 返回给程序一个\n  * 程序再次读取时, 就不用找文件了, 直接从缓冲区中获取\n  * 直到缓冲区中所有的都被使用过, 才重新从文件中读取8192个\n* C.BufferedOutputStream\n  * BufferedOutputStream也内置了一个缓冲区(数组)\n  * 程序向流中写出字节时, 不会直接写到文件, 先写到缓冲区中\n  * 直到缓冲区写满, BufferedOutputStream才会把缓冲区中的数据一次性写到文件里\n* D.拷贝的代码 \n\n   FileInputStream fis = new FileInputStream(\"致青春.mp3\");\t\t\t//创建文件输入流对象,关联致青春.mp3\n   ​\tBufferedInputStream bis = new BufferedInputStream(fis);\t\t\t//创建缓冲区对fis装饰\n   ​\tFileOutputStream fos = new FileOutputStream(\"copy.mp3\");\t\t//创建输出流对象,关联copy.mp3\n   ​\tBufferedOutputStream bos = new BufferedOutputStream(fos);\t\t//创建缓冲区对fos装饰\n   ​\t\n   ​\tint b;\n   ​\twhile((b = bis.read()) != -1) {\t\t\n   ​\t\tbos.write(b);\n   ​\t}\n   ​\t\n   ​\tbis.close();\t\t\t\t\t\t//只关装饰后的对象即可\n   ​\tbos.close();\n\n* E.小数组的读写和带Buffered的读取哪个更快?\n  * 定义小数组如果是8192个字节大小和Buffered比较的话\n  * 定义小数组会略胜一筹,因为读和写操作的是同一个数组\n  * 而Buffered操作的是两个数组\n\n####  10.12_IO流(flush和close方法的区别)\n* flush()方法\n\n  * 用来刷新缓冲区的,刷新后可以再次写出 \n* close()方法\n  * 用来关闭流释放资源的的,如果是带缓冲区的流对象的close()方法,不但会关闭流,还会再关闭流之前刷新缓冲区,关闭后不能再写出 \n\n    ####  10.13_IO流(字节流读写中文) \n* 字节流读取中文的问题\n\n  * 字节流在读中文的时候有可能会读到半个中文,造成乱码 \n* 字节流写出中文的问题\n  * 字节流直接操作的字节,所以写出中文必须将字符串转换成字节数组 \n  * 写出回车换行 write(\"\\r\\n\".getBytes());\n\n####  10.14_IO流(流的标准处理异常代码1.6版本及其以前)\n* try finally嵌套\n\n```java\n   FileInputStream fis = null;\n   \tFileOutputStream fos = null;\n   \ttry {\n   \t\tfis = new FileInputStream(\"aaa.txt\");\n   \t\tfos = new FileOutputStream(\"bbb.txt\");\n   \t\tint b;\n   \t\twhile((b = fis.read()) != -1) {\n   \t\t\tfos.write(b);\n   \t\t}\n   \t} finally {\n   \t\ttry {\n   \t\t\tif(fis != null)\n   \t\t\t\tfis.close();\n   \t\t}finally {\n   \t\t\tif(fos != null)\n   \t\t\t\tfos.close();\n   \t\t}\n   \t}\n  ```\n\n\n####  10.15_IO流(流的标准处理异常代码1.7版本)\n* try close\n\n   try(\n   ​\t\tFileInputStream fis = new FileInputStream(\"aaa.txt\");\n   ​\t\tFileOutputStream fos = new FileOutputStream(\"bbb.txt\");\n   ​\t\tMyClose mc = new MyClose();\n   ​\t){\n   ​\t\tint b;\n   ​\t\twhile((b = fis.read()) != -1) {\n   ​\t\t\tfos.write(b);\n   ​\t\t}\n   ​\t}\n* 原理\n\n  * 在try()中创建的流对象必须实现了AutoCloseable这个接口,如果实现了,在try后面的{}(读写代码)执行后就会自动调用,流对象的close方法将流关掉 \n\n####  10.16_IO流(图片加密)\n* 给图片加密\n\n   BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"a.jpg\"));\n   ​\tBufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"b.jpg\"));\n   ​\t\n   ​\tint b;\n   ​\twhile((b = bis.read()) != -1) {\n   ​\t\tbos.write(b ^ 123);\n   ​\t}\n   ​\t\n   ​\tbis.close();\n   ​\tbos.close();\n\n####  10.17_IO流(拷贝文件)\n* 在控制台录入文件的路径,将文件拷贝到当前项目下\n\n   ```java\n   Scanner sc = new Scanner(System.in);\n   \tSystem.out.println(\"请输入一个文件路径\");\n   \tString line = sc.nextLine();\t\t\t\t//将键盘录入的文件路径存储在line中\n   \tFile file = new File(line);\t\t\t\t\t//封装成File对象\n   \tFileInputStream fis = new FileInputStream(file);\n   \tFileOutputStream fos = new FileOutputStream(file.getName());\n   \t\n   \tint len;\n   \tbyte[] arr = new byte[8192];\t\t\t\t//定义缓冲区\n   \twhile((len = fis.read(arr)) != -1) {\n   \t\tfos.write(arr,0,len);\n   \t}\n   \t\n   \tfis.close();\n   \tfos.close();\n   ```\n\n\n####  10.18_IO流(录入数据拷贝到文件)\n* 将键盘录入的数据拷贝到当前项目下的text.txt文件中,键盘录入数据当遇到quit时就退出\n\n\n\n   ```java\n   Scanner sc = new Scanner(System.in);\n   \tFileOutputStream fos = new FileOutputStream(\"text.txt\");\n   \tSystem.out.println(\"请输入:\");\n       while(true) {\n   \t\tString line = sc.nextLine();\n   \t\tif(\"quit\".equals(line))\n   \t\t\tbreak;\n   \t\tfos.write(line.getBytes());\n   \t\tfos.write(\"\\r\\n\".getBytes());\n   \t}\n    \t\n   fos.close();\n   ```\n\n   ####  10.19_day20总结\n\n### 11.字符流(字符流FileReader)\n\n- 1.字符流是什么\n\n  - 字符流是可以直接读写字符的IO流\n  - 字符流读取字符, 就要先读取到字节数据, 然后转为字符. 如果要写出字符, 需要把字符转为字节再写出.    \n\n- 2.FileReader\n\n  - FileReader类的read()方法可以按照字符大小读取\n\n- \n  ​\t\n\n  ```java\n  FileReader fr = new FileReader(\"aaa.txt\");\t\t\t\t//创建输入流对象,关联aaa.txt\n  int ch;\n  while((ch = fr.read()) != -1) {\t\t\t\t\t\t\t//将读到的字符赋值给ch\n  \tSystem.out.println((char)ch);\t\t\t\t\t\t//将读到的字符强转后打印\n  }\n  fr.close();\t\t\t\t\t\t\t\t\t\t\t\t//关流 \n  ```\n\n####  11.02_IO流(字符流FileWriter)\n\n- FileWriter类的write()方法可以自动把字符转\n\n- \n\n- 为字节写出\n\n  FileWriter fw = new FileWriter(\"aaa.txt\");\n  ​\tfw.write(\"aaa\");\n  ​\tfw.close();\n\n####  11.03_IO流(字符流的拷贝)\n​\t\n​\t\n\n```java\nFileReader fr = new FileReader(\"a.txt\");\nFileWriter fw = new FileWriter(\"b.txt\");\nint ch;\nwhile((ch = fr.read()) != -1) {\n\tfw.write(ch);\n}\n\nfr.close();\nfw.close();\n```\n\n####  11.04_IO流(什么情况下使用字符流)\n\n- 字符流也可以拷贝文本文件, 但不推荐使用. 因为读取时会把字节转为字符, 写出时还要把字符转回字节.\n- 程序需要读取一段文本, 或者需要写出一段文本的时候可以使用字符流\n- 读取的时候是按照字符的大小读取的,不会出现半个中文\n- 写出的时候可以直接将字符串写出,不用转换为字节数组\n\n####  11.05_IO流(字符流是否可以拷贝非纯文本的文件)\n\n- 不可以拷贝非纯文本的文件\n- 因为在读的时候会将字节转换为字符,在转换过程中,可能找不到对应的字符,就会用?代替,写出的时候会将字符转换成字节写出去\n- 如果是?,直接写出,这样写出之后的文件就乱了,看不了了  \n\n####  11.06_IO流(自定义字符数组的拷贝)\n\n- ​\t\n  FileReader fr = new FileReader(\"aaa.txt\");\t\t\t//创建字符输入流,关联aaa.txt\n  ​\tFileWriter fw = new FileWriter(\"bbb.txt\");\t\t\t//创建字符输出流,关联bbb.txt\n  ​\t\n\n  ```java\n  int len;\n  char[] arr = new char[1024*8];\t\t\t\t\t\t//创建字符数组\n  while((len = fr.read(arr)) != -1) {\t\t\t\t\t//将数据读到字符数组中\n  \tfw.write(arr, 0, len);\t\t\t\t\t\t\t//从字符数组将数据写到文件上\n  }\n  \n  fr.close();\t\t\t\t\t\t\t\t\t\t\t//关流释放资源\n  fw.close();\t\n  ```\n\n####  11.07_IO流(带缓冲的字符流) \n\n- BufferedReader的read()方法读取字符时会一次读取若干字符到缓冲区, 然后逐个返回给程序, 降低读取文件的次数, 提高效率\n\n- BufferedWriter的write()方法写出字符时会先写到缓冲区, 缓冲区写满时才会写到文件, 降低写文件的次数, 提高效率\n\n- BufferedReader br = new BufferedReader(new FileReader(\"aaa.txt\"));\t//创建字符输入流对象,关联aaa.txt\n  ​\tBufferedWriter bw = new BufferedWriter(new FileWriter(\"bbb.txt\"));\t//创建字符输出流对象,关联bbb.txt\n  ​\t\n\n  ```java\n  int ch;\t\t\t\t\n  while((ch = br.read()) != -1) {\t\t//read一次,会先将缓冲区读满,从缓冲去中一个一个的返给临时变量ch\n  \tbw.write(ch);\t\t\t\t\t//write一次,是将数据装到字符数组,装满后再一起写出去\n  }\n  \n  br.close();\t\t\t\t\t\t\t//关流\n  bw.close();  \n  ```\n\n####  11.08_IO流(readLine()和newLine()方法)\t\n\n- \n  ​\t\n\n  ```java\n   BufferedReader的readLine()方法可以读取一行字符(不包含换行符号)\n   BufferedWriter的newLine()可以输出一个跨平台的换行符号\"\\r\\n\"\n   BufferedReader br = new BufferedReader(new FileReader(\"aaa.txt\"));\n  BufferedWriter bw = new BufferedWriter(new FileWriter(\"bbb.txt\"));\n  String line;\n  \twhile((line = br.readLine()) != null) {\n  \tbw.write(line);\n  //bw.write(\"\\r\\n\");\t\t\t\t\t//只支持windows系统\n  \tbw.newLine();\t\t\t\t\t\t//跨平台的\n  \t}\n  br.close();\n  bw.close(); \n  ```\n\n\n####  11.09_IO流(将文本反转)\n\n- 将一个文本文档上的文本反转,第一行和倒数第一行交换,第二行和倒数第二行交换\n\n####  11.10_IO流(LineNumberReader) \n\n- LineNumberReader是BufferedReader的子类, 具有相同的功能, 并且可以统计行号\n\n  - 调用getLineNumber()方法可以获取当前行号\n  - 调用setLineNumber()方法可以设置当前行号\n\n- LineNumberReader lnr = new LineNumberReader(new FileReader(\"aaa.txt\"));\n  ​\tString line;\n  ​\tlnr.setLineNumber(100);\t\t\t\t\t\t\t\t\t//设置行号\n  ​\twhile((line = lnr.readLine()) != null) {\n  ​\t\tSystem.out.println(lnr.getLineNumber() + \":\" + line);//获取行号\n  ​\t}\n  ​\t\n\n  ```\n  lnr.close(); \n  ```\n\n####  11.11_IO流(装饰设计模式)\n\n- interface Coder {\n  ​\t\tpublic void code();\n  ​\t}\n  ​\t\n\n  ```java\n  class Student implements Coder {\n  \n  \t@Override\n  \tpublic void code() {\n  \t\tSystem.out.println(\"javase\");\n  \t\tSystem.out.println(\"javaweb\");\n  \t}\n  \t\n  }\n  \n  class HeiMaStudent implements Coder {\n  \tprivate Student s;\t\t\t\t\t\t//获取到被包装的类的引用\n  \tpublic HeiMaStudent(Student s) {\t\t//通过构造函数创建对象的时候,传入被包装的对象\n  \t\tthis.s = s;\n  \t}\n  \t@Override\n  \tpublic void code() {\t\t\t\t\t//对其原有功能进行升级\n  \t\ts.code();\n  \t\tSystem.out.println(\"数据库\");\n  \t\tSystem.out.println(\"ssh\");\n  \t\tSystem.out.println(\"安卓\");\n  \t\tSystem.out.println(\".....\");\n  \t}\n  \t\n  } \n  ```\n\n####  11.12_IO流(使用指定的码表读写字符) \n\n- FileReader是使用默认码表读取文件, 如果需要使用指定码表读取, 那么可以使用InputStreamReader(字节流,编码表)\n\n- FileWriter是使用默认码表写出文件, 如果需要使用指定码表写出, 那么可以使用OutputStreamWriter(字节流,编码表)\n\n- \n  ​\t\n\n  ```java\n  BufferedReader br = \t\t\t\t\t\t\t\t\t//高效的用指定的编码表读\n  \t\t\tnew BufferedReader(new InputStreamReader(new FileInputStream(\"UTF-8.txt\"), \"UTF-8\"));\n  \tBufferedWriter bw = \t\t\t\t\t\t\t\t\t//高效的用指定的编码表写\n  \t\t\tnew BufferedWriter(new OutputStreamWriter(new FileOutputStream(\"GBK.txt\"), \"GBK\"));\n  \tint ch;\n  \twhile((ch = br.read()) != -1) {\n  \t\tbw.write(ch);\n  \t}\n  br.close();\n  bw.close();\n  ```\n\n  ####  11.13_IO流(转换流图解)\n\n- 画图分析转换流\n\n####  11.14_IO流(获取文本上字符出现的次数)\n\n- 获取一个文本上每个字符出现的次数,将结果写在times.txt上\n\n####  11.15_IO流(试用版软件)\n\n- 当我们下载一个试用版软件,没有购买正版的时候,每执行一次就会提醒我们还有多少次使用机会用学过的IO流知识,模拟试用版软件,试用10次机会,执行一次就提示一次您还有几次机会,如果次数到了提示请购买正版\n\n####  11.16_File类(递归)\n\n- 5的阶乘\t\n\n####  11.17_File类(练习)\n\n- 需求:从键盘输入接收一个文件夹路径,打印出该文件夹下所有的.java文件名\n\n####  11.18_IO流(总结)\n\n- 1.会用BufferedReader读取GBK码表和UTF-8码表的字符\n- 2.会用BufferedWriter写出字符到GBK码表和UTF-8码表的文件中\n- 3.会使用BufferedReader从键盘读取一行\n- \n\n### 12.其他流\n\n﻿####  12.01_IO流(序列流)(了解)\n\n- 1.什么是序列流\n\n  - 序列流可以把多个字节输入流整合成一个, 从序列流中读取数据时, 将从被整合的第一个流开始读, 读完一个之后继续读第二个, 以此类推.\n\n- 2.使用方式\n\n  - 整合两个: SequenceInputStream(InputStream, InputStream)\n\n  - \n\n    ```java\n    FileInputStream fis1 = new FileInputStream(\"a.txt\");\t\t\t//创建输入流对象,关联a.txt\n    \tFileInputStream fis2 = new FileInputStream(\"b.txt\");\t\t\t//创建输入流对象,关联b.txt\n    \tSequenceInputStream sis = new SequenceInputStream(fis1, fis2);\t//将两个流整合成一个流\n    \tFileOutputStream fos = new FileOutputStream(\"c.txt\");\t\t\t//创建输出流对象,关联c.txt\n    \t\n    int b;\n    while((b = sis.read()) != -1) {\t\t\t\t\t\t\t\t\t//用整合后的读\n    \tfos.write(b);\t\t\t\t\t\t\t\t\t\t\t\t//写到指定文件上\n    }\n    \n    sis.close();\n    fos.close(); \n    ```\n\n    ####  12.02_IO流(序列流整合多个)(了解)\n\n- 整合多个: SequenceInputStream(Enumeration)\n\n\n\n  ```java\n  FileInputStream fis1 = new FileInputStream(\"a.txt\");\t//创建输入流对象,关联a.txt\n  \tFileInputStream fis2 = new FileInputStream(\"b.txt\");\t//创建输入流对象,关联b.txt\n  \tFileInputStream fis3 = new FileInputStream(\"c.txt\");\t//创建输入流对象,关联c.txt\n  \tVector<InputStream> v = new Vector<>();\t\t\t\t\t//创建vector集合对象\n  \tv.add(fis1);\t\t\t\t\t\t\t\t\t\t\t//将流对象添加\n  \tv.add(fis2);\n  \tv.add(fis3);\n  \tEnumeration<InputStream> en = v.elements();\t\t\t\t//获取枚举引用\n  \tSequenceInputStream sis = new SequenceInputStream(en);\t//传递给SequenceInputStream构造\n  \tFileOutputStream fos = new FileOutputStream(\"d.txt\");\n  \tint b;\n  \twhile((b = sis.read()) != -1) {\n  \t\tfos.write(b);\n  \t}\n  sis.close();\n  fos.close();\n  ```\n\n\n####  12.03_IO流(内存输出流*****)(掌握)\n\n- 1.什么是内存输出流\n\n  - 该输出流可以向内存中写数据, 把内存当作一个缓冲区, 写出之后可以一次性获取出所有数据\n\n- 2.使用方式\n\n  - 创建对象: new ByteArrayOutputStream()\n\n  - 写出数据: write(int), write(byte[])\n\n  - 获取数据: toByteArray()\n\n  - FileInputStream fis = new FileInputStream(\"a.txt\");\n    ​\tByteArrayOutputStream baos = new ByteArrayOutputStream();\n    ​\tint b;\n    ​\twhile((b = fis.read()) != -1) {\n    ​\t\tbaos.write(b);\n    ​\t}\n    ​\t\n\n    ```java\n    //byte[] newArr = baos.toByteArray();\t\t\t\t//将内存缓冲区中所有的字节存储在newArr中\n    //System.out.println(new String(newArr));\n    System.out.println(baos);\n    fis.close();\n    ```\n\n    ####  12.04_IO流(内存输出流之黑马面试题)(掌握)\n\n- 定义一个文件输入流,调用read(byte[] b)方法,将a.txt文件中的内容打印出来(byte数组大小限制为5)\n\n- FileInputStream fis = new FileInputStream(\"a.txt\");\t\t\t\t//创建字节输入流,关联a.txt\n  ​\t\tByteArrayOutputStream baos = new ByteArrayOutputStream();\t\t//创建内存输出流\n  ​\t\tbyte[] arr = new byte[5];\t\t\t\t\t\t\t\t\t\t//创建字节数组,大小为5\n  ​\t\tint len;\n  ​\t\twhile((len = fis.read(arr)) != -1) {\t\t\t\t\t\t\t//将文件上的数据读到字节数组中\n  ​\t\t\tbaos.write(arr, 0, len);\t\t\t\t\t\t\t\t\t//将字节数组的数据写到内存缓冲区中\n  ​\t\t}\n  ​\t\tSystem.out.println(baos);\t\t\t\t\t\t\t\t\t\t//将内存缓冲区的内容转换为字符串打印\n  ​\t\tfis.close();\n\n  ####  12.05_IO流(随机访问流概述和读写数据)(了解)\n\n- A:随机访问流概述\n\n  - RandomAccessFile概述\n  - RandomAccessFile类不属于流，是Object类的子类。但它融合了InputStream和OutputStream的功能。\n  - 支持对随机访问文件的读取和写入。\n\n- B:read(),write(),seek()\n\n####  12.06_IO流(对象操作流ObjecOutputStream)(了解)\n\n- 1.什么是对象操作流\n\n  - 该流可以将一个对象写出, 或者读取一个对象到程序中. 也就是执行了序列化和反序列化的操作.\n\n- 2.使用方式\n\n  - 写出: new ObjectOutputStream(OutputStream), writeObject()\n\n    public class Demo3_ObjectOutputStream {\n\n    ```java\n    \t/**\n    \t * @param args\n    \t * @throws IOException \n    \t * 将对象写出,序列化\n    \t */\n    \tpublic static void main(String[] args) throws IOException {\n    \t\tPerson p1 = new Person(\"张三\", 23);\n    \t\tPerson p2 = new Person(\"李四\", 24);\n    //\t\tFileOutputStream fos = new FileOutputStream(\"e.txt\");\n    //\t\tfos.write(p1);\n    //\t\tFileWriter fw = new FileWriter(\"e.txt\");\n    //\t\tfw.write(p1);\n    \t\t//无论是字节输出流,还是字符输出流都不能直接写出对象\n    \t\tObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"e.txt\"));//创建对象输出流\n    \t\toos.writeObject(p1);\n    \t\toos.writeObject(p2);\n    \t\toos.close();\n    \t}\n    \n    }\n    ```\n\n    ####  12.07_IO流(对象操作流ObjectInputStream)(了解)\n\n- 读取: new ObjectInputStream(InputStream), readObject()\n\n  - public class Demo3_ObjectInputStream {\n\n    ```java\n    \t/**\n    \t * @param args\n    \t * @throws IOException \n    \t * @throws ClassNotFoundException \n    \t * @throws FileNotFoundException \n    \t * 读取对象,反序列化\n    \t */\n    \tpublic static void main(String[] args) throws IOException, ClassNotFoundException {\n    \t\tObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"e.txt\"));\n    \t\tPerson p1 = (Person) ois.readObject();\n    \t\tPerson p2 = (Person) ois.readObject();\n    \t\tSystem.out.println(p1);\n    \t\tSystem.out.println(p2);\n    \t\tois.close();\n    \t}\n    \n    }\n    ```\n\n\n####  12.08_IO流(对象操作流优化)(了解)\n\n- 将对象存储在集合中写出\n\n\n  ​\t\n\n  ```java\n  - Person p1 = new Person(\"张三\", 23);\n    Person p2 = new Person(\"李四\", 24);\n    Person p3 = new Person(\"马哥\", 18);\n    Person p4 = new Person(\"辉哥\", 20);\n  \n    ArrayList<Person> list = new ArrayList<>();\n    list.add(p1);\n    list.add(p2);\n    list.add(p3);\n    list.add(p4);\n  \n    ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"f.txt\"));\n    oos.writeObject(list);\t\t\t\t\t\t\t\t\t//写出集合对象\n  \n    oos.close();\n  \n  - 读取到的是一个集合对象\n  \n    ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"f.txt\"));\n    \tArrayList<Person> list = (ArrayList<Person>)ois.readObject();\t//泛型在运行期会被擦除,索引运行期相当于没有泛型\n    \t//想去掉黄色可以加注解\t\t\t\n    \t@SuppressWarnings(\"unchecked\")\n    \t\tfor (Person person : list) {\n    \t\tSystem.out.println(person);\n    \t\t}\n  ois.close();\n  ```\n\n  ####  12.09_IO流(加上id号)(了解)\n\n- 注意\n\n  - 要写出的对象必须实现Serializable接口才能被序列化\n  - 不用必须加id号\n\n####  12.10_IO流(数据输入输出流)(了解)\n\n- 1.什么是数据输入输出流\n\n  - DataInputStream, DataOutputStream可以按照基本数据类型大小读写数据\n  - 例如按Long大小写出一个数字, 写出时该数据占8字节. 读取的时候也可以按照Long类型读取, 一次读取8个字节.\n\n- 2.使用方式\n\n  - \n    ​\t\n\n    ```java\n    DataOutputStream(OutputStream), writeInt(), writeLong() \n    \n    DataOutputStream dos = new DataOutputStream(new FileOutputStream(\"b.txt\"));\n    \tdos.writeInt(997);\n    \tdos.writeInt(998);\n    \tdos.writeInt(999);\n    dos.close();\n    DataInputStream(InputStream), readInt(), readLong()\n    \n    DataInputStream dis = new DataInputStream(new FileInputStream(\"b.txt\"));\n    \tint x = dis.readInt();\n    \tint y = dis.readInt();\n    \tint z = dis.readInt();\n    \tSystem.out.println(x);\n    \tSystem.out.println(y);\n    \tSystem.out.println(z);\n    \tdis.close();\n    ```\n\n  - \n\n####  12.11_IO流(打印流的概述和特点)(掌握)\n\n- 1.什么是打印流\n\n  - 该流可以很方便的将对象的toString()结果输出, 并且自动加上换行, 而且可以使用自动刷出的模式\n\n  - System.out就是一个PrintStream, 其默认向控制台输出信息\n\n    PrintStream ps = System.out;\n    ​\tps.println(97);\t\t\t\t\t//其实底层用的是Integer.toString(x),将x转换为数字字符串打印\n    ​\tps.println(\"xxx\");\n    ​\tps.println(new Person(\"张三\", 23));\n    ​\tPerson p = null;\n    ​\tps.println(p);\t\t\t\t\t//如果是null,就返回null,如果不是null,就调用对象的toString()\n\n- 2.使用方式\n\n  - 打印: print(), println()\n\n  - 自动刷出: PrintWriter(OutputStream out, boolean autoFlush, String encoding) \n\n  - 打印流只操作数据目的\n\n    PrintWriter pw = new PrintWriter(new FileOutputStream(\"g.txt\"), true);\n    ​\tpw.write(97);\n    ​\tpw.print(\"大家好\");\n    ​\tpw.println(\"你好\");\t\t\t\t//自动刷出,只针对的是println方法\n    ​\tpw.close();\n\n####  12.12_IO流(标准输入输出流概述和输出语句)\n\n- 1.什么是标准输入输出流(掌握)\n\n  - System.in是InputStream, 标准输入流, 默认可以从键盘输入读取字节数据\n  - System.out是PrintStream, 标准输出流, 默认可以向Console中输出字符和字节数据\n\n- 2.修改标准输入输出流(了解)\n\n  - 修改输入流: System.setIn(InputStream)\n\n  - 修改输出流: System.setOut(PrintStream)\n\n  - \n    ​\t\n\n    ```java\n    System.setIn(new FileInputStream(\"a.txt\"));\t\t\t\t//修改标准输入流System.setOut(new PrintStream(\"b.txt\"));\t\t\t\t//修改标准输出流\n    InputStream in = System.in;\t\t\t\t\t\t\t\t//获取标准输入流\n    PrintStream ps = System.out;\t\t\t\t\t\t\t//获取标准输出流\n    int b;\n    while((b = in.read()) != -1) {\t\t\t\t\t\t\t//从a.txt上读取数据\n    \tps.write(b);\t\t\t\t\t\t\t\t\t\t//将数据写到b.txt上\n    }\n    \n    in.close();\n    ps.close();\n    ```\n\n####  12.13_IO流(修改标准输入输出流拷贝图片)(了解)\n​\t\t\n​\t\t\n\n```java\nSystem.setIn(new FileInputStream(\"IO图片.png\"));\t\t//改变标准输入流\nSystem.setOut(new PrintStream(\"copy.png\")); \t\t//改变标准输出流\nInputStream is = System.in;\t\t\t\t\t\t\t//获取标准输入流\n\tPrintStream ps = System.out;\t\t\t\t\t\t//获取标准输出流\n\t\n\tint len;\n\tbyte[] arr = new byte[1024 * 8];\n\t\n\twhile((len = is.read(arr)) != -1) {\n\t\tps.write(arr, 0, len);\n\t}\n\t\n\tis.close();\n\tps.close();\n```\n\n####  12.14_IO流(两种方式实现键盘录入)(了解)\n\n- A:BufferedReader的readLine方法。\n  - BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n- B:Scanner\n\n####  12.15_IO流(Properties的概述和作为Map集合的使用)(了解)\n\n- A:Properties的概述\n  - Properties 类表示了一个持久的属性集。\n  - Properties 可保存在流中或从流中加载。\n  - 属性列表中每个键及其对应值都是一个字符串。 \n- B:案例演示\n  - Properties作为Map集合的使用\n\n####  12.16_IO流(Properties的特殊功能使用)(了解)\n\n- A:Properties的特殊功能\n  - public Object setProperty(String key,String value)\n  - public String getProperty(String key)\n  - public Enumeration<String> stringPropertyNames()\n- B:案例演示\n  - Properties的特殊功能\n\n####  12.17_IO流(Properties的load()和store()功能)(了解)\n\n- A:Properties的load()和store()功能\n- B:案例演示\n  - Properties的load()和store()功能\n\n####  12.18_day22总结\n\n- 把今天的知识点总结一遍。\n\n\n\n\n\n\n\n","tags":["java"],"categories":["开发工具"]},{"title":"用第三方sdk解决微信授权","url":"/2018/10/22/用第三方sdk解决微信授权/","content":" **好身材才是男人最美丽的衣服**<Excerpt in index | 首页摘要>\n 运用sdk快速解决微信授权,解决大量的微信文档!\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 1.引入依赖:\n```xml\n        <dependency>\n\t\t\t<groupId>com.github.binarywang</groupId>\n\t\t\t<artifactId>weixin-java-mp</artifactId>\n\t\t\t<version>2.7.0</version>\n\t\t</dependency>\n```\n\n## 2.建立一个Controller\n```java\npackage com.imooc.controller;\n\nimport com.imooc.config.ProjectUrlConfig;\nimport com.imooc.enums.ResultEnum;\nimport com.imooc.exception.SellException;\nimport lombok.extern.slf4j.Slf4j;\nimport me.chanjar.weixin.common.api.WxConsts;\nimport me.chanjar.weixin.common.exception.WxErrorException;\nimport me.chanjar.weixin.mp.api.WxMpService;\nimport me.chanjar.weixin.mp.bean.result.WxMpOAuth2AccessToken;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\n\nimport java.net.URLEncoder;\n\n/**\n * Created by 廖师兄\n * 2017-07-03 01:20\n */\n@Controller\n@RequestMapping(\"/wechat\")\n@Slf4j\npublic class WechatController {\n\n    @Autowired\n    private WxMpService wxMpService;\n\n    @Autowired\n    private WxMpService wxOpenService;\n\n    @Autowired\n    private ProjectUrlConfig projectUrlConfig;\n\n    @GetMapping(\"/authorize\")\n    public String authorize(@RequestParam(\"returnUrl\") String returnUrl) {\n        //1. 配置\n        //2. 调用方法\n        String url = projectUrlConfig.getWechatMpAuthorize() + \"/sell/wechat/userInfo\";\n        String redirectUrl = wxMpService.oauth2buildAuthorizationUrl(url, WxConsts.OAUTH2_SCOPE_BASE, URLEncoder.encode(returnUrl));\n        return \"redirect:\" + redirectUrl;\n    }\n\n    @GetMapping(\"/userInfo\")\n    public String userInfo(@RequestParam(\"code\") String code,\n                         @RequestParam(\"state\") String returnUrl) {\n        WxMpOAuth2AccessToken wxMpOAuth2AccessToken = new WxMpOAuth2AccessToken();\n        try {\n            wxMpOAuth2AccessToken = wxMpService.oauth2getAccessToken(code);\n        } catch (WxErrorException e) {\n            log.error(\"【微信网页授权】{}\", e);\n            throw new SellException(ResultEnum.WECHAT_MP_ERROR.getCode(), e.getError().getErrorMsg());\n        }\n\n        String openId = wxMpOAuth2AccessToken.getOpenId();\n\n        return \"redirect:\" + returnUrl + \"?openid=\" + openId;\n    }\n\n    @GetMapping(\"/qrAuthorize\")\n    public String qrAuthorize(@RequestParam(\"returnUrl\") String returnUrl) {\n        String url = projectUrlConfig.getWechatOpenAuthorize() + \"/sell/wechat/qrUserInfo\";\n        String redirectUrl = wxOpenService.buildQrConnectUrl(url, WxConsts.QRCONNECT_SCOPE_SNSAPI_LOGIN, URLEncoder.encode(returnUrl));\n        return \"redirect:\" + redirectUrl;\n    }\n\n    @GetMapping(\"/qrUserInfo\")\n    public String qrUserInfo(@RequestParam(\"code\") String code,\n                             @RequestParam(\"state\") String returnUrl) {\n        WxMpOAuth2AccessToken wxMpOAuth2AccessToken = new WxMpOAuth2AccessToken();\n        try {\n            wxMpOAuth2AccessToken = wxOpenService.oauth2getAccessToken(code);\n        } catch (WxErrorException e) {\n            log.error(\"【微信网页授权】{}\", e);\n            throw new SellException(ResultEnum.WECHAT_MP_ERROR.getCode(), e.getError().getErrorMsg());\n        }\n        log.info(\"wxMpOAuth2AccessToken={}\", wxMpOAuth2AccessToken);\n        String openId = wxMpOAuth2AccessToken.getOpenId();\n\n        return \"redirect:\" + returnUrl + \"?openid=\" + openId;\n    }\n}\n\n```\n## 3.配置文件\n```java\nimport me.chanjar.weixin.mp.api.WxMpConfigStorage;\nimport me.chanjar.weixin.mp.api.WxMpInMemoryConfigStorage;\nimport me.chanjar.weixin.mp.api.WxMpService;\nimport me.chanjar.weixin.mp.api.impl.WxMpServiceImpl;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.stereotype.Component;\n\n/**\n * Created by 廖师兄\n * 2017-07-03 01:25\n */\n@Component\npublic class WechatMpConfig {\n\n    @Autowired\n    private WechatAccountConfig accountConfig;\n\n    @Bean\n    public WxMpService wxMpService() {\n        WxMpService wxMpService = new WxMpServiceImpl();\n        wxMpService.setWxMpConfigStorage(wxMpConfigStorage());\n        return wxMpService;\n    }\n\n    @Bean\n    public WxMpConfigStorage wxMpConfigStorage() {\n        WxMpInMemoryConfigStorage wxMpConfigStorage = new WxMpInMemoryConfigStorage();\n        wxMpConfigStorage.setAppId(accountConfig.getMpAppId());\n        wxMpConfigStorage.setSecret(accountConfig.getMpAppSecret());\n        return wxMpConfigStorage;\n    }\n}\n\n```\n","tags":["java"],"categories":["开发工具"]},{"title":"并查集(Union Find)","url":"/2018/10/22/并查集(Union Find)/","content":" **仰望星空,脚踏实地,暗无天日,登峰造极**<Excerpt in index | 首页摘要>\n学习算法思想,修炼编程内功!\n\n<!-- more -->\n<The rest of contents | 余下全文>\n# 并查集(Union Find)\n\n## 1.什么是并查集\n\n> * 是一种很不一样的树形结构\n> * 适合解决链接问题\n> * 网络中节点的链接状态\n> * 数学中集合类的实现(并集)\n>\n>\n\n## 2.并查集1.0版本的实现(Quick find 查的快,并的慢)\n\n```c++\n#include <iostream>\n#include <cassert>\n\nusing namespace std;\n\nclass UnionFind {\nprivate :\n    int *id;\n    int count;\npublic:\n    UnionFind(int n) {\n        count = n;\n        id = new int[n];\n        for (int i = 0; i < n; i++)\n            id[i] = i;\n    }\n\n    ~UnionFind() {\n        delete[]id;\n    }\n    int find(int p){\n        assert(p>=0&&p<count);\n        return id[p];\n    }\n    bool isConnected(int p,int q){\n        return find(p)==find(q);\n    }\n    void unionElements(int p ,int q){\n        int pid=find(p);\n        int qid=find(q);\n        if(q!=p){\n            for(int i=0;i<count;i++){\n                if(id[i]==pid)\n                    id[i]=qid;\n            }\n        }\n    }\n};\n```\n\n## 3.使用指向父亲节点实现并查集\n\n![1539598030956](/img/1539598030956.png)\n\n```c++\n#include <assert.h>\n#ifndef ARITHMETIC_IMOOC_UNIONFIND2_H\n#define ARITHMETIC_IMOOC_UNIONFIND2_H\n\n#endif //ARITHMETIC_IMOOC_UNIONFIND2_H\nnamespace UP2 {\n\n    class UnionFind {\n    private:\n        int *parent;\n        int count;\n    public:\n        UnionFind(int count) {\n            parent = new int[count];\n            this->count = count;\n            for (int i = 0; i < count; i++) {\n                parent[i] = i;\n            }\n        }\n        ~UnionFind() {\n            delete[] parent;\n        }\n        int find(int p){\n            assert(p>=0&&p<count);\n            while(p!=parent[p])\n                p=parent[p];\n            return p;\n        }\n        bool isConnection(int p,int q){\n            return find(p)==find(q);\n        }\n        void unionElements(int p,int q){\n            int pRoot=find(p);\n            int qRoot=find(q);\n            if(pRoot!=qRoot)\n                parent[pRoot]=parent[qRoot];\n        }\n    };\n}\n```\n\n## 4.并查集的优化(判断元素的层级尺寸再合并)\n\n```c++\n//\n// Created by JIA on 2018/10/15.\n//\n#include <assert.h>\n#ifndef ARITHMETIC_IMOOC_UNIONFIND2_H\n#define ARITHMETIC_IMOOC_UNIONFIND2_H\n\n#endif //ARITHMETIC_IMOOC_UNIONFIND2_H\nnamespace UP3 {\n\n    class UnionFind {\n    private:\n        int *parent;\n        int *sz;\n        int count;\n    public:\n        UnionFind(int count) {\n            parent = new int[count];\n            sz=new int[count];\n            this->count = count;\n            for (int i = 0; i < count; i++) {\n                parent[i] = i;\n                sz[i]=1;\n            }\n        }\n        ~UnionFind() {\n            delete[] parent;\n        }\n        int find(int p){\n            assert(p>=0&&p<count);\n            while(p!=parent[p])\n                p=parent[p];\n            return p;\n        }\n        bool isConnection(int p,int q){\n            return find(p)==find(q);\n        }\n        void unionElements(int p,int q){\n            int pRoot=find(p);\n            int qRoot=find(q);\n            if(pRoot==qRoot)\n                return ;\n            if(sz[pRoot]<sz[qRoot]){\n                parent[pRoot]=qRoot;\n                sz[qRoot]+=sz[pRoot];\n            }else{\n                parent[qRoot]=pRoot;\n                sz[pRoot]+=sz[qRot];\n            }\n\n        }\n    };\n}\n```\n\n## 5.通过路径压缩算法实现并查集的优化\n\n```c++\n      int find(int p){\n            assert(p>=0&&p<count);\n            while(p!=parent[p]){\n                p=parent[p];\n                parent[p]=parent[parent[p]];//路径压缩的实现\n            }\n            return p;     \n          //第二个版本的路径压缩算法,使用递归实现\n            if (p != parent[p])\n                parent[p] != find(parent[p]);\n            return parent[p];\n        }\n\n```\n\n\n\n\n\n ","tags":["算法"],"categories":["算法学习"]},{"title":"SpringMvc的一些方法","url":"/2018/10/22/SpringMvc的一些方法/","content":"\n** 失败者找理由,成功者找方法!** <Excerpt in index | 首页摘要>\n对SpringMvc的一些常用方法\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 1.Spring-mvc中关于表单中String日期转换为Date的工具类(实现*Converter*接口)\n> 需要实现一个接口,并重写一个方法,如下:\n\n```java\npackage com.itheima.springmvc.utils;\n\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\nimport org.springframework.core.convert.converter.Converter;\n\npublic class DateConvert2 implements Converter<String, Date>{\n\n\t@Override\n\tpublic Date convert(String arg0) {\n\t\tDate date=null;\n\t\ttry {\n\t\t\tSimpleDateFormat df=new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n\t\t\tdate=df.parse(arg0);\n\t\t} catch (ParseException e) {\n\t\t\te.printStackTrace();\n\t\t}\t\t\n\t\treturn date;\n\t}\n}\n```\n> 使用这个转换器需要在spring的配置文件中添加相应的bean,如下:\n\n     <!-- 配置注解驱动，相当于同时使用最新处理器映射跟处理器适配器,对json数据响应提供支持 -->\n\t<!-- 使用自定义转换器 -->\n\t<mvc:annotation-driven conversion-service=\"MyConvert\" />\n\t\n\t<!-- 定义转换器 -->\n\t<bean id=\"MyConvert\" class=\"org.springframework.format.support.FormattingConversionServiceFactoryBean\">\n\t\t<property name=\"converters\">\n\t\t\t<set>\n\t\t\t\t<bean class=\"com.itheima.springmvc.utils.DateConvert\" />\n\t\t\t</set>\n\t\t</property>\n\t</bean>\n## 2.web端关于get和post请求乱码的解决方案(web.xml中添加过滤器)\n\t\t<!-- 解决post乱码问题 -->\n\t<filter>\n\t\t<filter-name>encoding</filter-name>\n\t\t<filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>\n\t\t<!-- 设置编码参是UTF8 -->\n\t\t<init-param>\n\t\t\t<param-name>encoding</param-name>\n\t\t\t<param-value>UTF-8</param-value>\n\t\t</init-param>\n\t</filter>\n\t<filter-mapping>\n\t\t<filter-name>encoding</filter-name>\n\t\t<url-pattern>/*</url-pattern>\n\t</filter-mapping>\n***\n>修改tomcat中server.xml 文件解决get请求乱码(最方便的方法)\n>- **URLEncoding=\"utf-8\"** 为添加部分\n```xml\n  <Connector URLEncoding=\"utf-8\" connectionTimeout=\"20000\" port=\"8080\" protocol=\"HTTP/1.1\" redirectPort=\"8443\"/>\n```\n***\n\n>也可以使用自定义的拦截器实现(get和post请求均解决乱码问题):\n>- 运用动态代理的设计模式\n\n```java\npackage com.jia.filter;\n\nimport java.io.IOException;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\n\nimport javax.servlet.Filter;\nimport javax.servlet.FilterChain;\nimport javax.servlet.FilterConfig;\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.annotation.WebFilter;\nimport javax.servlet.http.HttpServletRequest;\n\npublic class Filter04 implements Filter {\n\n\tpublic void destroy() {\n\t}\n\n\tpublic void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n\t\tHttpServletRequest req=(HttpServletRequest)request;\n\t\tProxy.newProxyInstance(Filter04.class.getClassLoader(), xxx.class.getInterfaces(), new InvocationHandler() {\n\n\t\t\t@Override\n\t\t\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\t\t\t\tif(method.getName().equalsIgnoreCase(\"getAttribute\")) {\n\t\t\t\t\tString md=req.getMethod();\n\t\t\t\t\tif(\"get\".equals(md)) {\n\t\t\t\t\t\tString reuslt=(String)method.invoke(req, args);\n\t\t\t\t\t\tString str=new String(reuslt.getBytes(\"iso-8858-1\"),\"utf-8\");\n\t\t\t\t\t\treturn str;\n\n\t\t\t\t\t}else {\n\t\t\t\t\t\treq.setCharacterEncoding(\"utf-8\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t});\n\t}  \n\tpublic void init(FilterConfig fConfig) throws ServletException {\n\t}\n}\n```\n##3.在Controller中返回值为String时可以跳转到相应的页面\n>直接跳转到固定页面:\n```java\nRequestMapping(\"itemEdit\")\n\tpublic String itemEdit(Model model, @RequestParam(value = \"id\", required = true, defaultValue = \"1\") Integer ids) {\n\t\t// 查询商品信息\n\t\tItem item = itemService.getItemById(ids);\n\t\t// model返回数据模型\n\t\tmodel.addAttribute(\"item\", item);\n\t\t// mav.addObject(\"item\", item);\n\t\treturn \"itemEdit\";\n\t}\n```\n***\n>请求跳转到其他页面\n>- \"forward:xxx.action\"\n>\n>重定向到其他页面\n>- \"redirect:yyy.action\"\n***\n## 4.HandlerExceptionResolver 接口处理全局异常\n***\n## 5.springmvc上传文件写法(图片)\n![Alt text](/img/1534579880860.png)\n>需要加载的jar包\n![Alt text](/img/1534579925554.png)\n>配置多媒体解析器\n```\n<!-- 配置多媒体处理器 -->\n\t<!-- 注意：这里id必须填写：multipartResolver -->\n\t<bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\">\n\t\t<!-- 最大上传文件大小 -->\n\t\t<property name=\"maxUploadSize\" value=\"8388608\" />\n\t</bean>\n\n```\n>前端代码\n```xml\n<!-- 上传图片是需要指定属性 enctype=\"multipart/form-data\" -->\n\t<!-- <form id=\"itemForm\" action=\"\" method=\"post\" enctype=\"multipart/form-data\"> -->\n\t<form id=\"itemForm\"\taction=\"${pageContext.request.contextPath }/updateItem.action\" enctype=\"multipart/form-data\" method=\"post\">\n\t\t<input type=\"hidden\" name=\"id\" value=\"${item.id }\" /> 修改商品信息：\n\t\t<table width=\"100%\" border=1>\t\t\t\n\t\t\t<tr>\n\t\t\t\t<td>商品图片</td>\n\t\t\t\t<td>\n\t\t\t\t\t<c:if test=\"${item.pic !=null}\">\n\t\t\t\t\t\t<img src=\"/pic/${item.pic}\" width=100 height=100/>\n\t\t\t\t\t\t<br/>\n\t\t\t\t\t</c:if>\n\t\t\t\t\t<input type=\"file\"  name=\"pictureFile\"/> \n\t\t\t\t</td>\n\t\t\t</tr>\t\t\t\n\t\t</table>\n\t</form>\n```\n>上传文件后端代码\n```java\n//图片上传用MultipartFile接收文件\n\t@RequestMapping(value = \"updateItem\", method = { RequestMethod.POST, RequestMethod.GET })\n\tpublic String updateItem(Item item, Model model, MultipartFile picFile) throws Exception {\n\n\t\t// 图片新名字\n\t\tString name = UUID.randomUUID().toString();\n\t\t// 图片原名字\n\t\tString oldName = picFile.getOriginalFilename();\n\t\t// 后缀名\n\t\tString exeName = oldName.substring(oldName.lastIndexOf(\".\"));\n\n\t\tFile pic = new File(\"D:\\\\WebWork\\\\\" + name + exeName);\n\t\t// 保存图片到本地磁盘\n\t\tpicFile.transferTo(pic); \n\t\t// 更新商品图片信息\n\t\titem.setPic(name + exeName);\n\n\t\titemServices.update(item);\n\t\tmodel.addAttribute(\"item\", item);\n\t\tmodel.addAttribute(\"msg\", \"修改商品成功\");\n\t\treturn \"itemEdit\";\n\t}\n\n```","tags":["java"],"categories":["开源框架"]},{"title":"二分搜索树(Binary Seacher  Tree)","url":"/2018/10/14/二分搜索树(Binary Seacher  Tree)/","content":" **仰望星空,脚踏实地,暗无天日,登峰造极**<Excerpt in index | 首页摘要>\n学习算法思想,修炼编程内功!\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n### 1.二分查找\n\n> 一份为二,折半查找\n>\n> **要求**:待查找数组必须有序\n\n```c++\nusing namespace std;\ntemplate <typename T>\nint binarySearch(T arr[],int n,T target){\n    int l=0,r=n-1;\n    while(l<=r){\n        //int mid=(l+r)/2;  这样写存在bug,可能会溢出\n        int mid=l+(r-l)/2;\n        if(arr[mid]==target)\n            return mid;\n        if(target<mid)\n            r=mid-1;\n        else\n            l=mid+1;\n    }\n    return -1;\n}\n```\n\n> 递归实现二分查找\n\n```c++\ntemplate<typename T>\nint reBinarySearch(T arr[], T k, int l, int r) {\n    int mid = (l + r) / 2;\n    if (l > r)\n        return -1;\n    if (arr[mid] == k)\n        return mid;\n    else if (k < arr[mid])\n        reBinarySearch(arr, k, l, mid - 1);\n    else\n        reBinarySearch(arr, k, mid + 1, r);\n}\n```\n\n### 2.二分搜索树\n\n#### 2.1二分搜索树的优势:\n\n- 高效:\n\n  ​\t在查找,插入,删除都能以O(lgn)的时间复杂度完成\n\n- min,max,floor,ceil,rank,select 实现都将很方便\n\n- 在实际应用中,比如要查找一篇文章中某个词出现的次数,用二分搜索树效率将会异常的高\n\n![1539167904772](/img/1539167904772.png)\n\n#### 2.2 二分搜索树的定义:\n\n> - 在定义中天然的包括了递归结构\n> - 二分搜索树不一定是一颗完全二叉树\n\n![1539168446767](/img/1539168446767.png)\n\n#### 2.3向二叉搜索树中插入新的健值对的实现\n\n```c++\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <ctime>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\ntemplate<typename Key, typename Value>\nclass BST {\nprivate:\n    struct Node {\n        Key key;\n        Value value;\n        Node *left;\n        Node *right;\n\n        Node(Key key, Value value) {\n            this->key = key;\n            this - value = value;\n            this->right = this->left = NULL;\n        }\n    };\n    Node *root;//存根\n    int count;//存一共有的节点个数\n\npublic:\n    BST() {\n        root = NULL;\n        count = 0;\n    }\n    ~BST(){\n        //TODO\n    }\n    int size(){\n        return count;\n    }\n    bool isEmpty(){\n        return count==0;\n    }\n    void insert(Key key,Value value){\n        root = insert(root ,key,value);\n    }\nprivate:\n    //以node为根的二叉搜索树中插入节点(key,value)\n    //放回插入新节点后的二叉搜索树的根\n    Node* insert(Node *node,Key key,Value value){\n        if(node->key==NULL){\n            count++;\n//            node->key=key;\n//            node->value=value;\n            return new Node(key,value);\n        }\n        if(node->key==key)\n            node->value=value;\n        else if(node->key<key)\n            node->left=insert(node->left,key,value);\n        else\n            node->right=insert(node->right,key,value);\n        return node;\n    }\n};\n```\n\n### 2.4二分搜索树实现搜素和是否存在某个值得函数\n\n```c++\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <ctime>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\ntemplate<typename Key, typename Value>\nclass BST {\nprivate:\n    struct Node {\n        Key key;\n        Value value;\n        Node *left;\n        Node *right;\n\n        Node(Key key, Value value) {\n            this->key = key;\n            this - value = value;\n            this->right = this->left = NULL;\n        }\n    };\n    Node *root;//存根\n    int count;//存一共有的节点个数\n\npublic:\n    BST() {\n        root = NULL;\n        count = 0;\n    }\n    ~BST(){\n        //TODO\n    }\n    int size(){\n        return count;\n    }\n    bool isEmpty(){\n        return count==0;\n    }\n    void insert(Key key,Value value){\n        root = insert(root ,key,value);\n    }\n    //查找二叉搜索树是否存在key\n    bool contain(Key key){\n        return contain(root,key);\n    }\n    //查找key相应节点所对应的Value地址\n    Value* search(Key key){\n        return search(root,key);\n    }\nprivate:\n    //以node为根的二叉搜索树中插入节点(key,value)\n    //放回插入新节点后的二叉搜索树的根\n    Node* insert(Node *node,Key key,Value value){\n        if(node->key==NULL){\n            count++;\n//            node->key=key;\n//            node->value=value;\n            return new Node(key,value);\n        }\n        if(node->key==key)\n            node->value=value;\n        else if(node->key<key)\n            node->left=insert(node->left,key,value);\n        else\n            node->right=insert(node->right,key,value);\n        return node;\n    }\n    bool contain(Node* node ,Key key){\n        if(node==NULL)\n            return false;\n        if(node->key==key)\n            return true;\n        else if(key<node->key)\n            return contain(node->key,key);\n        else\n            return contain(node->right.key);\n    }\n    Value* search(Node* node,Key key){\n        if(node==NULL)\n            return NULL;\n        if(node->key==key)\n            return &(node->value);\n        else if(key<node->key)\n            return search(node->left,key);\n        else\n            return search(node->right,key);\n\n    }\n};\n```\n\n### 2.5二分搜索树的前,中,后序遍历,以及二分搜素树的销毁\n\n```c++\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <ctime>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\ntemplate<typename Key, typename Value>\nclass BST {\nprivate:\n    struct Node {\n        Key key;\n        Value value;\n        Node *left;\n        Node *right;\n        Node(Key key, Value value) {\n            this->key = key;\n            this - value = value;\n            this->right = this->left = NULL;\n        }\n    };\n    Node *root;//存根\n    int count;//存一共有的节点个数\npublic:\n    BST() {\n        root = NULL;\n        count = 0;\n    }\n    ~BST() {\n        destory(root);\n    }\n    int size() {\n        return count;\n    }\n    bool isEmpty() {\n        return count == 0;\n    }\n    void insert(Key key, Value value) {\n        root = insert(root, key, value);\n    }\n    //查找二叉搜索树是否存在key\n    bool contain(Key key) {\n        return contain(root, key);\n    }\n    //查找key相应节点所对应的Value地址\n    Value *search(Key key) {\n        return search(root, key);\n    }\n    //前序遍历\n    void preOreder() {\n        preOreder(root);\n    }\n    //中序遍历\n    void inOrder() {\n        inOrder(root);\n    }\n    //后序遍历\n    void postOrder() {\n        postOrder(root);\n    }\nprivate:\n//以node为根的二叉搜索树中插入节点(key,value)\n//放回插入新节点后的二叉搜索树的根\n    Node *insert(Node *node, Key key, Value value) {\n        if (node->key == NULL) {\n            count++;\n//            node->key=key;\n//            node->value=value;\n            return new Node(key, value);\n        }\n        if (node->key == key)\n            node->value = value;\n        else if (node->key < key)\n            node->left = insert(node->left, key, value);\n        else\n            node->right = insert(node->right, key, value);\n        return node;\n    }\n    bool contain(Node *node, Key key) {\n        if (node == NULL)\n            return false;\n        if (node->key == key)\n            return true;\n        else if (key < node->key)\n            return contain(node->key, key);\n        else\n            return contain(node->right.key);\n    }\n    Value *search(Node *node, Key key) {\n        if (node == NULL)\n            return NULL;\n        if (node->key == key)\n            return &(node->value);\n        else if (key < node->key)\n            return search(node->left, key);\n        else\n            return search(node->right, key);\n    }\n    void preOrder(Node *node) {\n        if (node != NULL) {\n            cout << node.key << \" \";\n            preOreder(node->left);\n            preOrder(node->right);\n        }\n    }\n    void inOrder(Node *node) {\n        if (node != NULL) {\n            inOrder(node->left);\n            cout << node->key << \" \";\n            inOrder(node->right);\n        }\n    }\n    void postOrder(Node *node) {\n        if (node != NULL) {\n            postOrder(node->left);\n            postOrder(node->right);\n            cout << node->key << \" \";\n        }\n    }\n    void destory(Node *node) {\n        if (node != NULL) {\n            destory(node->left);\n            destory(node->right);\n            delete node;\n            count--;\n        }\n    }\n};\n```\n\n### 2.6二分搜索树的广度优先遍历(层序遍历)\n\n![1539226708430](/img/1539226708430.png)\n\n> 代码实现\n\n```c++\n//二叉搜索树的程序遍历\n    void levelOrder() {\n        queue<Node *> q;\n        q.push(root);\n        while (!q.empty()) {\n            Node node = q.front();\n            q.pop();\n            count << node->key << \" \" << node->value << \"  \";\n            if (node.left)\n                q.push(node.left);\n            if (node.right)\n                q.push(node.left);\n        }\n    }\n\n```\n\n### 2.7找出最大值和最小值函数实现\n\n```c++\n Key minimum() {\n        assert(count != 0);\n        Node node = root;\n        while (node.left != NULL)\n            node = node.left;\n        return node.key;\n    }\n\n    Key maximum() {\n        assert(count != 0);\n        Node node = root;\n        while (node.right != NULL)\n            node = node.right;\n        return node;\n    }\n```\n\n### 2.8二分搜素树的删除节点\n> 删除最大值和最小值函数的实现:\n\n```c++\n//删除二分搜索树的最小节点\n    void removeMin(){\n        if(root)\n            root = removeMin(root);\n    }\n    //删除二分搜索树的最大节点\n    void removeMax(){\n        if(root)\n            root=removeMax(root);\n    }\nprivate:\nNode* removeMin(Node* node){\n        if(node->left==NULL){\n           Node* rightNode=node->right;\n           delete  node;\n           count--;\n           return rightNode;\n        }\n        node->left=removeMin(node->left);\n        return node;\n    }\n    Node* removeMax(Node* node){\n        if(node->right==NULL){\n            Node* leftNode=node->left;\n            delete node;\n            count--;\n            return leftNode;\n        }\n        node->right=removeMax(node->right);\n        return node;\n    }\n```\n\n> 二分搜索树删除指定节点:\n\n![1539588249714](/img/1539588249714.png)\n\n```c++\n //删除二叉树的指定节点\n    void remove(Key key) {\n        root = remove(root, key);\n    }\nprivate:    \n    Node *remove(Node *node, Key key) {\n        if (node == NULL)\n            return NULL;\n        if (key < node->key) {\n            node->left = remove(node->left, key);\n            return node;\n        } else if (key > node->key) {\n            node->right = remove(node->right, key);\n            return node;\n        } else {   //key=node.key的情况\n            if (node->left == NULL) {\n                Node *rightNode = node->right;\n                delete node;\n                count--;\n                return rightNode;\n            }\n            if (node->right == NULL) {\n                Node *leftNode = node->left;\n                delete node;\n                count--;\n                return leftNode;\n            }\n            //node.left!=null&&node.right!=null;\n            Node *successor = new Node(minimum(node->right));\n            count++;\n            successor->right = removeMin(node->right);\n            successor->left = node->left;\n            delete node;\n            count--;\n            return successor;\n        }\n    }\n```\n\n### 2.9二分查找树的局限性\n\n\n\n\n","tags":["算法"],"categories":["算法学习"]},{"title":"堆排序(heapSort)","url":"/2018/10/13/堆排序(heapSort)/","content":" **仰望星空,脚踏实地,暗无天日,登峰造极**<Excerpt in index | 首页摘要>\n学习算法思想,修炼编程内功!\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n## 堆排序(heapSort)\n\n### 1.堆排序的实现:\n\n```c++\n#include <string>\n#include <ctime>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\ntemplate<typename T>\n\nvoid __shiftDown(T arr[],int n,int k){\n    while(2*k+1<n){\n        int j=2*k+1;\n        if(j+1<n&&arr[j+1]>arr[j])\n            j+=1;\n        if(arr[k]>arr[j])\n            break;\n            swap(arr[j],arr[k]);\n            k=j;\n    }\n}\ntemplate<typename T>\nvoid heapSort(T arr[],int n){\n    for(int i=(n-1)/2;i>=0;i--)\n    __shiftDown(arr,n,i);\n    for(int i=n-1;i>0;i--){\n        swap(arr[0],arr[i]);\n        __shiftDown(arr,i,0);\n    }\n}\n```\n\n### 2.排序算法总结:\n\n> 排序苏算法的稳定性:对于相等的元素,在排序后,原来靠前的元素依然靠前.相等元素的相对位置没有发生改变.\n>\n> 在某次场景会考虑到排序算法的稳定性.比如:学生的姓名是按字典序排列的,根据分数排序后,相同分数的学生还应该按照字典序排列.(插入排序和归并排序是稳定的排序算法)\n>\n> ![1539159816193](/img/1539159816193.png)\n\n![1539159633630](/img/1539159633630.png)\n\n","tags":["算法"],"categories":["算法学习"]},{"title":"堆(Heap)","url":"/2018/10/13/堆的学习(Heap)/","content":" **仰望星空,脚踏实地,暗无天日,登峰造极**<Excerpt in index | 首页摘要>\n学习算法思想,修炼编程内功!\n\n<!-- more -->\n<The rest of contents | 余下全文>\n## 堆的学习(Heap)\n\n> 什么是优先队列:\n>\n> > 普通队列:先进先出;后进后出\n> >\n> > 优先队列:出队列和入队列和优先级有关(动态)\n>\n> ![1539084361286](/img/1539084361286.png)\n\n#### 1二叉堆\n\n![1539085506624](/img/1539085506624.png)\n\n### 1.1用数组储存二叉堆\n\n![1539085717026](/img/1539085717026.png)![1539085824560](/img/1539085824560.png)### 1.2定义一个基本的堆\n\n```c++\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <ctime>\n#include <cmath>\n#include <cassert>\nusing namespace std;\ntemplate <typename Item>\nclass Maxheap{\nprivate:\n    Item *data;\n    int count;\npublic:\n    Maxheap(int capacity){\n        data =new Item[capacity+1];\n        count=0;\n    }\n    ~Maxheap(){\n        delete[] data;\n    }\n    int size(){\n        return count;\n    }\n    bool isEmpty(){\n        return count == 0;\n    }\n};\n\nint main() {\n    Maxheap<int> maxheap = Maxheap<int>(100);\n    cout<<maxheap.size()<<endl;\n    return 0;\n}\n```\n\n### 1.3Shit Up的实现(向堆中插入元素)\n\n```c++\n//\n// Created by JIA on 2018/10/9.\n//\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <ctime>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\ntemplate<typename Item>\nclass Maxheap {\nprivate:\n    Item *data;\n    int count;\n\n    void shiftUp(int k) {\n        while (k > 1 && data[k / 2] < data[k]) {\n            swap(data[k / 2, data[k]]);\n\n            k /= 2;\n        }\n    }\n\npublic:\n    Maxheap(int capacity) {\n        data = new Item[capacity + 1];\n        count = 0;\n    }\n\n    ~Maxheap() {\n        delete[] data;\n    }\n\n    int size() {\n        return count;\n    }\n\n    bool isEmpty() {\n        return count == 0;\n    }\n\n    void insert(Item item) {\n        data[count + 1] = item;\n        count++;\n        shiftUp(count);\n    }\n};\n\nint main() {\n    Maxheap<int> maxheap = Maxheap<int>(100);\n    srand(time(NULL));\n    for (int i = 0; i < 15; i++) {\n        maxheap.insert(rand() % 100);\n    }\n    for (int i = 0; i < 15; i++) {\n        cout << maxheap.data[i] << \" \";\n    }\n    return 0;\n}\n```\n\n### 1.4ShiftDown和queryMax()的实现(取出堆中最大的元素)\n\n```c++\n//\n// Created by JIA on 2018/10/9.\n//\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <ctime>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\ntemplate<typename Item>\nclass Maxheap {\nprivate:\n    Item *data;\n    int count;\n\n    void shiftUp(int k) {\n        while (k > 1 && data[k / 2] < data[k]) {\n            swap(data[k / 2, data[k]]);\n\n            k /= 2;\n        }\n    }\n    void shiftDown(int k){\n//        while(data[k]>data[2*k]||data[k]>data[2*k+1])\n          while(2*k<=count){\n              int j=2*k;\n              if(j+1<count&&data[j]<data[j+1])\n                  j+=1;\n              if(data[k]>data[j])\n                  break;\n              swap(data[k],data[j]);\n              k=j;\n          }\n    }\n\n\npublic:\n    Maxheap(int capacity) {\n        data = new Item[capacity + 1];\n        count = 0;\n    }\n\n    ~Maxheap() {\n        delete[] data;\n    }\n\n    int size() {\n        return count;\n    }\n\n    bool isEmpty() {\n        return count == 0;\n    }\n\n    void insert(Item item) {\n        data[count + 1] = item;\n        count++;\n        shiftUp(count);\n    }\n    int queryMax(){\n\n        Item ret=data[1];\n        swap(ret ,data[count]);\n        count--;\n        shiftDown(1);\n        return ret;\n    }\n};\n\nint main() {\n    Maxheap<int> maxheap = Maxheap<int>(100);\n    srand(time(NULL));\n    for (int i = 0; i < 15; i++) {\n        maxheap.insert(rand() % 100);\n    }\n    for (int i = 0; i < 15; i++) {\n        cout << maxheap.data[i] << \" \";\n    }\n    return 0;\n}\n```\n\n## 3.堆排序\n\n> 借助大顶堆,每次将对顶元素取出;\n\n```c++\ntemplate <typename T>\nvoid HeapSort(T arr[],int n){\n    Maxheap<T> maxheap=new Maxheap<T>(n);\n    for (int i =n-1 ; i>=0  ; i--) {\n        arr[i]=maxheap.queryMax();\n    }\n}\n```\n\n### 1.5堆排序的优化\n\n> 直接将待排序的数组初始化成一个大顶堆堆\n\n```c++\nMaxheap(Item arr[],int n){\n        data=new Item[n+1];\n        capacity=n;\n        for (int i = 0; i <n ; i++) {\n            data[i+1]=arr[i];\n            count=n;\n            for(int i=count/2;i>=1;i--)\n                shiftDown(i);\n        }\n    }\n```\n\n### 1.6Heapify的算法复杂度\n\n![1539091417707](/img/1539091417707.png)## 2索引堆(Index Heap)\n\n> Heapify时只讲数组的索引堆化  \n>\n> 为什么使用索引堆:\n>\n>   Heapify的过程会进行频繁的交换,当元素足够复杂时,交换元素将会异常的耗费资源\n\n### 2.1 最大索引堆得代码实现\n\n```c++\nusing namespace std;\n\ntemplate<typename Item>\nclass IndexMaxheap {\nprivate:\n    int* indexes;\n    Item *data;\n    int count;\n    int cacacity;\n    void shiftUp(int k) {\n        while (k > 1 && data[indexes[k / 2]] < data[indexes[k]]) {\n            swap(indexes[k / 2], indexes[k]);\n\n            k /= 2;\n        }\n    }\n    void shiftDown(int k){\n//        while(data[k]>data[2*k]||data[k]>data[2*k+1])\n        while(2*k<=count){\n            int j=2*k;\n            if(j+1<count&&data[indexes[j]]<data[indexes[j+1]])\n                j+=1;\n            if(data[indexes[k]>data[indexes[j]])\n                break;\n            swap(indexes[k],indexes[j]);\n            k=j;\n        }\n    }\n\n\npublic:\n    IndexMaxheap(int capacity) {\n        data = new Item[capacity + 1];\n        this->indexes=new int[capacity];\n        count = 0;\n        this->cacacity=capacity;\n    }\n\n    ~IndexMaxheap() {\n        delete[] data;\n        delete[] indexes;\n    }\n\n    int size() {\n        return count;\n    }\n\n    bool isEmpty() {\n        return count == 0;\n    }\n\n    void insert(int i,Item item) {\n\n        data[i+1]=item;\n        indexes[count+1]=i;\n        count++;\n        shiftUp(count);\n    }\n    Item queryMax(){\n        Item ret=data[indexes[1]];\n        swap(indexes[1] ,indexes[count]);\n        count--;\n        shiftDown(1);\n        return ret;\n    }\n    int queryMaxIdex(){\n        int ret =indexes[1]-1;\n        swap(indexes[1] ,indexes[count]);\n        count--;\n        shiftDown(1);\n        return ret;\n    }\n    Item getItem(int i){\n        return data[i-1];\n    }\n    void change(int i,Item item){\n        i+=1;\n        data[i]=item;\n        for(int j=1;j<=count;j++){\n            if(indexes[j]==i){\n                shiftDown(indexes[j]);\n                shiftUp(indexes[j]);\n                return ;\n            }\n        }\n    }\n};\n```\n\n### 2.2 反向查找","tags":["算法"],"categories":["算法学习"]},{"title":"高级排序算法(n*logN)","url":"/2018/10/11/高级排序算法/","content":" **仰望星空,脚踏实地,暗无天日,登峰造极**<Excerpt in index | 首页摘要>\n学习算法思想,修炼编程内功!\n\n<!-- more -->\n<The rest of contents | 余下全文>\n# 高级排序算法(n*logN)\n## 1.归并排序(Merge Sort)\n\n> 将待排序的数组无数次分成两部分,最后将剩下的排序(减少了时间复杂度,增加了空间复杂度),归并的过程需要开辟新的数组 \n\n![1539061916200](/img/1539061916200.png)\n\n![1539062061025](/img/1539062061025.png)\n\n### 实现代码\n\n* 注释出代码为接近有序的代码进行优化:如果左面比右面小就不用归并操作\n\n```c++\n//将arr[l,mid]和[mid+1,r]进行归并\ntemplate<typename T>\nvoid __marge(T arr[], int l, int mid, int r) {\n    T aux[r - l + 1];\n    for (int i = l; i <= r; i++)\n        aux[i - l] = arr[i];\n\n    int i = l;\n    int j = mid + 1;\n    for (int k = l; k <= r; k++) {\n        if (i > mid) {\n            arr[k] = aux[j - l];\n            j++;\n        } else if (j > r) {\n            arr[k] = aux[i - l];\n            i++;\n        } else if (aux[i - l] < aux[j - l]) {\n            arr[k] = aux[i - l];\n            i++;\n        } else {\n            arr[k] = aux[j - l];\n            j++;\n        }\n    }\n}\n//对arr[l....r]的范围进行排序\ntemplate<typename T>\nvoid __mergeSort(T arr[], int l, int r) {\n    if (l >= r)\n        return;\n    int mid = (l + r) / 2;\n    __mergeSort(arr, l, mid);\n    __mergeSort(arr, mid+1, r);\n    //if (arr[mid] > arr[mid + 1])  //对接近有序的数组进行优化\n    __marge(arr, l, mid, r);\n\n}\ntemplate <typename T>\nvoid mergeSort(T arr[], int n) {\n    __mergeSort(arr, 0, n - 1);\n}\n\n```\n\n### 自底向上实现归并排序(不用进行递归操作)\n\n```c++\n#include <iostream>\n\nusing namespace std;\n\n//将arr[l,mid]和[mid+1,r]进行归并\ntemplate<typename T>\nvoid __marge(T arr[], int l, int mid, int r) {\n    T aux[r - l + 1];\n    for (int i = l; i <= r; i++)\n        aux[i - l] = arr[i];\n    int i = l;\n    int j = mid + 1;\n    for (int k = l; k <= r; k++) {\n        if (i > mid) {\n            arr[k] = aux[j - l];\n            j++;\n        } else if (j > r) {\n            arr[k] = aux[i - l];\n            i++;\n        } else if (aux[i - l] < aux[j - l]) {\n            arr[k] = aux[i - l];\n            i++;\n        } else {\n            arr[k] = aux[j - l];\n            j++;\n        }\n    }\n}\n\ntemplate<typename T>\nvoid mergerSortBU(T arr[], int n) {\n    for (int sz = 1; sz <= n; sz += sz) {\n        for (int i = 0; i + sz < n; i+= sz + sz) {\n            __marge(arr, i, i + sz - 1, min(i + sz + sz - 1, n - 1));\n        }\n    }\n}\n```\n\n## 2.快速排序(Quick Sort)\n\n> 最好理解,实现最容易的排序算法,但是如果数组接近有序时,性能将会异常的差\n>\n> 使用: swap(arr[l],arr[rand()%(h-l+1)+l]);  随机取一个数可以对代码进行优化\n\n```c++\n#include <iostream>\n\nusing namespace std;\n\nint __privo(int arr[], int l, int h) {\n    int p = arr[l];\n    while (l < h) {\n        swap(arr[l],arr[rand()%(h-l+1)+l]);   //对代码的优化\n        while (l < h && arr[h] >= p) --h;\n        swap(arr[l], arr[h]);\n        while (l < h && p > arr[l]) ++l;\n        swap(arr[l], arr[h]);\n    }\n\n    return l;\n}\n\nvoid quickSort(int arr[], int l, int h) {\n    if (l > h){\n        return;}\n    int p = __privo(arr, l, h);\n    quickSort(arr, l, p - 1);\n    quickSort(arr, p + 1, h);\n\n}\n\nint main() {\n    cout << \"abc\" << endl;\n    int a[] = {3,1,2,4,7,8,23,6,0};\n    quickSort(a, 0, 8);\n    for (int i = 0; i < 9; i++) {\n        cout << a[i] << \" \";\n    }\n    cout << endl;\n    cout<<\"))))\";\n    return 0;\n}\n\n\n```\n\n","tags":["算法"],"categories":["算法学习"]},{"title":"基础排序算法","url":"/2018/10/10/基础的排序算法/","content":" **仰望星空,脚踏实地,暗无天日,登峰造极**<Excerpt in index | 首页摘要>\n学习算法思想,修炼编程内功!\n\n<!-- more -->\n<The rest of contents | 余下全文>\n# 基础排序算法\n\n## 1选择排序(Selection Sort)\n\n### 基本思想\n\n> 基本思想,从0开始每一次找第n小的元素与当前第n位置的元素交换.时间复杂度O(n2) ,无论怎样的数组必须都将两层循环跑完.\n\n![1539000224817](/img/1539000224817.png)\n\n### 实现代码\n```c++\n#include<iostream>\nusing namespace std;\nvoid selectionSort( int arr[],int n){\n    for(int i=0; i<n; i++){\n        //寻找[i,n)区间最小值\n        int minIndex=i;\n        for(int j=i+1; j<n; j++){\n            if(arr[minIndex]>arr[j]){\n                minIndex=j;\n            }\n            swap(arr[minIndex],arr[i]);\n        }\n    }\n}\nint main(){\n    int a[]={1,2,3,5,4,6,8,7,9,10};\n    selectionSort(a,10);\n    for(int i=0;i<10;i++){\n        cout<<a[i]<<\" \";\n    }\n    cout<<endl;\n    return 0;\n}\n\n```\n\n### 使用c++模板进行扩展\n\n```c++\n#include<iostream>\n#include \"Student.h\"\nusing namespace std;\n//c++模板,或者泛型\ntemplate<typename T>\nvoid selectionSort( T arr[],int n){\n    for(int i=0; i<n; i++){\n        //寻找[i,n)区间最小值\n        int minIndex=i;\n        for(int j=i+1; j<n; j++){\n            if(arr[j]<arr[minIndex]){\n                minIndex=j;\n            }\n            swap(arr[minIndex],arr[i]);\n        }\n    }\n}\nint main(){\n    int a[]={1,2,3,5,4,6,8,7,9,10};\n    selectionSort(a,10);\n    for(int i=0;i<10;i++){\n        cout<<a[i]<<\" \";\n    }\n    cout<<endl;\n    float b[]={1.2,2.4,5,6,2.2};\n    selectionSort(b,5);\n    for(int i=0;i<5;i++){\n        cout<<b[i]<<\"  \";\n    }\n     cout<<endl;\n     string c[]={\"d\",\"b\",\"c\",\"a\",\"f\"};\n     for(int i=0;i<5;i++){\n        cout<<c[i]<<\"  \";\n     }\n      cout<<endl;\n      Student d[3]={{\"A\",90},{\"B\",80},{\"C\",85}};\n      selectionSort(d,3);\n      for(int i=0;i<3;i++){\n        cout<<d[i]<<\" \";\n      }\n      cout<<endl;\n    return 0;\n}\n\n```\n\n---\n\n```c++\n#ifndef STUDENT_H_INCLUDED\n#define STUDENT_H_INCLUDED\n\n\n#include<iostream>\n#include<string>\nusing namespace std;\nstruct Student{\n    string name;\n    int score;\n    bool operator<(const Student &otherStudent){\n        return score < otherStudent.score;\n    }\n    friend ostream& operator<<(ostream &os ,const Student &student){\n        os<<\"Student: \"<<student.name<<\" \"<<student.score<<endl;\n        return os;\n    }\n};\n\n\n#endif // STUDENT_H_INCLUDED\n\n```\n\n## 2.插入排序(Insertion Sort)\n\n> 再循环中每次将元素与前面位置元素比较,如果小就交换位置.时间复杂度O(n2).插入排序对接近有序的数组排序性能将会更好\n\n![1539003860047](/img/1539003860047.png)\n\n### 实现代码:\n\n```c++\n#include <iostream>\nusing namespace std;\ntemplate <typename T>\nvoid insertionSort(T arr [],int n){\n\n    for(int i=1;i<n;i++){\n        for(int j=i+1;j>0&&arr[j]<arr[j-1];j--){\n            swap(arr[j],arr[j-1]);\n        }\n    }\n\n}\n\n```\n\n---\n\n### 优化代码:\n\n> 每次循环标记元素的值,将每一次交换改成赋值操作,\n\n```c++\n#include <iostream>\n\nusing namespace std;\ntemplate <typename T>\nvoid insertionSortOpt(T arr[], int n) {\n    for (int i = 1; i < n; i++) {\n        T e = arr[i];\n        int j;\n        for ( j = i; j > 0 && arr[j - 1] > e; j--) {\n            arr[j] = arr[j - 1];\n        }\n        arr[j] = e;\n    }\n}\n\n```\n\n","tags":["算法"],"categories":["算法学习"]},{"title":"SpringCloud微服务学习总结","url":"/2018/10/04/SpringCloud微服务学习总结/","content":"\n** 骗的了别人骗不了自己,做什么都要用心!** <Excerpt in index | 首页摘要>\n对SpringCloud学习做一个总结,供以后应用查看\n<!-- more -->\n<The rest of contents | 余下全文>\n\n微服务的特点:\n\n> * 一系列微小的服务共同组成\n> * 单独部署,跑在自己的进程里\n> * 每个服务为独立的业务开发\n> * 分布式的管理\n\n传统vs微服务\n\n![1538629111529](/img/1538629111529.png)\n\n> 业务形态上不适合微服务的场景\n>\n> * 系统中包含很多很多强事务的场景\n> * 业务相对稳定,迭代周期长\n> * 访问压力不大,可用性要求不高\n> * ...\n\n![1538628687788](/img/1538628687788.png)\n\n![1538628921984](/img/1538628921984.png)\n\n## 1.Eureka服务注册中心\n\n### 1.1构建项目\n\n> 选择eureka Server\n\n![1538625976475](/img/1538625976475.png) \n\n### 1.2 启动类上添加```@EnableEurekaServer```注解\n\n```java\n\npackage com.jia.eureka;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;\n\n@SpringBootApplication\n@EnableEurekaServer\npublic class EurekaApplication {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(EurekaApplication.class, args);\n\t}\n}\n```\n\n### 1.3 application.yml配置\n\n>* register-with-eureka: false       是否注册到服务注册中心,因为自己就是服务注册注册中心,所以false\n>* enable-self-preservation: false      关闭心跳检测保留链接(开发环境为了查看服务状态)\n\n```java\n\neureka:\n  client:\n    service-url:\n      defaultZone: http://localhost:8761/eureka/\n    register-with-eureka: false\n  server:\n    enable-self-preservation: false\nspring:\n  application:\n    name: eureka\nserver:\n  port: 8761\n```\n\n### 1.4启动效果\n\n![1538626591475](/img/1538626591475.png)### 1.5小结\n\n> eureka服务注册中心在生产环境中可以做到高可用,启动多个eureka服务注册中心,彼此相互注册,每个客户端服务再分别注册到这些eureka服务注册中心.即使一个eureka垮掉,整个微服务也可以正常运行.\n>\n> ![1538628284808](/img/1538628284808.png)\n\n## 2.Eureka客户端的使用\n\n### 2.1构建项目\n\n> 选择Eureka Discovery\n\n![1538627464924](/img/1538627464924.png)2.2 启动类上添加@EnableDiscoveryClient注解\n\n```java\npackage com.jia.client;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.cloud.client.discovery.EnableDiscoveryClient;\n\n@SpringBootApplication\n@EnableDiscoveryClient\npublic class ClientApplication {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(ClientApplication.class, args);\n\t}\n}\n\n```\n\n### 2.3 application.yml的配置\n\n>*  instance:\n>\n>  ​        hostname: clientName     客户端服务跳转的名字\n\n```java\neureka:\n  client:\n    service-url:\n      defaultZone: http://localhost:8761/eureka/\n#  instance:\n#    hostname: clientName\nspring:\n  application:\n    name: client\nserver:\n  port: 10001\n```\n\n### 2.4 启动效果\n\n![1538628237602](/img/1538628237602.png)\n\n### 2.5小结\n\n> * @EnableEurekaServer @EnabeEurekaClient\n> * 心跳检测,健康检查,负载均衡等功能\n> * Eureka的高可用,生产上建议使用两台\n> * 分布式系统中,服务注册中心是重要的基础部分\n\n## 3.统一配置中心config\n\n### 3.1.为什么需要统一配置中心\n\n* 不方便维护\n* 配置内容安全与权限\n* 更新配置项目启动\n\n### 3.2.统一配置中心总体架构\n\n![1538630591518](/img/1538630591518.png)\n\n### 3.3.统一配置中心的Server端\n\n> * 项目构建 \n>\n> ![1538630687494](/img/1538630755571.png)\n>\n> * 启动类上添加注解@EnableConfigServer\n>\n>   ```java\n>   package com.jia.config;\n>   \n>   import org.springframework.boot.SpringApplication;\n>   import org.springframework.boot.autoconfigure.SpringBootApplication;\n>   import org.springframework.cloud.client.discovery.EnableDiscoveryClient;\n>   import org.springframework.cloud.config.server.EnableConfigServer;\n>   \n>   @SpringBootApplication\n>   @EnableDiscoveryClient\n>   @EnableConfigServer\n>   public class ConfigApplication {\n>   \n>   \tpublic static void main(String[] args) {\n>   \t\tSpringApplication.run(ConfigApplication.class, args);\n>   \t}\n>   }\n>   ```\n>\n>   * gitee上创建一个仓库用来存放配置文件\n>\n>   * > gitee地址:https://gitee.com/shltj/config-repo\n>\n>     ![1538631315904](/img/1538631315904.png)\n>\n>     * application.yml的配置\n>\n>       ```java\n>       spring:\n>         application:\n>           name: config\n>         cloud:\n>           config:\n>             server:\n>               git:\n>                 uri: https://gitee.com/shltj/config-repo\n>                 username: shltj\n>                 password: xxxxxxxx\n>                 basedir: e:/config\n>       eureka:\n>         client:\n>           service-url:\n>             defaultZone: http://localhost:8761/eureka/\n>       ```\n>\n>       * 启动效果\n>\n>         ![1538633264680](/img/1538633264680.png)\n\n### 3.4统一配置中心Client端\n\n> * 添加依赖\n>   \n>   ```java\n>   \t<dependency>\n>   \t\t\t<groupId>org.springframework.cloud</groupId>\n>   \t\t\t<artifactId>spring-cloud-config-client</artifactId>\n>   \t</dependency>\n>   ```\n>\n>   * gitee上新建client-dev.yml\n>\n>   ```java\n>   eureka:\n>     client:\n>       service-url:\n>         defaultZone: http://localhost:8761/eureka/\n>   #  instance:\n>   #    hostname: clientName\n>   spring:\n>     application:\n>       name: client\n>   server:\n>     port: 10001\n>   ```\n>\n>   * 将applicatiion.yml 修改为bootstrap.yml springboot默认先加载applicatiion.yml \n>\n>     ```java\n>     spring:\n>       cloud:\n>         config:\n>           discovery:\n>             enabled: true\n>             service-id: config\n>           profile: dev\n>       application:\n>         name: client\n>     ```\n>\n\n  ## 4.SpringCloud Bus 自动刷新配置\n\n### 4.1自动刷新配置原理\n\n![1538635206179](/img/1538635206179.png)### 4.2在config服务端添加amqp的依赖\n\n```java\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.cloud</groupId>\n\t\t\t<artifactId>spring-cloud-starter-bus-amqp</artifactId>\n\t\t</dependency>\n```\n\n### 4.3  在application.yml 中添加rabbitmq的配置并且暴露访问端口(后期可由git服务器的webhook 访问)\n\n```java\n  rabbitmq:\n    port: 5672\n    host: 101.200.44.222\n    username: tong\n    password: tong\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: \"*\"    \n```\n\n### 4.4在client服务端添加rabbitmap的依赖\n\n```java\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-bus-amqp</artifactId>\n        </dependency>\n```\n\n### 4.5注意将springboot和springcloud的版本改成BUILD-SNAPSHOT,M3存在bug.\n\n> **别忘记需要在更新配置的地方添加@RefreshScope注解**\n\n> 访问http://localhost:8080/actuator/bus-refresh(用post请求方式)可以实现动态更新配置,github上的webhook已经支持访问改接口\n\n## 5.mq的使用\n\n### 5.1 mq的应用场景\n\n> * 异步处理\n> * 流量削峰\n> * 日志处理\n> * 应用解耦\n\n## 6.服务网关Zuul\n\n### 6.1服务网关所应具备的要素\n\n> * 稳定性,高可用(7*25小时服务)\n> * 性能,并发性\n> * 安全性\n> * 扩展性\n\n### 6.2常见的服务网关\n\n![1538648760855](/img/1538648760855.png)### 6.3Zuul的特点\n\n> * 路由+过滤器=zuul\n>\n> * 核心是一些列的过滤器\n>\n>   ![1538648953468](/img/1538648953468.png)![1538649013623](/img/1538649013623.png)\n\n### 6.4Zuul的使用\n\n> * 项目的构建\n>\n>   ![1538649205460](/img/1538649205460.png)*  再启动类上添加@EnableZuulProxy注解\n>\n>   ```java\n>   package com.jia.apigetway;\n>   \n>   import org.springframework.boot.SpringApplication;\n>   import org.springframework.boot.autoconfigure.SpringBootApplication;\n>   import org.springframework.cloud.client.discovery.EnableDiscoveryClient;\n>   import org.springframework.cloud.netflix.zuul.EnableZuulProxy;\n>   \n>   @SpringBootApplication \n>   @EnableDiscoveryClient\n>   @EnableZuulProxy\n>   public class ApiGetwayApplication {\n>   \n>   \tpublic static void main(String[] args) {\n>   \t\tSpringApplication.run(ApiGetwayApplication.class, args);\n>   \t}\n>   }\n>   \n>   ```\n>\n>   * 经过服务网关和直接访问服务写法对比(网关+服务+方法)\n>\n>\n>\n>     > ![1538650336849](/img/1538650336849.png)\n>     >\n>     > ![1538650399065](/img/1538650399065.png)\n\n>* 自定义路由bootstrap.yml添加配置\n>\n>  ```java\n>  management:\n>    security:\n>      enabled: false\n>  zuul:\n>    routes:\n>      aaaaa:\n>        path: /myclient/**\n>        serviceId: client\n>  ```\n>\n>  ---\n>\n>  简介写法:\n>\n>  ![1538650911129](/img/1538650911129.png)\n\n> * 排除某些路由的写法:\n>\n>   ![1538651042319](/img/1538651042319.png)* Zuul默认服务间不能传递cookie,传递cookId配置方法\n>\n>   ![1538651174961](/img/1538651174961.png)\n\n### 6.5Zuul典型的使用场景\n\n* 前置过滤器: 限流,鉴权,参数校验调整\n* 后置过滤器:统计,日志\n\n### 6.6Zuul的权限校验 \n\n> 规定请求的参数必须带Token.如果Token为空,校验不通过,实现代码如下:\n>\n> > 注意: shouldFilter方法返回值设置为true\n> >\n> > ​         filterType()方法中配置参数类型\n> >\n> > ​          filterOrder()方法中配置拦截器的优先级\n\n```java\npackage com.jia.apigetway.filter;\n\nimport com.netflix.zuul.ZuulFilter;\nimport com.netflix.zuul.context.RequestContext;\nimport org.apache.http.HttpStatus;\nimport org.springframework.stereotype.Component;\nimport org.springframework.util.StringUtils;\n\nimport javax.servlet.http.HttpServletRequest;\n\nimport static org.springframework.cloud.netflix.zuul.filters.support.FilterConstants.PRE_DECORATION_FILTER_ORDER;\nimport static org.springframework.cloud.netflix.zuul.filters.support.FilterConstants.PROXY_KEY;\n\n@Component\npublic class Tocken extends ZuulFilter {\n    @Override\n    public String filterType() {\n        return PROXY_KEY;\n    }\n\n    @Override\n    public int filterOrder() {\n        return PRE_DECORATION_FILTER_ORDER-1;\n    }\n\n    @Override\n    public boolean shouldFilter() {\n        return true;\n    }\n\n    @Override\n    public Object run() {\n        RequestContext requestContext = RequestContext.getCurrentContext();\n        HttpServletRequest request=requestContext.getRequest();\n        String token=request.getParameter(\"token\");\n        if(StringUtils.isEmpty(token)){\n            requestContext.setSendZuulResponse(false);\n            requestContext.setResponseStatusCode(HttpStatus.SC_UNAUTHORIZED);\n        }\n\n        return null;\n    }\n}\n\n```\n\n### 6.7Zuul的限流\n\n> Zuul使用的是Google开发的令牌桶限流,具体如下图:\n>\n> ![1538652781643](/img/1538652781643.png)\n\n> 代码如下\n>\n> ```java\n> package com.jia.apigetway.filter;\n> \n> import com.google.common.util.concurrent.RateLimiter;\n> import com.netflix.zuul.ZuulFilter;\n> import org.springframework.stereotype.Component;\n> \n> import static org.springframework.cloud.netflix.zuul.filters.support.FilterConstants.PRE_TYPE;\n> import static org.springframework.cloud.netflix.zuul.filters.support.FilterConstants.SERVLET_DETECTION_FILTER_ORDER;\n> \n> @Component\n> public class RateLimiterFilter extends ZuulFilter {\n>     //每秒钟放100令牌\n>     private static final RateLimiter RATE_LIMITER=RateLimiter.create(100);\n> \n>     @Override\n>     public String filterType() {\n>         return PRE_TYPE;\n>     }\n> \n>     @Override\n>     public int filterOrder() {\n>         return SERVLET_DETECTION_FILTER_ORDER-1;\n>     }\n> \n>     @Override\n>     public boolean shouldFilter() {\n>         return true;\n>     }\n> \n>     @Override\n>     public Object run() {\n>         if(!RATE_LIMITER.tryAcquire()){\n>            throw new RuntimeException();   //通过令牌桶限流,如果拿不到令牌就抛出一个异常,感觉好像有bug\n>         }\n>         return null;\n>     }\n> }\n> \n> ```\n\n### 6.8Zuul的权限校验\n\n> 通过Zuul的拦截器实现如下鉴权功能\n>\n> ![1538654024968](/img/1538654024968.png)\n>\n> 在拦截器中具体代码实现如下:\n>\n> ![1538654539209](/img/1538654539209.png)\n\n### 6.8Zuul的跨域解决方法\n\n> 基本解决跨域\n\n```java\npackage com.jia.apigetway;\n\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.cors.CorsConfiguration;\nimport org.springframework.web.cors.UrlBasedCorsConfigurationSource;\nimport org.springframework.web.filter.CorsFilter;\n\nimport java.util.Arrays;\n\n/**\n * 跨域配置\n * C-Cross O-Origin  R-Resource S-Sharing\n */\n@Configuration\npublic class CorsConfig  {\n    public CorsFilter corsFilter(){\n        final UrlBasedCorsConfigurationSource source=new UrlBasedCorsConfigurationSource();\n        final CorsConfiguration config=new CorsConfiguration();\n        config.setAllowCredentials(true);\n        config.setAllowedOrigins(Arrays.asList(\"*\")); //http://www.a.com\n        config.setAllowedHeaders(Arrays.asList(\"*\"));\n        config.setAllowedMethods(Arrays.asList(\"*\"));\n        config.setMaxAge(300l);\n        source.registerCorsConfiguration(\"/**\",config);\n        return  new CorsFilter(source)\n    }\n}\n\n```\n\n> 通用跨域解决方案\n>\n> ![1538655791286](/img/1538655791286.png)\n\n## 7.服务容错Hystrix\n\n> 同步等待会造成资源耗尽\n\n### 7,1Hystrix的功能\n\n> * 服务降级\n> * 依赖隔离\n> * 服务熔断\n> * 监控(Hystrix Dashboard)\n\n### 7.2服务降级\n\n> 优先核心服务,非核心服务不可用或若可用\n>\n> 通过HystrixCommand注解指定\n>\n> fallbackMethod(回退函数)中具体实现降级逻辑\n\n### 7,3Hystrix的使用\n\n> 在client服务去访问client2服务的getMessage方法\n>\n> * 在client服务端添加Hystrix依赖\n>\n>   ```java\n>   \t\t<dependency>\n>   \t\t\t<groupId>org.springframework.cloud</groupId>\n>   \t\t\t<artifactId>spring-cloud-starter-hystrix</artifactId>\n>   \t\t</dependency>\n>   ```\n>\n>   * 启动类上添加@EnableCircuitBreaker注解\n>\n>     ```java\n>     package com.jia.client;\n>     \n>     import org.springframework.boot.SpringApplication;\n>     import org.springframework.boot.autoconfigure.SpringBootApplication;\n>     import org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker;\n>     import org.springframework.cloud.client.discovery.EnableDiscoveryClient;\n>     import org.springframework.cloud.netflix.hystrix.EnableHystrix;\n>     \n>     @SpringBootApplication\n>     @EnableDiscoveryClient\n>     @EnableCircuitBreaker\n>     public class ClientApplication {\n>     \n>     \tpublic static void main(String[] args) {\n>     \t\tSpringApplication.run(ClientApplication.class, args);\n>     \t}\n>     }\n>     ```\n>\n>     * 定义HystrixController实验服务降级\n>\n>       >在方法上添加  @HystrixCommand(fallbackMethod = \"fallback\")注解当方法出现异常或者超时会自动调用fallback();\n>       >\n>       >如果想所有的方法都实现服务降级,可以在Controller上添加@DefaultProperties(defaultFallback=\"xxxxx\") xxxxx为自定义服务降级走的方法\n>\n>       ```java\n>       package com.jia.client.controller;\n>       \n>       import com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;\n>       import org.springframework.web.bind.annotation.GetMapping;\n>       import org.springframework.web.bind.annotation.RestController;\n>       import org.springframework.web.client.RestTemplate;\n>       \n>       @RestController\n>       public class HystrixController {\n>       \n>            RestTemplate restTemplate=new RestTemplate();\n>       \n>            @GetMapping(\"/get\")\n>            @HystrixCommand(fallbackMethod = \"fallback\")\n>            public String getMsg(){\n>                String msg=restTemplate.getForObject(\"http://localhost:10005/getMessage\",String.class);\n>                try {\n>                    Thread.sleep(2000);\n>                } catch (InterruptedException e) {\n>                    e.printStackTrace();\n>                }\n>                return \"from client2 message\"+msg;\n>            }\n>            private  String fallback(){\n>                return \"人太多,挤爆了\";\n>            }\n>       \n>       }\n>       \n>       ```\n\n### 7,4Hystrix服务的熔断\n\n> 断路器实现服务熔断:\n>\n> ![1538702279205](/img/1538702279205.png)\n>\n>    访问getMessage方法,当参数为奇数是抛异常,当异常达到一定次数是(60%)启动断路开关\n\n```java\npackage com.imooc.client3.controller;\n\nimport com.netflix.hystrix.contrib.javanica.annotation.DefaultProperties;\nimport com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;\nimport com.netflix.hystrix.contrib.javanica.annotation.HystrixProperty;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.RestController;\nimport org.springframework.web.client.RestTemplate;\n\n@RestController\n@DefaultProperties(defaultFallback = \"defaultFallback\")\npublic class HystrixController {\n    private RestTemplate restTemplate = new RestTemplate();\n//    服务的超时配置\n\n//    @HystrixCommand(fallbackMethod = \"fallback\",commandProperties ={\n//            @HystrixProperty(name = \"execution.isolation.thread.timeoutInMilliseconds\",value=\"3500\")\n//    } )\n    @HystrixCommand(commandProperties = {\n            @HystrixProperty(name=\"circuitBreaker.enabled\",value = \"true\"),   //设置熔断\n            @HystrixProperty(name=\"circuitBreaker.requestVolumeThreshold\",value = \"10\"),\n            @HystrixProperty(name=\"circuitBreaker.sleepWindowInMilliseconds\",value = \"10000\"),\n            @HystrixProperty(name=\"circuitBreaker.errorThresholdPercentage\",value = \"60\")\n    })\n    @GetMapping(\"/messageT\")\n    public String getMessage(@RequestParam(\"number\") Integer number ) {\n        String result=null;\n        if(number%2==0){\n             result = this.restTemplate.getForObject(\"http://localhost:10006/tong\",String.class);\n\n        }else{\n            int a=1/0;\n             result=\"1111\";\n        }\n\n        System.out.println(result);\n        return result;\n    }\n\n    private String fallback() {\n        return \"出故障了!!!\";\n    }\n\n    @HystrixCommand\n    @GetMapping(\"/messageT1\")\n    public String getMessage1() throws RuntimeException {\n        String result = this.restTemplate.getForObject(\"http://localhost:10006/tong\", String.class);\n\n        System.out.println(result);\n        int a = 1 / 0;\n        return result;\n\n\n    }\n\n    private String defaultFallback() {\n        return \"默认方法出故障了!!!!!\";\n    }\n\n}\n\n```\n\n### 7.5feign和Hystrix的使用\n\n> feign的使用(内置ribbon):\n>\n> * 添加依赖\n>\n>   ```java\n>   <dependency>\n>       <groupId>org.springframework.cloud</groupId>\n>       <artifactId>spring-cloud-starter-openfeign</artifactId>\n>   </dependency>\n>   ```\n>\n> * 启动类上添加注解@EnableFeignClients\n>\n>   ```java\n>   package com.jia.client;\n>   \n>   import org.springframework.boot.SpringApplication;\n>   import org.springframework.boot.autoconfigure.SpringBootApplication;\n>   import org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker;\n>   import org.springframework.cloud.client.discovery.EnableDiscoveryClient;\n>   import org.springframework.cloud.openfeign.EnableFeignClients;\n>   \n>   @SpringBootApplication\n>   @EnableDiscoveryClient\n>   @EnableCircuitBreaker\n>   @EnableFeignClients\n>   public class ClientApplication {\n>   \n>   \tpublic static void main(String[] args) {\n>   \t\tSpringApplication.run(ClientApplication.class, args);\n>   \t}\n>   }\n>   ```\n>\n>   * 访问远程服务的方法\n>\n>     ```java\n>     package com.jia.client.controller;\n>     \n>     \n>     import org.springframework.cloud.openfeign.FeignClient;\n>     import org.springframework.web.bind.annotation.PostMapping;\n>     \n>     @FeignClient(\"client2\")\n>     public interface Client2Feign {\n>         @PostMapping(\"/client2/getMessage\")\n>         String get();\n>     }\n>     \n>     ```\n>\n>     ----\n>\n>     feign和Hystrix结合使用:\n>\n>     > bootstrap.yml中添加配置\n>     >\n>     > ```java\n>     > feign:\n>     >   hystrix:\n>     >     enable: true\n>     > ```\n>     >\n>     >\n>\n>     > 如果发生异常执行class中的方法\n>\n>     ```java\n>     package com.jia.client.controller;\n>     \n>     \n>     import org.springframework.cloud.openfeign.FeignClient;\n>     import org.springframework.stereotype.Component;\n>     import org.springframework.web.bind.annotation.PostMapping;\n>     \n>     @FeignClient(value = \"client2\",fallback = Client2Feign.Client2Fallback.class)\n>     public interface Client2Feign {\n>         @PostMapping(\"/client2/getMessage\")\n>         String get();\n>         @Component\n>         class Client2Fallback implements Client2Feign{\n>             @Override\n>             public String get() {\n>                 return null;\n>             }\n>         }\n>     }\n>     \n>     ```\n\n### 7.6Hystrix-dashboard可视化组件的使用\n\n> * 添加依赖\n>\n>   ```java\n>        <dependency>\n>           <groupId>org.springframework.cloud</groupId>\n>           <artifactId>spring-cloud-starter-hystrix-dashboard</artifactId>\n>        </dependency>\n>        <dependency>\n>            <groupId>org.springframework.boot</groupId>\n>            <artifactId>spring-boot-starter-actuator</artifactId>\n>         </dependency>\n>   ```\n>\n>   * 启动类上添加注解@EnableHystrixDashboard\n>\n>     ```java\n>     package com.jia.client;\n>     \n>     import org.springframework.boot.SpringApplication;\n>     import org.springframework.boot.autoconfigure.SpringBootApplication;\n>     import org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker;\n>     import org.springframework.cloud.client.discovery.EnableDiscoveryClient;\n>     import org.springframework.cloud.netflix.hystrix.dashboard.EnableHystrixDashboard;\n>     import org.springframework.cloud.openfeign.EnableFeignClients;\n>     \n>     @SpringBootApplication\n>     @EnableDiscoveryClient\n>     @EnableCircuitBreaker\n>     @EnableFeignClients\n>     @EnableHystrixDashboard\n>     public class ClientApplication {\n>     \n>     \tpublic static void main(String[] args) {\n>     \t\tSpringApplication.run(ClientApplication.class, args);\n>     \t}\n>     }\n>     \n>     ```\n>\n>     * 访问/hystrix路径\n>\n>       ![1538707724714](/img/1538707724714.png)* client服务端添加如下配置:\n>\n>       ```java\n>       management:\n>         context-path: /\n>       ```\n>\n>       * 监控视图\n>\n>         ![1538708343150](/img/1538708343150.png)\n\n## 8.服务的追踪(链路监控Sleuth)\n\n> * 添加依赖\n>\n>   ```java\n>   \t\t<dependency>\n>   \t\t\t<groupId>org.springframework.cloud</groupId>\n>   \t\t\t<artifactId>spring-cloud-starter-sleuth</artifactId>\n>   \t\t</dependency>\n>   ```\n>\n>  * 使用**OpenZIPkin**查看服务的追踪\n>\n>     > * 用docker安装软件\n>     >\n>     >   docker pull openzipkin/zipkin\n>     >\n>     >   docker run -d -p 9411:9411 zipkin\n>     >\n>     >   浏览器访问:http://101.200.44.222:9411/zipkin/\n>     >\n>     >   ![1538710627440](/img/1538710627440.png)\n>\n>  * client服务添加相应依赖\n>\n>     ```java\n>     <dependency>\n>        <groupId>org.springframework.cloud</groupId>\n>        <artifactId>spring-cloud-sleuth-zipkin</artifactId>\n>     </dependency>\n>     ```\n>\n>   * bootstrap.yml中添加配置\n>\n>       ```java\n>       zipkin:\n>         base-url: http://101.200.44.222:9411\n>       ```\n>\n>           * 设置抽样观察百分比为1\n>\n>         ```java\n>         sleuth:\n>           sampler:\n>             percentage: 1f\n>         ```\n>\n> * 展示效果\n>\n>      ![1538711526837](/img/1538711526837.png)\n>\n\n##  9.分布式追踪系统\n\n### 9.1核心步骤(OpenTracing规范)\n\n![1538711826394](/img/1538711826394.png)\n\n> * 数据采集\n> * 数据存储\n> * 查询展示\n\n## 10.使用docker部署项目\n\n### 10.1docker部署eureka服务注册中心\n\n> * Docerfile文件内容\n>\n> ```dockerfile\n> FROM hub.c.163.com/library/java:8-alpine\n> ADD app.jar  app.jar\n> EXPOSE 8761\n> ENTRYPOINT [\"java\",\"-jar\",\"/app.jar\"]\n> ```\n>\n> * 构建命令:docker build -t springcloud2/eureka .\n>\n> * 运行命令:docker run -d -p 8761:8761 springcloud2/eureka\n>\n> * 网易云上传镜像:https://www.163yun.com/help/documents/15587826830438400\n>\n> * 访问成功:\n>\n>   ![1538714796176](/img/1538714796176.png)\n\n### 10.2 rancher的使用\n\n> Rancher是一个开源的企业级全栈化容器部署管理平台(为了更方便的管理docker)\n>\n> > 安装rancher命令:sudo docker run -d --restart=unless-stopped -p 8080:8080 rancher/server:stable\n>\n> ![1538717959699](/img/1538717959699.png)\n>\n>* 需添加一台主机\n","tags":["java"],"categories":["开源框架"]},{"title":"自定义注解+反射实现orm框架的映射与查询功能","url":"/2018/10/04/自定义注解+反射实现orm框架的映射与查询功能/","content":"\n**积极一点,耐心一点,你想要的,时光都会慢慢带到你面前!**<Excerpt in index | 首页摘要>\n对注解和反射的加深学习,对ORM框架的加深理解 \n<!-- more -->\n<The rest of contents | 余下全文>\n\n> **自定义orm框架例如:Mybatis,hibernate的@Table,@Column注解,通过反射解析注解实现对应表的查询功能,对注解加深学习,对orm框架的思想进行理解.**\n*将定义的注解进行解析取出数据库表的名字,表对应字段的名字,以及字段对应的value进行sql的拼装,最后通过jdbc进行查询.* \n具体代码如下:\n\n## 数据表\n\n```java\n@Table(\"user\")\npublic class Filter {\n    @Column(\"id\")\n    private int id;\n    @Column(\"userName\")\n    private String userName;\n    @Column(\"nickName\")\n    private  String nickName;\n    @Column(\"age\")\n    private int age;\n    @Column(\"city\")\n    private String city;\n    @Column(\"email\")\n    private String email;\n    @Column(\"mobile\")\n    private String mobile;\n    public int getId() {\n        return id;\n    }\n\n    public void setId(int id) {\n        this.id = id;\n    }\n\n    public String getUserName() {\n        return userName;\n    }\n\n    public void setUserName(String userName) {\n        this.userName = userName;\n    }\n\n    public String getNickName() {\n        return nickName;\n    }\n\n    public void setNickName(String nickName) {\n        this.nickName = nickName;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public String getCity() {\n        return city;\n    }\n\n    public void setCity(String city) {\n        this.city = city;\n    }\n\n    public String getEmail() {\n        return email;\n    }\n\n    public void setEmail(String email) {\n        this.email = email;\n    }\n\n    public String getMobile() {\n        return mobile;\n    }\n\n    public void setMobile(String mobile) {\n        this.mobile = mobile;\n    }\n}\n\n```\n\n\n\n## 自定义注解\n\n```java\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Table {\n    String value();\n}\n\n```\n\n------\n\n```java\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Target(ElementType.FIELD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Column {\n    String value();\n}\n\n```\n\n## 对注解的解析和测试类\n\n```java\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\n\npublic class Test {\n    public static void main(String[] args) {\n        Filter f1 = new Filter();\n        f1.setAge(10);\n        Filter f2 = new Filter();\n        f2.setNickName(\"congcong\");\n        Filter f3 = new Filter();\n        f3.setEmail(\"111@qq.com,222@163.com,333@outlook.com\");\n        String sql1 = query(f1);\n        String sql2 = query(f2);\n        String sql3 = query(f3);\n        System.out.println(sql1);\n        System.out.println(sql2);\n        System.out.println(sql3);\n    }\n    public static String query(Filter filter) {\n        StringBuilder sb = new StringBuilder();\n        //1.获取Class\n        Class clazz = filter.getClass();\n        //2.获取Table注解\n        if (!clazz.isAnnotationPresent(Table.class)) {\n            return null;\n        }\n        Table table = (Table) clazz.getAnnotation(Table.class);\n        String tableName = table.value();\n        sb.append(\"select * from \").append(tableName).append(\" where 1=1 \");\n        //3.获取表中的字段\n        Field[] fields = clazz.getDeclaredFields();\n        for (Field f : fields) {\n            //4.处理每个字段对应的SQL\n            if (!f.isAnnotationPresent(Column.class)) {\n                continue;\n            }\n            //4.1获取字段上的注解\n            Column column = f.getAnnotation(Column.class);\n            String columnName = column.value();\n            //4.2获取字段的值\n            String fieldName = f.getName();\n            //4.3获取字段的get方法\n            String getMethodName = \"get\" + fieldName.substring(0, 1).toUpperCase()\n                    + fieldName.substring(1);\n            Object fieldValue = null;\n            try {\n                Method getMethod = clazz.getDeclaredMethod(getMethodName);\n                fieldValue = getMethod.invoke(filter);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            //4.4拼装SQL\n            if (fieldValue == null || (fieldValue instanceof Integer && (Integer) fieldValue == 0)) {\n                continue;\n            }\n            if (fieldValue instanceof String) {\n                sb.append(\"and \").append(columnName).append(\"=\");\n                if (((String) fieldValue).contains(\",\")) {\n                    String[] values = ((String) fieldValue).split(\",\");\n                    sb.append(\" in(\");\n                    for (String v : values) {\n                        sb.append(\"'\").append(v).append(\"'\").append(\",\");\n                    }\n                    sb.deleteCharAt(sb.length() - 1);\n                    sb.append(\")\");\n                }\n            } else {\n                sb.append(\"'\").append(fieldValue)\n                        .append(\"'\").append(\" \");\n            }\n            if (fieldValue instanceof Integer) {\n                sb.append(\"and \").append(columnName).append(\"=\").append(fieldValue).append(\" \");\n            }\n        }\n        return sb.toString();\n    }\n}\n```\n\n> 通过jdbc可实现表的完整查询功能功能,在此略过","tags":["java"],"categories":["开源框架"]},{"title":"初识Docker","url":"/2018/10/03/初识Docker/","content":" **读书,健身,努力工作,关心身体,保持好心情,成为最棒的自己!**<Excerpt in index | 首页摘要>\n docker是一个神奇的开发工具!\n\n<!-- more -->\n<The rest of contents | 余下全文>\n## 1.什么是docker\n\n> docker是一个世界领先的容器化平台.网上对他的定义有很多,说法过于复杂化了.我是通过学习springcloud认识的docker的,感觉它就是一个神器.个人理解的docker就是一个背包,你可以把你需要的东西放在这个背包里,然后这个背包你可以分享给任何人.你也可以从免费的商店里获得别人的背包,无论你咋什么样的环境下都可以正常使用这个背包.\n>\n> docker是跨平台的,支持windows,maxos,linux\n\n## 2.docker思想\n\n![1538544866753](/img/1538544866753.png)\n\n## 3.docker解决了哪些问题\n\n### 3.1换一个运行环境程序跑不起来\n\n> 自己本地运行好好的程序放在别人的电脑上就不行了,曾经亲自体会过,非常苦恼.一是苦恼还得在别人的电脑上调bug,更可怕的是时时刻刻担心自己的程序放在第三台电脑上也会down掉了.这种恐惧远胜过修改bug.相信这种问题无论是哪个程序员都或多或少遇到过.docker的出现完美的解决了这个问题,它将你写好的代码,运行环境都放在一个\"集装箱\"里,给别人的不只是代码,而是一整套的程序所需的运行环境.在你的机器上怎们运行,在别人的电脑或者服务器上就会怎样运行.\n\n### 3.2完美实现了隔离\n> docker再启动是为每个容器限定的CPU,硬盘和网络,不会出现一个程序进入了死循环,从而影响到其他程序的事情发生.\n\n### 3.3弹性伸缩变得简单\n> 就电商来说:双十一几亿人同时在线,按照平时的资源配置肯定吃不消.如果按照双十一的业务量来配置资源平时又是极大的浪费.所以就要弹性的加减服务器,写过java程序的小伙伴们到知道,要想在一台电脑上跑java程序需要安装至少需要安装jre,配置环境,再把代码拷过来运行,中间可能还会出现问题.使用docker扩展服务器将变成按一下按钮秒秒钟添加n台服务器那么容易.\n\n## 4.走进docker\n\n> docker的三个关键字:镜像,仓库,容器\n>\n> docker的三个关键单词:Build,Ship,Run\n\n![1538546571188](/img/1538546571188.png)\n\n> -镜像:\n>\n> -容器:\n>\n> -仓库:\n>\n> * 官网仓库:hub.docker.com \n> * 网易仓库:c.163.com\n\n## 5.docker的安装\n\n> 网上教程很多,懒得再详细总结\n\n## 6.第一个docker镜像\n\n###  6.1docker工作流程\n\n![1538548365242](/img/1538548365242.png)\n\n### 6.2常用的命令\n\n> * docker pull [OPTIONS] NAME[:TAG]  拉去镜像   举例:docker pull hello-world\n> * docker images [OPTIONS]_[ REPOSITORY[:TAG]] 查看镜像\n> * docker run hello-world\n> * docker ps\n> * docker exec -it [代号] bash   :进入容器(正在运行的)\n> * which nginx : 查看Nginx的位置\n> * netstat -na|grep 10001 : 检查端口是否开放\n> * docker run -d -p 10001:80 nginx   :开放容器的80端口映射到本机的10001端口\n> * docker run -d -P  nginx :随机开放端口映射过来\n> * docker build .   : 在当前目录运行构建的Dockerfile 文件\n> * docker build  -t  Jpress:latest  .   :给镜像起一个名字和版本\n\n## 7.运行Nginx服务器镜像\n\n![1538548580593](/img/1538548580593.png)\n\n## 8.docker的网络\n\n![1538549437822](/img/1538549437822.png)![1538549459787](./img/1538549459787.png)\n\n## 9.制作自己的镜像\n\n> * Dockerfille : 制作镜像\n> * docker build : 构建镜像","tags":["docker"],"categories":["开发工具"]},{"title":"Oracle学习","url":"/2018/10/01/Oracle学习/","content":" **无需证明什么,要做的唯有让自己更棒!**\n \n <Excerpt in index | 首页摘要>\n\n\n<!-- more -->\n<The rest of contents | 余下全文>\n# Oracle学习\n\n##  第一天:\n\n```sql\n\nselect * from tab;\n\n/*\n数据库  ---> 数据库实例  --->  表空间(逻辑单位)(用户)  ---> 数据文件(物理单位)\n\n地球    ---> 一个国家    --->  省份(逻辑单位)(公民)    ---> 山川河流(物理单位)\n\n\n\n通常情况下,ORacle数据库只会有一个实例ORCL,\n\n新建一个项目:\n     MYSQL : 创建一个数据库,创建相应的表\n     Oracle: 创建一个表空间,创建用户,用户去创建表\n     \nOracle和MYSQL的差别\n\nOracle是多用户的, MYSQL是多数据库的\n\n1. 遵循SQL标准\n2. 不同厂商,不同的数据库产品,但是有自己的方言\n3. 使用自己的方言,也能够完成相同的功能\n4. Oracle安全级别要高,MYSQL开源免费\n\n*/\n/*\n基本查询:\n   SQL : 结构化查询语言\n   \n   请听题: 请说一下SQL的分类以及每类常见的操作符都有哪些\n   四类:\n        DDL : 数据定义语言 create alter drop truncate\n        DML : 数据操纵语言 insert update delete\n        DCL : 数据控制语言 安全 授权 grant revoke\n        DQL : 数据查询语言 select from子句 where子句\n        \n   查询语句的结构:\n   \n   select [列名] [*] from 表名 [where 条件] [group by 分组条件] [having 过滤] [order by 排序]\n*/\nselect * from emp;\n\nselect 1+1;  --在Oracle等于报错 ,在MYSQL中输出结果是2\n\n/*\n     dual : oracle中的虚表 ,伪表, 主要是用来补齐语法结构\n     \n*/\nselect 1+1 from dual;\n\nselect * from dual;\n\nselect 1 from emp;\n--直接写一个常量比写 * 要高效\nselect count(1) from emp;\nselect count(*) from emp;\n\n/*\n       别名查询: 使用as 关键字, 可以省略\n       别名中不能有特殊字符或者关键字, 如果有就加双引号\n       \n*/\nselect ename 姓名, sal 工资 from emp;\n\nselect ename \"姓       名\", sal 工资 from emp;\n\n/*\n      去除重复数据 distinct\n      多列去除重复: 每一列都一样才能够算作是重复\n*/\n--单列去除重复\nselect distinct job from emp;\n\n--多列去除重复的\nselect distinct job,deptno from emp;\n\n\n--查询中四则运算\nselect 1+1 from dual;\n\n--查询员工年薪  = 月薪* 12\nselect sal*12 from emp;\n\n\n--查询员工年薪+奖金\nselect sal*12 + comm from emp;\n--nvl 函数 : 如果参数1为null  就返回参数2\nselect sal*12 + nvl(comm,0) from emp;\n\n/*\n    注意: null值 , 代表不确定的 不可预知的内容 , 不可以做四则运算\n*/\n\n\n/*\n字符串拼接:\n    java : + 号拼接\n    Oracle 特有的连接符: || 拼接\n    \n    在Oracle 中 ,双引号主要是别名的时候使用, 单引号是使用的值, 是字符\n    \n    concat(str1,str2) 函数, 在mysql和Oracle中都有\n*/\n--查询员工姓名 :  姓名:SCOTT\nselect ename from emp;\n--使用拼接符\nselect '姓名:' || ename from emp;\n\n--使用函数拼接\nselect concat('姓名:',ename) from emp;\n\n\n/*\n    条件查询 : [where后面的写法]   \n        关系运算符: > >= = < <= != <>\n        逻辑运算符: and or not\n        其它运算符:\n               like 模糊查询\n               in(set) 在某个集合内\n               between..and.. 在某个区间内\n               is null  判断为空\n               is not null 判断不为空\n*/\n--查询每月能得到奖金的员工信息\nselect * from emp where comm is not null;\n\n\n--查询工资在1500--3000之间的员工信息\nselect * from emp where sal between 1500 and 3000;\n\nselect * from emp where sal >= 1500 and sal <= 3000;\n\n--查询名字在某个范围的员工信息 ('JONES','SCOTT','FORD') in\nselect * from emp where ename in ('JONES','SCOTT','FORD');\n\n\n/*\n    模糊查询: like\n        %   匹配多个字符\n        _   匹配单个字符\n        \n        如果有特殊字符, 需要使用escape转义\n*/\n--查询员工姓名第三个字符是O的员工信息\nselect * from emp where ename like '__O%';\n\n--查询员工姓名中,包含%的员工信息\n\nselect * from emp where ename like '%#%%' escape '#';\nselect * from emp where ename like '%\\%%' escape '\\';\n\n\n```\n\n```sql\n/*\n       排序 : order by \n          升序: asc    ascend\n          降序: desc   descend\n          \n          排序注意null问题 : nulls first | last\n          \n          同时排列多列, 用逗号隔开\n*/\n\n--查询员工信息,按照奖金由高到低排序\n\nselect * from emp order by comm desc nulls last;\n\n--查询部门编号和按照工资  按照部门升序排序, 工资降序排序\nselect deptno, sal from emp order by deptno asc, sal desc;\n\n\n/*\n     函数: 必须要有返回值\n     \n     单行函数: 对某一行中的某个值进行处理\n         数值函数\n         字符函数\n         日期函数\n         转换函数\n         通用函数\n     \n     多行函数: 对某一列的所有行进行处理\n           max()  min count sum avg\n           \n           1.直接忽略空值 \n*/\n--统计员工工资总和\nselect sum(sal) from emp;\n\n--统计员工奖金总和  2200\nselect sum(comm) from emp;\n\n--统计员工人数 14\nselect count(1) from emp;\n\n--统计员工的平均奖金  550  错误    2200/14 =\nselect avg(comm) from emp;\n\n\n--统计员工的平均奖金 157.\nselect sum(comm)/count(1) from emp;\nselect ceil(sum(comm)/count(1)) from emp;\n\nupdate emp set ename = 'TUR%NER' where ename = 'TURNER';\n\nselect * from emp;\n\n\n\n--数值函数\nselect ceil(45.926) from dual;  --46\nselect floor(45.926) from dual; --45\n--四舍五入\nselect round(45.926,2) from dual; --45.93\nselect round(45.926,1) from dual; -- 45.9\nselect round(45.926,0) from dual; --46\nselect round(45.926,-1) from dual; --50\nselect round(45.926,-2) from dual; --0\nselect round(65.926,-2) from dual; --100\n\n--截断\nselect trunc(45.926,2) from dual; --45.92\nselect trunc(45.926,1) from dual; -- 45.9\nselect trunc(45.926,0) from dual; --45\nselect trunc(45.926,-1) from dual; --40\nselect trunc(45.926,-2) from dual; --0\nselect trunc(65.926,-2) from dual; --0\n\n--求余\nselect mod(9,3) from dual; --0\nselect mod(9,4) from dual; --1\n\n\n--字符函数\n-- substr(str1,起始索引,长度) \n--注意: 起始索引不管写 0 还是 1 都是从第一个字符开始截取\nselect substr('abcdefg',0,3) from dual; --abc\nselect substr('abcdefg',1,3) from dual; --abc\n\nselect substr('abcdefg',2,3) from dual; --bcd\n\n--获取字符串长度 24 28\nselect length('abcdefg') from dual;\n\n--去除字符左右两边的空格\nselect trim('  hello  ') from dual;\n\n--替换字符串\nSelect replace('hello','l','a') from dual;\n\n\n\n--日期函数\n--查询今天的日期\nselect sysdate from dual;\n--查询3个月后的今天的日期\nselect add_months(sysdate,3) from dual;\n--查询3天后的日期\nselect sysdate + 3 from dual;\n\n\n--查询员工入职的天数\nselect sysdate - hiredate from  emp;\n\nselect ceil(sysdate - hiredate) from  emp;\n\n--查询员工入职的周数\nselect (sysdate - hiredate)/7 from emp;\n\n--查询员工入职的月数\nselect months_between(sysdate,hiredate) from emp;\n\n--查询员工入职的年份\nselect months_between(sysdate,hiredate)/12 from emp;\n\n--转换函数  数值转字符 字符转数值  日期\n--字符转数值 to_number(str) 鸡肋\nselect 100+'10' from dual;  --110  默认已经帮我们转换\nselect 100 + to_number('10') from dual; --110\n\n--数值转字符\nselect to_char(sal,'$9,999.99') from emp;\n\nselect to_char(sal,'L9,999.99') from emp;\n/*\nto_char(1210.73, '9999.9') 返回 '1210.7' \nto_char(1210.73, '9,999.99') 返回 '1,210.73' \nto_char(1210.73, '$9,999.00') 返回 '$1,210.73' \nto_char(21, '000099') 返回 '000021' \nto_char(852,'xxxx') 返回' 354'\n\n*/\n\n--日期转字符 to_char()  \nselect to_char(sysdate,'yyyy-mm-dd hh:mi:ss') from dual;\nselect to_char(sysdate,'yyyy-mm-dd hh24:mi:ss') from dual;\n--只想要年\nselect to_char(sysdate,'yyyy') from dual;  --2017\n\n--只想要日\nselect to_char(sysdate,'d') from dual; --2  代表一个星期中第几天\nselect to_char(sysdate,'dd') from dual;  --10  代表一个月中的第几天\nselect to_char(sysdate,'ddd') from dual; --100 代表一年中的第几天\n\n\nselect to_char(sysdate,'day') from dual;  --monday\nselect to_char(sysdate,'dy') from dual;   --mon  星期的简写\n\n\n--字符转日期\nselect to_date('2017-04-10','yyyy-mm-dd') from dual;\n\n--查询1981年 -- 1985年入职的员工信息\nselect * from emp where hiredate between to_date('1981','yyyy') and to_date('1985','yyyy');\n\n\n/* \n      通用函数:\n       nvl(参数1,参数2) 如果参数1 = null 就返回参数2\n       nvl2(参数1,参数2,参数3) 如果参数1 = null ,就返回参数3, 否则返回参数2\n       \n       nullif(参数1,参数2) 如果参数1 = 参数2 那么就返回 null , 否则返回参数1\n       \n       coalesce: 返回第一个不为null的值\n*/\nselect nvl2(null,5,6) from dual; --6;\n\nselect nvl2(1,5,6) from dual; --5;\n\nselect nullif(5,6) from dual; --5\nselect nullif(6,6) from dual; --null\n\nselect coalesce(null,null,3,5,6) from dual;  --3\n\n\n\n\nselect ceil(-12.5) from dual; --12\nselect floor(12.5) from dual; --12\n\n\nselect '  hello  ' from dual;\nselect * from emp;\n```\n\n\n\n##  第二天:\n\n```SQL\nselect * from bonus;\n\nselect * from salgrade;\n\n/*\n     多表查询:\n       笛卡尔积: 实际上是两张表的乘积,但是在实际开发中没有太大意义\n      \n     格式: select * from 表1,表2   \n*/\nselect * from emp;\nselect * from dept;\n\nselect * from emp, dept;\n\nselect * from emp e1, dept d1 where e1.deptno = d1.deptno;\n/*\n     内联接:\n       隐式内联接: \n           等值内联接:   where e1.deptno = d1.deptno;\n           不等值内联接:  where e1.deptno <> d1.deptno;\n           自联接: 自己连接自己\n       显示内联接:\n           select * from 表1 inner join 表2 on 连接条件\n           \n           inner 关键字可以省略\n*/\nselect * from emp e1, dept d1 where e1.deptno <> d1.deptno;\n\n--查询员工编号,员工姓名,经理的编号,经理的姓名\nselect e1.empno,e1.ename,e1.mgr,m1.ename\nfrom emp e1, emp m1 where e1.mgr= m1.empno;\n\n\n--查询员工编号,员工姓名,员工的部门名称,经理的编号,经理的姓名\nselect e1.empno,e1.ename,d1.dname,e1.mgr,m1.ename\nfrom emp e1, emp m1,dept d1 where e1.mgr= m1.empno and e1.deptno = d1.deptno;\n\n--查询员工编号,员工姓名,员工的部门名称,经理的编号,经理的姓名,经理的部门名称\nselect e1.empno,e1.ename,d1.dname,e1.mgr,m1.ename,d2.dname\nfrom emp e1, emp m1,dept d1,dept d2 \nwhere \n     e1.mgr= m1.empno \n and e1.deptno = d1.deptno\n and m1.deptno = d2.deptno \n;\n\n--查询员工编号,员工姓名,员工的部门名称,员工的工资等级,经理的编号,经理的姓名,经理的部门名称\nselect e1.empno,e1.ename,d1.dname,s1.grade,e1.mgr,m1.ename,d2.dname\nfrom emp e1, emp m1,dept d1,dept d2,salgrade s1 \nwhere \n     e1.mgr= m1.empno \n and e1.deptno = d1.deptno\n and m1.deptno = d2.deptno\n and e1.sal between s1.losal and s1.hisal \n;\n\n--查询员工编号,员工姓名,员工的部门名称,员工的工资等级,经理的编号,经理的姓名,经理的部门名称,经理的工资等级\nselect e1.empno,e1.ename,d1.dname,s1.grade,e1.mgr,m1.ename,d2.dname,s2.grade\nfrom emp e1, emp m1,dept d1,dept d2,salgrade s1,salgrade s2 \nwhere \n     e1.mgr= m1.empno \n and e1.deptno = d1.deptno\n and m1.deptno = d2.deptno\n and e1.sal between s1.losal and s1.hisal \n and m1.sal between s2.losal and s2.hisal \n;\n\n--查询员工编号,员工姓名,员工的部门名称,员工的工资等级,经理的编号,经理的姓名,经理的部门名称,经理的工资等级\n--将工资等级 1,2,3,4 显示成 中文的 一级 二级 三级...\n\nselect e1.empno,\n       e1.ename,\n       d1.dname,\n       case s1.grade\n         when 1 then '一级'\n         when 2 then '二级'\n         when 3 then '三级'\n         when 4 then '四级'\n         else\n             '五级'\n         end \"等级\",\n       e1.mgr,\n       m1.ename,\n       d2.dname,\n       decode(s2.grade,1,'一级',2,'二级',3,'三级',4,'四级','五级') \"等级\"\nfrom emp e1, emp m1,dept d1,dept d2,salgrade s1,salgrade s2 \nwhere \n     e1.mgr= m1.empno \n and e1.deptno = d1.deptno\n and m1.deptno = d2.deptno\n and e1.sal between s1.losal and s1.hisal \n and m1.sal between s2.losal and s2.hisal \n;\n\n--查询员工姓名和员工部门所处的位置\nselect e1.ename,d1.loc from emp e1,dept d1 where e1.deptno = d1.deptno;\n\nselect * from emp e1 inner join dept d1 on e1.deptno = d1.deptno;\n\n\n/*\n    外连接: (标准,通用写法)\n       左外连接: left outer join 左表中所有的记录,如果右表没有对应记录,就显示空\n       右外连接: right outer join 右表中的所有记录,如果左表没有对应记录,就显示空\n       outer 关键字可以省略  \n       \n    Oracle中的外连接: (+) 实际上是如果没有对应的记录就加上空值\n          select * from emp e1,dept d1 where e1.deptno = d1.deptno(+);            \n*/\nselect * from emp e1 left outer join dept d1 on e1.deptno = d1.deptno;\ninsert into emp(empno,ename) values(9527,'HUAAN');\nselect * from emp e1,dept d1 where e1.deptno = d1.deptno(+);\n\nselect * from emp e1 right outer join dept d1 on e1.deptno = d1.deptno;\nselect * from emp e1,dept d1 where e1.deptno(+) = d1.deptno;\n\n\n\n/*\n       子查询: 查询语句中嵌套查询语句; 用来解决复杂的查询语句\n            查询最高工资的员工信息     \n         单行子查询: > >= = < <= <> !=\n            \n         多行子查询: in not in  >any >all exists not exists\n               \n               查询领导信息\n*/\n--查询最高工资的员工信息 \n--1.查询出最高工资 --5000\nselect max(sal) from emp;\n--2. 工资等于最高工资\nselect * from emp where sal = (select max(sal) from emp);\n\n\n--查询出比雇员7654的工资高,同时和7788从事相同工作的员工信息\n--1.雇员7654的工资 1250\nselect sal from emp where empno = 7654;\n--2.7788从事的工作 ANALYST\nselect job from emp where empno = 7788;\n--3.两个条件合并\nselect * from emp where sal > 1250 and job = 'ANALYST';\n\nselect * from emp where sal > (select sal from emp where empno = 7654) and job = (select job from emp where empno = 7788);\n\n--查询每个部门最低工资的员工信息和他所在的部门信息\n--1.查询每个部门的最低工资,分组统计\nselect deptno,min(sal) minsal from emp group by deptno;\n--2.员工工资等于他所处部门的最低工资\nselect * \nfrom emp e1,\n     (select deptno,min(sal) minsal from emp group by deptno) t1 \nwhere e1.deptno = t1.deptno and e1.sal = t1.minsal; \n--3.查询部门相关信息\nselect * \nfrom emp e1,\n     (select deptno,min(sal) minsal from emp group by deptno) t1,\n     dept d1 \nwhere e1.deptno = t1.deptno and e1.sal = t1.minsal and e1.deptno = d1.deptno; \n\n\n/*\n      内联接, 单行子查询, 多行子查询\n      \n      in \n      not in\n      any \n      all\n      exists \n      \n      通常情况下, 数据库中不要出现null  最好的做法加上Not null\n      null值并不代表不占空间, char(100) null 100个字符\n*/\n--查询领导信息\n--1.查询所有经理的编号\nselect mgr from emp;\nselect distinct mgr from emp;\n--2.结果\nselect * from emp where empno in (select mgr from emp);\n\n--查询不是领导的信息\nselect * from emp where empno not in (select mgr from emp);\nselect * from emp where empno <>all(select mgr from emp);\n--正确的写法\nselect * from emp where empno not in (select mgr from emp where mgr is not null);\n\n--查询出比10号部门任意一个员工薪资高的员工信息  10 20 30\nselect * from emp where sal >any (select sal from emp where deptno = 10);\n\n\n--查询出比20号部门所有员工薪资高的员工信息 10 20 30\n--1.20号最高工资 5000\nselect max(sal) from emp where deptno =20;\n--2.员工信息\nselect * from emp where sal > (select max(sal) from emp where deptno =20); \n\n-----使用多行子查询完成上面这题\n---------20号部门所有员工薪资 (800 2975 ...)\nselect sal from emp where deptno = 20;\n---------大于集合所有的\nselect * from emp where sal >all(select sal from emp where deptno = 20);\n\n\n/*\n     exists(查询语句) : 存在的意思,判断一张表里面的记录是否存在与另外一张表中\n                当作布尔值来处理:\n                    当查询语句有结果的时候, 就是返回true\n                                            否则返回的是false\n     数据量比较大的时候是非常高效的   \n*/\nselect * from emp where exists(select * from emp where deptno = 1234567);\nselect * from emp where 3=4;\n\nselect * from emp where exists(select * from emp where deptno = 20);\n\n--查询有员工的部门的信息\nselect * from dept d1 where exists(select * from emp e1 where e1.deptno = d1.deptno );\n\n\n\n\n\n\n--找到员工表中工资最高的前三名(降序排序)\nselect * from emp order by sal desc;\n/*\n       rownum : 伪列, 系统自动生成的一列, 用来表示行号\n       \n       rownum是Oracle中特有的用来表示行号的, 默认值/起始值是 1 ,在每查询出结果之后,再添加1\n       \n       rownum最好不能做大于号判断,可以做小于号判断\n       \n       SQL执行顺序\n       from .. where ..group by..having .. select..rownum..order by\n*/\nSelect rownum,e1.* from emp e1;\n\n--查询rownum大于2的所有记录 ,\nselect rownum,e1.* from emp e1 where rownum > 2;  --没有任何记录\n\n--查询rownum大于等于1的所有记录 \nselect rownum,e1.* from emp e1 where rownum >=1;\n \n--查询rownum < 6 的所有记录\nselect rownum,e1.* from emp e1 where rownum < 6;\n\n--rownum 排序\nSelect rownum,e1.* from emp e1 order by sal;\n\n--找到员工表中工资最高的前三名\nselect e1.* from emp e1 order by sal desc;\n--将上面的结果当作一张表处理,再查询\nselect rownum, t1.* from (select e1.* from emp e1 order by sal desc) t1;\n\n--只要显示前三条记录\nselect rownum, t1.* from (select e1.* from emp e1 order by sal desc) t1 where rownum < 4;\n\n\n--找到员工表中薪水大于本部门平均薪水的员工\n--1.分组统计部门平均薪水\nselect deptno,avg(sal) avgsal from emp group by deptno;\n--2.员工工资 > 本部门平均工资\nselect * from emp e1,(select deptno,avg(sal) avgsal from emp group by deptno) t1 \nwhere e1.deptno = t1.deptno and e1.sal > t1.avgsal;\n/*\n      关联子查询 , 非关联子查询\n*/\nselect * from emp e where sal > (select avg(sal) from emp e2 group by deptno having e.deptno=e2.deptno);\n\n\n\n/*\n   统计每年入职的员工个数\n*/\nselect hiredate from emp;\n--只显示年\nselect to_char(hiredate,'yyyy') from emp;\n--分组统计\nselect  to_char(hiredate,'yyyy') yy,count(1) cc from emp group by  to_char(hiredate,'yyyy');\n\nselect yy\nfrom \n(select  to_char(hiredate,'yyyy') yy,count(1) cc from emp group by  to_char(hiredate,'yyyy')) tt;\n\nselect case yy when '1987' then cc end\nfrom \n(select  to_char(hiredate,'yyyy') yy,count(1) cc from emp group by  to_char(hiredate,'yyyy')) tt;\n\nselect case yy when '1987' then cc end \"1987\"\nfrom \n(select  to_char(hiredate,'yyyy') yy,count(1) cc from emp group by  to_char(hiredate,'yyyy')) tt;\n\n--去除行记录中的空值\nselect sum(case yy when '1987' then cc end) \"1987\"\nfrom \n(select  to_char(hiredate,'yyyy') yy,count(1) cc from emp group by  to_char(hiredate,'yyyy')) tt;\n\n--统计员工的总数\nselect sum(cc) \"TOTAL\"\nfrom \n(select  to_char(hiredate,'yyyy') yy,count(1) cc from emp group by  to_char(hiredate,'yyyy')) tt;\n\n--将1987 和TOTAL 合并在一起\nselect\n      sum(cc) \"TOTAL\",\n      sum(case yy when '1987' then cc end) \"1987\"\nfrom\n      (select  to_char(hiredate,'yyyy') yy,count(1) cc from emp group by  to_char(hiredate,'yyyy')) tt;\n\n--显示所有年份的结果\nselect\n      sum(cc) \"TOTAL\",\n      sum(case yy when '1980' then cc end) \"1980\",\n      sum(case yy when '1981' then cc end) \"1981\",\n      sum(case yy when '1982' then cc end) \"1982\",\n      sum(case yy when '1987' then cc end) \"1987\"\nfrom\n      (select  to_char(hiredate,'yyyy') yy,count(1) cc from emp group by  to_char(hiredate,'yyyy')) tt;\n\n/*\n    rowid : 伪列  每行记录所存放的真实物理地址\n    rownum : 行号 , 每查询出记录之后,就会添加一个行号\n*/\nselect rowid,e.* from emp e;\n\n--去除表中重复记录\ncreate table p(\n       name varchar2(10)\n);\n\ninsert into p values('黄伟福');\ninsert into p values('赵洪');\ninsert into p values('杨华');\n\ndelete from p where \n\nselect rowid,p.* from p;\nselect distinct * from p;\n\ndelete from p p1 where rowid > (select min(rowid) from p p2 where p1.name = p2.name);\n\n\n/*\n       rownum : 分页查询 \n       在oracle中只能使用子查询来做分页查询  \n*/\n--查询第6 - 第10 记录\nselect rownum, emp.* from emp;\n\nselect rownum hanghao, emp.* from emp;\n\nselect * from (select rownum hanghao, emp.* from emp) tt where tt.hanghao between 6 and 10;\n\n\n\n/*\n       集合运算: \n         并集: 将两个查询结果进行合并\n         交集\n         差集\n       \n       所有的查询结果可能不是来自同一张表,  \n         emp  2000年\n              2017年 手机 详细信息 emp2017\n         \n*/\n--工资大于1500,或者20号部门下的员工\nselect * from emp where sal > 1500 or deptno = 20;\n\n--工资大于1500\nselect * from emp where sal > 1500;\n--20号部门下的员工\nselect * from emp where deptno = 20;\n\n--并集运算: union  union all\n/*\n        union : 去除重复的,并且排序\n        union all : 不会去除重复的\n*/\nselect * from emp where sal > 1500\nunion\nselect * from emp where deptno = 20;\n\nselect * from emp where sal > 1500\nunion all\nselect * from emp where deptno = 20;\n\n/*\n    交集运算: intersect\n       \n*/\n--工资大于1500,并且20号部门下的员工\nselect * from emp where sal > 1500;\nselect * from emp where deptno = 20;\n\nselect * from emp where sal > 1500\nintersect\nselect * from emp where deptno = 20;\n\n\n/*\n   差集运算: 两个结果相减\n*/\n--1981年入职员工(不包括总裁和经理)\n--1981年入职员工\nselect * from emp where to_char(hiredate,'yyyy')='1981';\n\n--总裁和经理\nselect * from emp where job = 'PRESIDENT' or job = 'MANAGER';\n\n\nselect * from emp where to_char(hiredate,'yyyy')='1981'\nminus\nselect * from emp where job = 'PRESIDENT' or job = 'MANAGER';\n\n\n\n/*\n       集合运算中的注意事项:\n         1.列的类型要一致\n         2.按照顺序写\n         3.列的数量要一致,如果不足,用空值填充\n*/\nselect ename,sal from emp where sal > 1500\nunion\nselect ename,sal from emp where deptno = 20;\n--列的类型不匹配\nselect ename,sal from emp where sal > 1500\nunion\nselect sal,ename from emp where deptno = 20;\n\n--列的数量不匹配\nselect ename,sal,deptno from emp where sal > 1500\nunion\nselect ename,sal from emp where deptno = 20;\n\nselect ename,sal,deptno from emp where sal > 1500\nunion\nselect ename,sal,null from emp where deptno = 20;\n\nselect ename,sal,deptno from emp where sal > 1500\nunion\nselect ename,sal,66 from emp where deptno = 20;\n\nselect * from emp;\nselect * from dept;\n\n```\n\n## 第三天:\n\n```SQL\n/*\n  多表查询:\n    内联接\n      等值联接\n      inner join\n    外连接\n      left outer join\n      right outer join\n      Oracle特有的写法(+)\n      \n    子查询:\n      \n   \n*/\n--内联接的结果\nselect * from emp e1,emp t1 where e1.mgr = t1.empno;\n--t1表里面的所有记录都会显示出来, 如果t1.empno 在e1.mgr中没有对应的记录,就加空值\nselect * from emp e1,emp t1 where e1.mgr(+) = t1.empno;\n--查询不是领导的员工编号\nselect empno from emp where empno not in (select mgr from emp where mgr is not null);\n\n--获取员工的名字和部门的名字\nselect e.ename,d.dname from emp e,dept d where e.deptno = d.deptno;\n----使用子查询的方式来完成\nselect ename,deptno from emp;\n\nselect ename,deptno,deptno from emp;\n--关联子查询, 子查询依赖外部查询的条件\nselect e.ename,e.deptno,(select d.dname from dept d where d.deptno = e.deptno ) aa from emp e;\n\n\n--统计薪资大于薪资最高的员工所在部门的平均工资和薪资最低的员工所在部门的平均工资的平均工资的员工信息。\n\n\n/*\n     Oracle体系结构:\n      数据库 ---> 数据库实例ORCL ---> 表空间 (用户里面的创建表) ---> 数据文件 \n      地球   ---> 中国           ---> 省份  (人民)              ---> 土地山川河流\n     \n     雄安新区 ---> 人(开发荒地,种地)\n                \n     \n     创建表空间: 逻辑单位, 通常我们新建一个项目,就会去新建表空间,在表空间中创建用户来创建表\n           语法:\n               create tablespace 表空间的名称\n               datafile '文件的路径(服务器上)'\n               size 大小\n               autoextend on  自动扩展\n               next 每次扩展的大小\n*/\n--切换到system帐号下创建\n--创建一个表空间 --- 汉东\ncreate tablespace handong\ndatafile 'c:\\handong.dbf'\nsize 100m\nautoextend on\nnext 10m;\n\n\n--删除表空间\ndrop tablespace handong;\n\n\n/*\n   创建用户 \n     create user 用户名\n     identified by 密码\n     default tablespace 表空间的名称\n*/\ncreate user dakang\nidentified by dakang\ndefault tablespace handong;\n\n\n\n/*\n授权   grant 角色 | 权限  to 用户\n*/\ngrant connect to dakang;\n\n--授予 dba的角色\ngrant dba to dakang;\n\n\nselect * from scott.emp;\n\n\n/*\n      创建表:\n         create table 表名(\n           列名  列的类型 [列的约束],\n           列名  列的类型  [列的约束]      \n         );\n      列的类型:\n         varchar ,在Oracle中,目前是支持的, 但是不保证以后还支持\n         \n         varchar2(长度) 可变字符长度    varchar2(10)  hello  占5个字符\n         char(长度)   固定长度字符      char(10)      hello  占10个字符,用空格填充\n         number(总长度,小数长度)     数字类型 --小数长度不能大于等于总长度\n         \n         date                   年月日时分秒 2017/4/13 9:43:49\n         timestamp              时间戳, 比date类型更加精确 13-APR-17 09.44.08.272000 AM +08:00\n         \n         LONG/CLOB : 存放一本小说\n         BLOB      : 存放电影  java 存进去,  再读取出来\n     \n\n    使用子查询的方式创建表\n         \n         create table 表名 as 查询语句; \n         \n           注意: 只会复制表结构和表中的数据,不会复制列的约束     \n                 如果查询语句有结果, 就是复制 表结构和数据\n                 如果查询语句没有结果, 就是复制 表结构   \n         \n*/\ncreate table test1(\n   name1 varchar2(10),\n   name2 char(10),\n   age   number(2,3)    \n);\n\ninsert into test1(name1,name2) values('hello','hello');\n\nselect * from test1 where name1 like 'hello'; --可以查询数据\nselect * from test1 where name2 like 'hello'; --查不出数据\n\ninsert into test1(age) values(2);\n\nselect current_date from dual;\nselect current_timestamp from dual;\n\nselect * from test1;\n\n--  create table 表名 as 查询语句; 复制表     \nselect * from scott.emp;\n\ncreate table emp as select * from scott.emp;\n\n--如果查询语句是没有任何的结果的\nselect * from scott.emp where 1=2;\ncreate table emp1 as select * from scott.emp where 1=2;\n\n\nselect * from emp1;\n\n\n/*\n    修改表:\n       添加列\n       修改列 vharchar2(10)\n       删除列\n       修改列名\n       \n       重命名表   \n       \n  SQL分类:\n       DDL : 数据定义语言, 修改的结构  alter create drop truncate\n       DML :　数据操纵语言 , 操作表中数据 insert update delete\n       DCL : 数据控制语言 , grant     \n       DQL : select\n*/\ncreate table stu(\n    stuid number,\n    sname varchar(10)   \n);\n\n--添加一列  \nalter table stu add phone varchar2(11);\n\nalter table stu add (\n                          mobile varchar2(11),\n                          sex    varchar2(2)\n                     );\n\n--修改列的类型\nalter table stu modify sex varchar2(4);\n\n--修改列名 sex --- gender\nalter table stu rename column sex to gender;\n\n--删除列\nalter table stu drop column gender;\n\n--修改表名\nrename stu to student;\n\n\n\n--删除表\ndrop table student;\n\n\n/*\n   表的五大约束\n   列的约束: 约束主要是用来约束表中数据的规则\n     主键约束: primary key 不能为空, 必须唯一\n     非空约束\n     唯一约束\n     检查约束 check(条件)  在mysql中是可以写的,但是mysql直接忽略了检查约束\n     \n     外键约束:\n          主要是用来约束从表A中的记录,必须是存在于主表B中\n*/\n--男,女,人妖\ncreate table student(\n    stuid number primary key,\n    sname varchar2(10) unique,\n    age   varchar2(10) not null,\n    gender varchar2(4) check( gender in ('男','女','人妖'))\n);\n--主键约束违反\ninsert into student values(1,'张三','31','男');\ninsert into student values(1,'李四','31','男');\n--唯一约束违反\ninsert into student values(1,'徐立','31','男');\ninsert into student values(2,'徐立','31','男');\n--非空约束\ninsert into student values(1,'徐立',null,'男');\n--检查约束\ninsert into student values(1,'徐立','31','男');\n\ninsert into student values(1,'徐立','31','妖');\n\nselect * from student;\n\n/*\n     商品分类,商品表\n     \n*/\n--商品分类表\ncreate table category(\n       cid number primary key,\n       cname varchar2(20)\n);\n\n--创建一个商品表\ncreate table product(\n       pid number primary key,\n       pname varchar2(20),\n       cno number\n);\n\ninsert into category values(1,'手机数码');\n\ninsert into product values(10,'锤子',11);\n\n\n\n--添加外键约束\nalter table product add foreign key(cno) references category(cid);\ninsert into product values(10,'锤子',11);--插入失败\n\n--1.首先主表中必须存在11号, 先往主表中插入数据,再往从表中插入数据\ninsert into category values(2,'电脑办公');\ninsert into product values(11,'外星人',2);\n\n\n--删除Category\ndrop table category; --表中记录被外键关联无法删除\n\n--强制删除表(不建议使用) : 先删除外键关联表的外键约束,然后再删除自己, 先删除product的外键约束,再删除category\ndrop table category cascade constraint;\n\n\n--级联删除\n----添加外键约束,使用级联约束  ,在删除的时候,使用级联删除\nalter table product add foreign key(cno) references category(cid) on delete cascade;\n\n\ninsert into category values(2,'电脑办公');\ninsert into product values(11,'外星人',2);\n\n--级联删除 : 首先去从表中找有没有 关联数据, 如果在从表中找到关联数据,先删除从表中关联数据,然后再删除表中的数据\ndelete from category where cid = 2;\n\n\nselect * from category;\nselect * from product;\n\ndrop table product;\ntruncate table product;\ntruncate table category;\n\n/*\n     插入数据:\n         insert into 表名 values(所有列的值都要对应写上)\n         insert into 表名(列1,列2) values(值1,值2);\n         \n     使用子查询插入数据\n         insert into 表名 查询语句\n*/\nselect * from emp1;\n\nselect * from emp;\n--将emp中10号部门的员工信息,插入到emp1中\ninsert into emp1 select * from emp where deptno = 10;\n\n\n/*\n     更新数据\n       update 表名 set 列名 = 列的值  [where 条件]\n*/\nupdate emp1 set ename='HUAAN' where ename = 'KING';\nselect * from emp1;\n\n/*\n     删除数据:\n       delete from 表名  [where 条件]\n       \n       delete和truncate 区别\n        \n       delete:                 truncate:\n        DML                    DDL\n        逐条删除               先删除表再创建表\n        支持事务操作           不支持事务操作,\n                               执行效率要高  \n       \n       \n*/\ndelete from emp1 where empno=7839;\n\n/*\n   事务: 就是一系列的操作,要么都成功,要么都失败\n       四大特性: 原子性,隔离性,持久性,一致性\n          \n       如果不考虑隔离级别: 脏读,虚读,不可重复读\n            MYSQL隔离级别: READ UNCOMMITTED , READ COMMITTED, REPEATABLE READ, SERIALIAZABLE\n            ORACLE隔离级别: READ COMMITTED SERIALIZABLE READ ONLY \n                        默认隔离级别: READ COMMITTED\n                        \n      提交 : commit\n      事务的保存点/回滚点: savepoint 保存点的名称\n      回滚: rollback\n*/\ncreate table louti(\n   lou number primary key    \n);\n\ninsert into louti values(1);\ninsert into louti values(2);\ninsert into louti values(3);\ninsert into louti values(4);\ninsert into louti values(5);\nsavepoint dangban;\ninsert into louti values(5); --主键约束会发生异常\ninsert into louti values(6);\nrollback to dangban\ncommit;\n\n\ndeclare\n\nbegin\n  insert into louti values(1);\n  insert into louti values(2);\n  insert into louti values(3);\n  insert into louti values(4);\n  insert into louti values(5);\n  savepoint dangban;\n  insert into louti values(5);  --这行代码会发生异常\n  insert into louti values(6);\n  commit;\nexception  --捕获异常\n  when others then\n     rollback to dangban;\n     commit;\nend;\n\nselect * from louti;\n\n/*\n      视图: 是对查询结果的一个封装\n      视图里面所有的数据,都是来自于它查询的那张表,视图本身不存储任何数据\n          1.能够封装复杂的查询结果\n          2.屏蔽表中的细节\n       语法: \n          create [or replace] view 视图的名称 as 查询语句 [ with read only]\n          \n       注意: 通常不要通过视图去修改,视图创建的时候,通常要加上with read only\n*/\nselect * from emp;\n\n--创建一个视图\ncreate or replace view view_test1 as select ename,job,mgr from emp;\n\n--通过视图修改数据\nupdate view_test1 set ename='SMITH2' where ename = 'SMITH';\n\n--创建一个只读视图\ncreate or replace view view_test2 as select ename,job,mgr from emp with read only;\n\nupdate view_test2 set ename='SMITH3' where ename = 'SMITH2';\n\n--视图封装复杂的查询语句\ncreate view view_test3 as select\n      sum(cc) \"TOTAL\",\n      sum(case yy when '1980' then cc end) \"1980\",\n      sum(case yy when '1981' then cc end) \"1981\",\n      sum(case yy when '1982' then cc end) \"1982\",\n      sum(case yy when '1987' then cc end) \"1987\"\nfrom\n      (select  to_char(hiredate,'yyyy') yy,count(1) cc from emp group by  to_char(hiredate,'yyyy')) tt;\n\n\n\n--同义词的概念\ncreate synonym dept for view_test3;\n\n\ncreate synonym yuangong for view_test2;\n\nselect * from yuangong;\n\nselect * from dept;\n\nselect * from view_test3;\n\nselect * from view_test2;\n\n/*\n    序列: 生成类似于 auto_increment 这种ID自动增长 1,2,3,4,5....\n       auto_increment 这个是mysql  \n       \n       语法:\n           create sequence 序列的名称\n           start with 从几开始\n           increment by 每次增长多少\n           maxvalue 最大值 | nomaxvalue\n           minvalue 最小值 | nominvalue\n           cycle | nocycle  是否循环    1,2,3,1,2,3\n           cache 缓存的数量3 | nocache  1,2,3,4,5,6 \n           \n      如何从序列获取值\n          currval : 当前值\n          nextval : 下一个值\n          \n               注意: currval 需要在调用nextval之后才能使用      \n               \n               永不回头,往下取数据, 无论发生异常, 回滚   \n*/\n--创建一个 1,3,5,7,9......30 \ncreate sequence seq_test1\nstart with 1\nincrement by 2\nmaxvalue 30\ncycle\ncache 10;\n\nselect seq_test1.nextval from dual;\nselect seq_test1.currval from dual;\n\n--序列用的最多的一种写法\ncreate sequence seq_test2;\nselect seq_test2.nextval from dual;\n\n\ncreate sequence seq_test3\nstart with 1\nincrement by 2\nmaxvalue 30\nminvalue 0\ncycle\ncache 10;\n\nselect seq_test3.nextval from dual;\n\n/*\n    索引:相当于是一本书的目录,能够提高我们的查询效率\n       如果某一列,你经常用来作为查询条件,那么就有必要创建索引,数据量比较的情况\n       \n       语法: \n             create index 索引的名称 on 表名(列)   \n        \n       注意:主键约束自带主键索引, 唯一约束自带唯一索引\n       \n       索引原理: btree   balance Tree 平衡二叉树\n       \n             如果某列作为查询条件的时候,可以提高查询效率,但是修改的时候,会变慢\n             \n             索引创建好之后,过了一段,DBA都会去做重构索引\n             \n       SQL调优:\n             1.查看执行计划F5\n             2. 分析里面的cost 和 影响行数, 想办法降低            \n*/\n--五百万数据测试\ncreate table wubaiwan(\n      name varchar2(30),\n      address varchar2(20) \n);\n\ninsert into wubaiwan values('')\n\n--插入500000万条数据\ndeclare\n\nbegin\n     for i in 1..5000000 loop\n       insert into wubaiwan values('姓名'||i,'地址'||i);\n     end loop;\n     commit;  \nend;\n\n--在没有添加索引的情况下,去查询  name='姓名3000000'  --2.985\nselect * from wubaiwan where name='姓名3000000';\n\n--创建索引 name 再去查询 name='姓名3000000'\ncreate index ind_wubaiwan on wubaiwan(name);\nselect * from wubaiwan where name='姓名3000000';  --0.016\n\n--在没有添加复合索引的情况下,再去查询 name='姓名3000000' and '地址3000000'\nselect * from wubaiwan where name='姓名3000000' and address='地址3000000'; --0.032\n\n--创建复合索引的情况下, 再去查询\ncreate index ind_wubaiwan2 on wubaiwan(name,address);\nselect * from wubaiwan where name='姓名3000000' and address='地址3000000'; --0.015\n\n\n\n/*\n     DDL表空间操作\n         创建表空间\n         创建用户\n         授权\n         \n         创建表\n              子查询创建表\n         修改表 : 添加列,删除列,修改列,修改列名, 修改表名\n         \n         约束:\n             主键约束,唯一约束,非空约束,检查约束,外键约束\n             \n             外键约束:\n               强制删除\n               级联删除\n             \n     DML表中数据:\n         插入数据\n             子查询插入数据\n         更新数据\n         删除数据: delete 和 truncate\n         \n         事务操作:\n               savepoint 保存点\n               rollback to 保存点\n          ORACLE事务隔离级别  : READ COMMITTED \n          \n     视图: 就像窗户一样, 封装查询结果 , 通常视图创建只读视图\n     序列: 主要是用来实现ID自增长 \n     索引: 相当于是书的目录,能够提高查询效率, 原理 平衡二叉树, 每隔一段时间DBA都需要去重建索引\n     同义词: create synonym 名称 for 对象的名称          \n\n*/\n/*\n     PLSQL编程 : procedure Language 过程语言 Oracle对SQL的一个扩展\n             让我们能够像在java中一样写 if else else if 条件, 还可以编写循环逻辑 for while\n             \n             declare\n                --声明变量\n                变量名 变量类型;\n                变量名 变量类型 := 初始值;\n                  vsal emp.sal%type;  --引用型的变量  \n                  vrow emp%rowtype;   --声明记录型变量          \n             begin\n                --业务逻辑\n             end;\n             \n             dbms_output.put_line()相当于java中 syso \n*/\ndeclare\n   i varchar2(10) := '张三';          \nbegin\n  dbms_output.put_line(i);\nend;\n\n--查询7369的工资,并且打印出来\ndeclare\n  vsal emp.sal%type;\nbegin\n  --将查询出的结果赋值给vsal\n  select sal into vsal from emp where empno = 7369;\n  \n  dbms_output.put_line(vsal);\nend;\n\n--查询7369的员工信息,并且打印出来\n select * from emp where empno = 7369;\n\ndeclare\n  vrow emp%rowtype;      \nbegin\n  select * into vrow from emp where empno = 7369;\n  \n  dbms_output.put_line('姓名:'||vrow.ename || '工资'|| vrow.sal);\nend;\n\n/*\n  PL条件判断\n     \n     if then\n     \n     elsif then\n       \n     else \n     \n     end if;\n*/\n--根据不同年纪,输出相关内容\ndeclare\n   age number := &aaa;\nbegin\n  if age < 18 then\n     dbms_output.put_line('小屁孩');\n  elsif age>=18 and age <=24 then\n     dbms_output.put_line('年轻人');\n  elsif age>24 and age < 40 then\n    dbms_output.put_line('老司机');\n  else \n      dbms_output.put_line('老年人');    \n  end if;\nend;\n\n/*\n  循环操作\n  while 循环\n      while 条件 loop\n        \n      end loop;\n    \n  for循环\n      for 变量  in [reverse] 起始值..结束值 loop\n        \n      end loop;\n  \n  loop循环  \n      loop\n        exit when 条件\n      end loop;\n      \n*/\n--输出1~10\ndeclare\n  i number :=1;\nbegin\n  while i<=10 loop\n    dbms_output.put_line(i);\n    i := i+1;    \n  end loop;\nend;\n\n--输出1~10\ndeclare\n\nbegin\n  for i in reverse 1..10 loop\n    dbms_output.put_line(i);\n  end loop;\nend;\n\n--输出1~10\ndeclare\n   i number :=1;\nbegin\n   loop\n     exit when i>10;\n      dbms_output.put_line(i);  \n     i := i+1;\n   end loop;\nend;\n\n/*\n\n   *\n  ***\n *****\n  ***\n   *   \n输出 m  \n   x : [-m,m]\n   y : [-m,m]\n   \n   输出所有满足条件的 : abs(y)+abs(x) <=m\n   \n   m取值\n*/\n--使用PLSQL输出菱形\ndeclare\n   m number := 10;\nbegin\n   for x in -m..m loop\n     for y in -m..m loop\n       if abs(y) + abs(x) <= m then\n         dbms_output.put('*');\n       else\n         dbms_output.put(' ');\n       end if;      \n     end loop;\n     dbms_output.new_line();\n   end loop;  \nend;\n\n--使用PLSQL输出三角形,只要是三个角\ndeclare\n   m number := 10;\nbegin\n   for x in reverse -m..m loop\n     for y in -m..m loop\n       if abs(y) + abs(x) <= m and x>=0 then\n         dbms_output.put('*');\n       else\n         dbms_output.put(' ');\n       end if;      \n     end loop;\n     dbms_output.new_line();\n   end loop;  \nend;\n\n```\n\n## 第四天:\n\n```SQL\n/*\n  序列: ORACLE使用来模拟ID自动增长的\n  \n*/\ncreate sequence seq_test4;\n\ncreate table test2(\n   tid number primary key,\n   tname varchar2(10)    \n);\n\ninsert into test2 values(seq_test4.nextval,'张三');\nselect * from test2;\n\n/*\n       PLSQL编程: 过程语言,编写一些复杂业务逻辑  \n       \n       输出星号:\n                abs(y) + abs(x) <= m   \n                \n       vsal  emp.sal%type --引用型变量\n       row  emp%rowtype  --记录型变量\n       \n       select sal into vsal from emp where empno=7788;\n*/\ndeclare\n   m number := 3;             \nbegin\n   for y in -m..m loop\n     for x in -m..m loop\n         if abs(y) + abs(x) <= m then\n            dbms_output.put('*');\n         else  \n            dbms_output.put(' ');  \n         end if;\n     end loop;\n     dbms_output.new_line();\n   end loop;  \nend;\n\n\n/*\n   游标(光标): 是用来操作查询结果集,相当于是JDBC中ResultSet\n       \n       语法: cursor 游标名[(参数名 参数类型)] is 查询结果集\n       \n       开发步骤:\n           1. 声明游标\n           2. 打开游标       open 游标名\n           3. 从游标中取数据  fetch 游标名 into 变量\n                         游标名%found :找到数据\n                         游标名%notfound : 没有找到数据 \n           4. 关闭游标       close 游标名\n           \n      系统引用游标\n           1. 声明游标 : 游标名 sys_refcursor\n           2. 打开游标: open 游标名 for 结果集\n           3. 从游标中取数据\n           4. 关闭游标\n                \n     for循环遍历游标:\n           不需要声明额外变量\n           不需要打开游标\n           不需要关闭游标      \n*/\n--输出员工表中所有的员工姓名和工资(不带参数游标)\n/*\n   游标:所有员工\n   声明一个变量,用来记录一行数据  %rowtype\n*/\ndeclare\n   --游标\n   cursor vrows is select * from emp;\n   --s声明变量,记录一行数据\n   vrow emp%rowtype;\nbegin\n   --1.打开游标  \n   open vrows;\n   --2.从游标提取数据\n   --循环取数据\n   loop\n       fetch vrows into vrow; \n       exit when vrows%notfound;  \n       dbms_output.put_line('姓名:'||vrow.ename ||' 工资: ' || vrow.sal);\n   end loop;\n   --3.关闭游标\n   close vrows;\nend;\n\n--输出指定部门下的员工姓名和工资\n/*\n   游标: 指定部门的所有员工\n   声明一个变量记录一行数据\n*/\ndeclare\n   --声明游标\n   cursor vrows(dno number) is select * from emp where deptno = dno;\n   --声明变量\n   vrow emp%rowtype;\nbegin\n  --1.打开游标 , 指定10号部门\n  open vrows(10);\n  --2. 循环遍历,取数据\n  loop\n     fetch vrows into vrow;\n     exit when vrows%notfound;    \n      dbms_output.put_line('姓名:'||vrow.ename ||' 工资: ' || vrow.sal);\n  end loop;\n  close vrows;\nend;\n\n--系统引用游标\n--输出员工表中所有的员工姓名和工资\ndeclare\n  --声明系统引用游标\n  vrows sys_refcursor;\n  --声明一个变量\n  vrow emp%rowtype;\nbegin\n  --1.打开游标\n  open vrows for select * from emp;\n  --2.取数据\n  loop\n    fetch vrows into vrow;\n    exit when vrows%notfound;\n     dbms_output.put_line('姓名:'||vrow.ename ||' 工资: ' || vrow.sal);\n  end loop;\n  close vrows;\nend;\n\n--扩展内容----使用for循环遍历游标\ndeclare\n  --声明一个游标\n  cursor vrows is select * from emp;\nbegin\n  for vrow in vrows loop\n     dbms_output.put_line('姓名:'||vrow.ename ||' 工资: ' || vrow.sal || '工作:'|| vrow.job);\n  end loop;\nend;\n\nselect * from emp;\n\n\n\n--按照员工工作给所有员工涨工资,总裁涨1000,经理涨800,其他人涨400\n/*\n    游标 : 所有员工\n    声明一个记录一行数据   \n*/\ndeclare\n   --声明游标\n   cursor vrows is select * from emp;\n   --声明一个变量\n   vrow emp%rowtype; \nbegin\n  --1.打开游标\n  open vrows;\n  --2.循环取数据\n  loop\n       --取数据\n       fetch vrows into vrow;\n       --退出条件\n       exit when vrows%notfound;  \n       --根据不同的职位,涨工资 总裁涨1000,经理涨800,其他人涨400\n       if vrow.job = 'PRESIDENT' then\n          update emp set sal = sal + 1000 where empno = vrow.empno;\n       elsif vrow.job = 'MANAGER' then\n          update emp set sal = sal + 800 where empno = vrow.empno;\n       else\n          update emp set sal = sal + 400 where empno = vrow.empno; \n       end if;       \n  end loop;\n  --3.关闭游标\n  close vrows;\n  --4.提交事务\n  commit;\nend;\n\n\nselect * from emp;\n\n\n/*\n   例外:(意外)程序运行的过程发生异常,相当于是JAVA中的异常\n   \n   declare\n       --声明变量\n   begin\n       --业务逻辑\n   exception\n       --处理异常\n       when 异常1 then\n         ...\n       when 异常2 then\n         ...\n       when others then\n         ...处理其它异常\n   end;\n   \n   zero_divide : 除零异常\n   value_error : 类型转换异常\n   too_many_rows : 查询出多行记录,但是赋值给了rowtype记录一行数据变量\n   no_data_found : 没有找到数据\n       \n   \n   自定义异常:\n       异常名  exception;\n       raise 异常名          \n*/\ndeclare\n   vi number;\n   vrow emp%rowtype;\nbegin\n   --vi := 8/0;  \n   --vi := 'aaa';\n   --select * into vrow from emp;\n   select * into vrow from emp where empno=1234567;\nexception\n  when zero_divide then\n    dbms_output.put_line('发生了除零异常');\n  when value_error then\n     dbms_output.put_line('发生了类型转换异常');\n  when too_many_rows then\n    dbms_output.put_line(' 查询出多行记录,但是赋值给了rowtype记录一行数据变量');\n  when no_data_found then\n    dbms_output.put_line('没有找到数据异常');\n  when others then\n     dbms_output.put_line('发生了其它异常' || sqlerrm);     \nend;\n\n--查询指定编号的员工,如果没有找到,则抛出自定义的异常\n/*\n     --错误的演示\n     \n     1.声明一个变量 %rowtype\n     2.查询员工信息,保存起来\n     3.判断员工信息是否为空\n     4. 如果是 则抛出异常\n*/\ndeclare\n  --   1.声明一个变量 %rowtype\n  vrow emp%rowtype;\n  --2 .声明一个自定义的异常\n  no_emp exception;  \nbegin\n  --查询员工信息,保存起来\n  select * into vrow from emp where empno = 8888;   --抛出异常\n  \n  if vrow.sal is null then\n    raise no_emp; --抛出自定义的异常\n  end if;\nexception\n  when no_emp then\n     dbms_output.put_line('输出了自定义的异常');  \n  when others then\n     dbms_output.put_line('输出了其它异常'||sqlerrm);  \nend;\n\n--查询指定编号的员工,如果没有找到,则抛出自定义的异常\n/*\n     游标来判断\n       %found %notfound\n    声明一个游标\n    声明一个变量,记录数据\n    从游标中取记录\n       如果有,则不管它\n       如果没有就抛出自定义的异常\n*/\ndeclare\n  --声明游标\n  cursor vrows is select * from emp where empno=8888;   \n  --声明一个记录型变量\n  vrow emp%rowtype;\n  --声明一个自定义异常\n  no_emp exception;  \nbegin\n  --1.打开游标\n  open vrows;\n  --2.取数据\n  fetch vrows into vrow;\n  --3.判断游标是否有数据\n  if vrows%notfound then\n    raise no_emp;\n  end if;\n  close vrows;\nexception\n  when no_emp then\n    dbms_output.put_line('发生了自定义的异常');\nend;\n\n\n\n/*\n    存储过程: 实际上是封装在服务器上一段PLSQL代码片断,已经编译好了的代码\n              1.客户端取调用存储过程,执行效率就会非常高效\n         语法:\n              create [or replace] procedure 存储过程的名称(参数名 in|out 参数类型,参数名 in|out 参数类型)\n              is | as\n               --声明部分\n              begin\n               --业务逻辑 \n              end; \n             \n              \n*/\n--给指定员工涨薪,并打印涨薪前和涨薪后的工资\n/*\n    参数 : in 员工编号\n    参数 : in 涨多少\n    \n    声明一个变量 : 存储涨工资前的工资\n    \n    查询出当前是多少\n    打印涨薪前的工资\n    更新工资\n    打印涨薪后的工资          \n*/\ncreate or replace procedure proc_updatesal(vempno in number,vnum in number)\nis\n   --声明变量.记录当前工资\n   vsal number;    \nbegin\n  --查询当前的工资\n  select sal into vsal from emp where empno = vempno;\n  --输出涨薪前的工资\n  dbms_output.put_line('涨薪前:'||vsal);\n  --更新工资\n  update emp set sal = vsal + vnum where empno = vempno;\n  --输出涨薪后的工资\n  dbms_output.put_line('涨薪后:'||(vsal+vnum));\n  --提交\n  commit;\nend;\n\n--方式1\ncall proc_updatesal(7788,10);\n\n--方式2 用的最多的方式\ndeclare\n\nbegin\n  proc_updatesal(7788,-100);\nend;\n\n\n/*\n  存储函数: 实际上是一段封装是Oracle服务器中的一段PLSQL代码片断,它是已经编译好了的代码片段\n        \n        语法: \n             create [or replace] function 存储函数的名称(参数名 in|out 参数类型,参数名 in|out 参数类型) return 参数类型\n             is | as\n             \n             begin\n               \n             end;\n        存储过程和函数的区别:\n             1.它们本质上没有区别\n             2.函数存在的意义是给过程调用   存储过程里面调用存储函数\n             3.函数可以在sql语句里面直接调用\n             4.存储过程能实现的,存储函数也能实现,存储函数能实现的,过程也能实现\n             \n        默认是 in       \n*/\n--查询指定员工的年薪\n/*\n    参数 : 员工的编号\n    返回 : 年薪          \n*/\ncreate or replace function func_getsal(vempno number) return number\nis\n  --声明变量.保存年薪\n  vtotalsal number;     \nbegin\n  select sal*12 + nvl(comm,0) into vtotalsal from emp where empno = vempno;\n  return vtotalsal;\nend;\n\n--调用存储函数\ndeclare\n  vsal number;\nbegin\n  vsal := func_getsal(7788);\n  dbms_output.put_line(vsal);\nend;\n\n\n--查询员工的姓名,和他的年薪\nselect ename,func_getsal(empno) from emp;\n--查询员工的姓名和部门的名称\n\n\n--查询指定员工的年薪--存储过程来实现\n--参数: 员工编号\n--输出: 年薪\ncreate or replace procedure proc_gettotalsal(vempno in number,vtotalsal out number)\nis\n       \nbegin\n  select sal*12 + nvl(comm,0) into vtotalsal from emp where empno = vempno;\nend;\n\n\ndeclare\n  vtotal number;\nbegin\n  proc_gettotalsal(7788,vtotal);\n  dbms_output.put_line('年薪:'||vtotal);\nend;\n\nselect *  from emp where empno = 8888; \n\n/*\n    JAVA调用存储过程\n       JDBC的开发步骤:\n          1.导入驱动包\n          2.注册驱动\n          3.获取连接\n          4.获取执行SQL的statement\n          5.封装参数\n          6.执行SQL\n          7.获取结果\n          8.释放资源   \n*/\n\n/*\n   封装一个存储过程 : 输出所有表中的记录\n   \n   输出类型 : 游标  \n*/\ncreate or replace procedure proc_getemps(vrows out sys_refcursor)\nis\n\nbegin\n  --1.打开游标, 给游标赋值\n  open vrows for select * from emp;\nend;\n\n\n\n/*\n   触发器: 当用户执行了 insert | update | delete 这些操作之后, 可以触发一系列其它的动作/业务逻辑\n       作用 : \n            在动作执行之前或者之后,触发业务处理逻辑\n            插入数据,做一些校验\n            \n       语法:\n           create [or replace] trigger 触发器的名称\n           before | after\n           insert | update | delete \n           on 表名\n           [for each row]\n           declare\n           \n           begin\n             \n           end;\n           \n       触发器的分类:\n           语句级触发器:   不管影响多少行, 都只会执行一次\n           \n           行级触发器:     影响多少行,就触发多少次\n                  :old  代表旧的记录, 更新前的记录\n                  :new  代表的是新的记录\n       \n*/\n--新员工入职之后,输出一句话: 欢迎加入黑马程序员\ncreate or replace trigger tri_test1\nafter\ninsert\non emp\ndeclare\n\nbegin\n  dbms_output.put_line('欢迎加入黑马程序员');\nend;\n\ninsert into emp(empno,ename) values(9527,'HUAAN');\n\n--数据校验, 星期六老板不在, 不能办理新员工入职\n--在插入数据之前\n--判断当前日期是否是周六\n--如果是周六,就不能插入\ncreate or replace trigger tri_test2\nbefore\ninsert \non emp\ndeclare\n --声明变量\n vday varchar2(10);\nbegin\n  --查询当前\n  select trim(to_char(sysdate,'day')) into vday from dual;\n  --判断当前日期:\n  if vday = 'saturday' then\n     dbms_output.put_line('老板不在,不能办理入职');\n     --抛出系统异常\n     raise_application_error(-20001,'老板不在,不能办理入职');\n  end if;\nend;\n\ninsert into emp(empno,ename) values(9528,'HUAAN2');\n\n--更新所有的工资 输出一句话\ncreate or replace trigger tri_test3\nafter\nupdate\non emp \nfor each row\ndeclare\n\nbegin\n  dbms_output.put_line('更新了数据');\nend;\n\nupdate emp set sal = sal+10;\n\n\n\n--判断员工涨工资后的工资一定要大于涨工资前的工资\n/*\n   200 --> 100\n   触发器 : before\n      旧的工资 \n      新的工资\n      如果旧的工资大于新的工资 , 抛出异常,不让它执行成功   \n      \n      \n   触发器中不能提交事务,也不能回滚事务 \n*/\ncreate or replace trigger tri_updatesal\nbefore\nupdate\non emp\nfor each row\ndeclare\n\nbegin\n  if :old.sal > :new.sal then\n    raise_application_error(-20002,'旧的工资不能大于新的工资');\n  end if;\nend;\n\nupdate emp set sal = sal + 10;\nselect * from emp;\n\nupdate emp set sal = sal - 100;\n\n\n/*\n   模拟mysql中ID的自增属性 auto_increment \n   insert into person(null,'张三');  \n   \n   触发器:\n   \n   pid=1  insert  pid=1\n   \n   序列 : create sequence seq_person_pid;       \n*/\ncreate table person(\n    pid number primary key,\n    pname varchar2(20)   \n);\n\ninsert into person values(null,'张三'); \n\ncreate sequence seq_person_pid;\n\n--触发器\ncreate or replace trigger tri_add_person_pid\nbefore\ninsert\non person\nfor each row\ndeclare\n\nbegin\n  dbms_output.put_line(:new.pname);\n  --给新记录 pid 赋值\n  select seq_person_pid.nextval into :new.pid from dual;\nend;\n\ninsert into person values(null,'张三'); \n\n\nselect * from person;\n\n```\n","tags":["Oracle"],"categories":["开发工具"]},{"title":"突破算法第11天-红黑树","url":"/2017/10/30/test2/","content":"** 累了选择休息而不是选择放弃!** <Excerpt in index | 首页摘要>\n红黑树\n<!-- more -->\n<The rest of contents | 余下全文>\n{% blockquote %}\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem.\n{% endblockquote %}\n\n\n\n{% blockquote David Levithan, Wide Awake %}\nDo not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy.\n{% endblockquote %}\n\n\n{% codeblock %}\npublic static void main\n{% endcodeblock %}\n","tags":["开发工具"],"categories":["开发工具"]}]