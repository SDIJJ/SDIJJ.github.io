[{"title":"Java 基础大复习","url":"/2018/10/24/Java基础大复习/","content":" **读书,健身,努力工作,关心身体,保持好心情,成为最棒的自己!**<Excerpt in index | 首页摘要>\n 复习下Java基础!\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n## 1. 内存分析\n\n> Java虚拟机的内存可以分为三个区域:栈stack,堆heap,方法区method area\n\n### 1.1.栈的特点如下:\n\n![1539781422834](/img/1539781422834.png)\n\n###  1.2.堆的特点如下:\n\n![1539781521522](/img/1539781521522.png)\n\n### 1,3.方法区特点如下:\n\n![1539781599776](/img/1539781599776.png)\n\n### 1.4.分析流程\n\n![1539782448438](/img/1539782448438.png)     \n## 2. Java垃圾回收机制(Garbage Collection)\n\n### 2.1.垃圾回收算法: \n\n> * 引用计数法\n> * 引用可达法(根搜索算法)\n\n### 2.2.分代垃圾回收机制\n\n> * 年轻代\n> * 年老代\n> * 持久代\n\n## 3.StringBuilder和StringBuffer的主要区别:StringBuffer方法用synchronized修饰\n\n## 3.关于包装类的缓存问题\n\n```java\nInteger d=1234;\nINteget d1=1234;\nSystem.out.print(d==d1);     //结果false;\nSystem.out.print(d.equals(d1));    //结果:true\n\nInteger d2=123;\nIngeger d3=123;\nSystem.out.print(d2==d3);            //结果:true;        [-128,127]之间数.仍然当基本类型来处理\nSystem.out.print(d2.equals(d3));     //结果:true\n\n```\n\n## 4.容器\n\n### 4.1 接口层次示意图\n\n![1539949593458](C:\\Users\\JIA\\AppData\\Roaming\\Typora\\typora-user-images\\1539949593458.png)\n\n> ​               Collection                                                Map\n>\n> ​                /                  \\ \t\t\t\t\t\t    |\n>\n> ​          Set                  List                                         HashMap\n>\n> ​          |                        |            \\\n>\n> ​         HashSet          ArrayList      LinkedList\n### 4.1 List接口\n\n>有序的Collection，此接口的用户可以成对列表中的每个元素的插入位置进行精确的定位，用户可\n>以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表当中的元素。\n> 与set不同，列表通常允许重复的元素，更精确的讲列表通常允许满足e1.equals(e2)条件的元素e1，e2并存，并且如果列表本身允许null元素的话，通常他们允许多个null元素。\n\n#### 4.1.1 常用的三个子类\n\n> * ArrayList  : 底层实现原理Object数组   查询快,修改,插入,删除慢\n>\n> * LinkedList :   底层实现链表      查询慢.修改,插入,删除快\n>\n> * Vector: 线程安全 ,效率低\n>\n> * ```java\n>   List list= Collections.synchronizedList(new ArrayList());// 线程安全 \n>   ```\n#### 4.1.2 自己动手模拟ArrayList\n```java\npackage collection;\n\nimport java.util.*;\n\n/**\n * 自己实现ArrayList\n */\npublic class MyArrayList {\n    private Object[] elements;\n    private int size;\n\n    public int size() {\n        return this.size;\n    }\n\n    MyArrayList() {\n        this(10);\n    }\n\n    MyArrayList(int space) {\n        elements = new Object[space];\n    }\n\n    public void add(Object obj) {\n        if (size == elements.length) {\n            Object[] newElements = new Object[2 * size + 2];\n            System.arraycopy(elements, 0, newElements, 0, elements.length);\n            elements = newElements;\n        }\n        elements[size++] = obj;\n    }\n\n    public boolean isEmpty() {\n        return size == 0;\n    }\n\n    public Object get(int index) {\n        rangeCheck(index);\n        return elements[index];\n\n    }\n\n    public void remove(int index) {\n        rangeCheck(index);\n        System.arraycopy(elements, index + 1, elements, index, elements.length - index - 1);\n        size--;\n    }\n\n    public void remove(Object obj) {\n        for (int i = 0; i < size; i++)\n            if (get(i).equals(obj))\n                remove(i);\n    }\n\n    public Object set(int index, Object obj) {\n        rangeCheck(index);\n        Object o = elements[index];\n        elements[index] = obj;\n        return o;\n    }\n\n    public void add(int index, Object obj) {\n        rangeCheck(index);\n        System.arraycopy(elements, index, elements, index + 1, elements.length - index);\n        elements[index] = obj;\n        size++;\n    }\n\n    private void rangeCheck(int index) {\n        if (index < 0 || index >= size)\n            throw new ArrayIndexOutOfBoundsException();\n    }\n\n    public static void main(String[] args) {\n        MyArrayList list = new MyArrayList();\n        list.add(\"111\");\n        list.add(\"222\");\n        list.remove(\"111\");\n        System.out.println(list.size);\n        System.out.println(list.get(0));\n        list.set(0, \"3333\");\n        System.out.println(list.get(0));\n//        System.out.println(list.get(14));\n//        System.out.println(list.size());\n    }\n}\n\n```\n\n#### 4.1.3自己动手模拟LinkedList\n\n```java\npackage collection;\n\npublic class MyLinkedList {\n    private Node first;\n    private Node last;\n    private int size;\n\n    public int size() {\n        return size;\n    }\n\n    public boolean isEmpty() {\n        return size == 0;\n    }\n\n    public void add(Object obj) {\n        Node n = new Node();\n        n.setObj(obj);\n        if (first == null) {\n            first = n;\n            last = n;\n        } else {\n            last.setNextNode(n);\n            n.setPreNode(last);\n            last = n;\n        }\n        size++;\n    }\n\n    private void rangeCheck(int index) {\n        if (index >= size || index < 0)\n            throw new ArrayIndexOutOfBoundsException();\n    }\n\n    public Object get(int index) {\n        rangeCheck(index);\n        return node(index).getObj();\n    }\n\n    public void remove(int index) {\n\n        Node n = node(index);\n        Node up = n.getPreNode();\n        Node down = n.getNextNode();\n        up.setNextNode(down);\n        down.setPreNode(up);\n//        n.getPreNode().setNextNode(n.getNextNode());\n//        n.getNextNode().setPreNode(n.getPreNode());\n        size--;\n    }\n\n    private Node node(int index) {\n        if (first != null) {\n            Node temp = first;\n            for (int i = 0; i < index; i++)\n                temp = temp.getNextNode();\n            return temp;\n        }\n        return null;\n    }\n\n    public void add(int index, Object obj) {\n        rangeCheck(index);\n        Node newNode = new Node();\n        newNode.setObj(obj);\n        Node n = node(index);\n        Node up = n.getPreNode();\n        up.setNextNode(newNode);\n        newNode.setPreNode(up);\n        newNode.setNextNode(n);\n        n.setPreNode(newNode);\n        size++;\n    }\n\n\n    public static void main(String[] args) {\n        MyLinkedList list = new MyLinkedList();\n        list.add(\"111\");\n        list.add(\"222\");\n        list.add(\"333\");\n        list.add(1, \"AAA\");\n        System.out.println(list.size());\n        System.out.println(list.get(1));\n    }\n}\n\nclass Node {\n    private Node preNode;\n    private Object obj;\n    private Node nextNode;\n\n    public Node(Node preNode, Object obj, Node nextNode) {\n        this.preNode = preNode;\n        this.obj = obj;\n        this.nextNode = nextNode;\n    }\n\n    public Node() {\n    }\n\n    ;\n\n    public Node getPreNode() {\n        return preNode;\n    }\n\n    public void setPreNode(Node preNode) {\n        this.preNode = preNode;\n    }\n\n    public Object getObj() {\n        return obj;\n    }\n\n    public void setObj(Object obj) {\n        this.obj = obj;\n    }\n\n    public Node getNextNode() {\n        return nextNode;\n    }\n\n    public void setNextNode(Node nextNode) {\n        this.nextNode = nextNode;\n    }\n}\n\n```\n\n### 4.2Map \n\n> 实现原理:数组+链表\n\n#### 4.2.1常用实现类:\n\n> * HashMap       快,不安全\n> * HashTable      慢,安全\n\n#### 4.2.2 HashMap 的简单模拟\n\n```java\npackage collection;\n\nimport java.util.LinkedList;\n\n\npublic class MyMap {\n\n    private LinkedList[] arr = new LinkedList[999];\n    private int size;\n\n    public int size() {\n        return size;\n    }\n\n    public boolean isEmpty() {\n        return size == 0;\n    }\n\n    public void put(Object key, Object value) {\n        MyEntry entry = new MyEntry();\n        entry.value = value;\n        entry.key = key;\n        int hashKey = key.hashCode() % arr.length;\n        if (arr[hashKey] == null) {\n            arr[hashKey] = new LinkedList();\n            arr[hashKey].add(entry);\n            size++;\n        } else {\n            for (int i = 0; i < arr[hashKey].size(); i++) {\n                MyEntry e = ((MyEntry) arr[hashKey].get(i));\n                if (e.value.equals(value)) {\n                    e.value = value;\n                    return;\n                }\n                arr[hashKey].add(entry);\n                size++;\n            }\n        }\n    }\n\n    public Object get(Object key) {\n        int hashKey = key.hashCode() % arr.length;\n        for (int i = 0; i < arr[hashKey].size(); i++) {\n            MyEntry e = ((MyEntry) arr[hashKey].get(i));\n            if (e.key.equals(key))\n                return e.value;\n        }\n        return null;\n    }\n\n\n    public static void main(String[] args) {\n        MyMap map = new MyMap();\n        map.put(\"111\", \"wewe\");\n        map.put(\"222\", \"wewe1\");\n        map.put(\"333\", \"wewe2\");\n        map.put(\"444\", \"wewe2\");\n        map.put(\"555\", \"wewe2\");\n        System.out.println(map.size());\n        System.out.println(map.get(\"111\"));\n    }\n\n}\nclass MyEntry {\n    Object key;\n    Object value;\n}\n```\n\n#### 4.2.3 如果两个对象内容相同(equals为true),那么他们的hash一定相同\n\n### 4.3 Set \n\n> HashSet :底层用HashMap实现 \n\n### 5.线程\n\n#### 5.1多线程(多线程并行和并发的区别)(了解)\n\n* 并行就是两个任务同时运行，就是甲任务进行的同时，乙任务也在进行。(需要多核CPU)\n* 并发是指两个任务都请求运行，而处理器只能按受一个任务，就把这两个任务安排轮流进行，由于时间间隔较短，使人感觉两个任务都在运行。\n* 比如我跟两个网友聊天，左手操作一个电脑跟甲聊，同时右手用另一台电脑跟乙聊天，这就叫并行。\n* 如果用一台电脑我先给甲发个消息，然后立刻再给乙发消息，然后再跟甲聊，再跟乙聊。这就叫并发。\n\n#### 5.2JVM启动是多线程的(至少启动一个主线程和垃圾管理线程)\n\n#### 5.3多线程(Java程序运行原理和JVM的启动是多线程的吗)(了解)\n* A:Java程序运行原理\n  * Java命令会启动java虚拟机，启动JVM，等于启动了一个应用程序，也就是启动了一个进程。该进程会自动启动一个 “主线程” ，然后主线程去调用某个类的 main 方法。\n\n* B:JVM的启动是多线程的吗\n  * JVM启动至少启动了垃圾回收线程和主线程，所以是多线程的。\n\n* 继承Thread\n  * 好处是:可以直接使用Thread类中的方法,代码简单\n  * 弊端是:如果已经有了父类,就不能用这种方法\n* 实现Runnable接口\n  * 好处是:即使自己定义的线程类有了父类也没关系,因为有了父类也可以实现接口,而且接口是可以多实现的\n  * 弊端是:不能直接使用Thread中的方法需要先获取到线程对象后,才能得到Thread的方法,代码复杂\n\n#### 5,4线程匿名内部类的实现\n\n```java\npackage thread;\n\npublic class Demo03 {\n    public static void main(String[] args) {\n        new Thread(){\n            @Override\n            public void run() {\n                for(int i=0;i<1111;i++)\n                    System.out.println(\"aaaa\");\n            }\n        }.start();\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                for (int i = 0; i < 11111; i++) {\n                    System.out.println(\"b\");\n                }            }\n        }).start();\n    }\n}\n```\n\n#### 5.4 Sleep (不解释)\n\n#### 5.5 守护线程(被人挂掉自己也挂掉)\n\n> 比如: QQ正在传输文件(守护线程),关闭QQ程序文件传输马上停止.\n\n```java\npackage thread;\n\npublic class Demo05 {\n    public static void main(String[] args) {\n        Thread t1 = new Thread() {\n            @Override\n            public void run() {\n                for (int i = 0; i < 20; i++)\n                    System.out.println(\"aaaaa\");\n            }\n        };\n        Thread t2 = new Thread() {\n            @Override\n            public void run() {\n                for (int i = 0; i < 50; i++) {\n                    System.out.println(i + \" bb\");\n                }\n            }\n        };\n        t2.setDaemon(true);\n        t1.start();\n        t2.start();\n    }\n}\n\n```\n\n#### 5.6 join(插队)(join执行完其他线程再执行)\n\n* join(), 当前线程暂停, 等待指定的线程执行结束后, 当前线程再继续\n* join(int), 可以等待指定的毫秒之后继续(插队int毫秒)\n\n```java\npackage thread;\n\npublic class Demo06 {\n    public static void main(String[] args) {\n        final  Thread t1=new Thread(){\n            @Override\n            public void run() {\n                for (int i = 0; i <30 ; i++) {\n                    System.out.println(\"线程111\");\n                }\n            }\n        };\n        Thread t2=new Thread(){\n            @Override\n            public void run() {             \n                for (int i = 0; i <30 ; i++) {\n                    if(i>10) {\n                        try {\n                            t1.join();\n                        } catch (InterruptedException e) {\n                            e.printStackTrace();\n                        }\n                    }\n                    System.out.println(\"线程222\");\n                }\n            }\n        };\n         t1.start();\n         t2.start();\n    }\n}\n\n```\n\n#### 5.7 yield(礼让线程)\n\n> 让其他线程先执行\n\n####  5.8优先级(任然交替执行线程,但是优先级高的线程执行次数更多)\n\n> setPriority(1~10);\n\n#### 5.9Synchronized\n\n> * ``` Synchronized(对象){ }  ```      :同步代码块,可以传任意对象,但是必须是同一个对象\n> * ``` public Synchronized void method()  ```     :非静态的同步所对象是this\n> * ``` public static Synchronized void method()``` : 静态的同步方法使用的所对象是字节码对象(类名.class)\n\n#### 5.10死锁(哲学家进餐问题)\n\n> 为了避免死锁:尽量Synchronized 嵌套\n\n```java\npackage thread;\n\npublic class Demo07 {\n    private static Object s2 = \"筷子2\";\n    private static Object s1 = \"筷子1\";\n\n    public static void main(String[] args) {\n\n        new Thread() {\n            @Override\n            public void run() {\n                while (true) {\n                    synchronized (s1) {\n                        System.out.println(getName() + \":拿到s1\");\n                        synchronized (s2) {\n                            System.out.println(getName() + \":拿到s2   哲学家开始吃饭\");\n                        }\n                    }\n                }\n            }\n        }.start();\n        new Thread() {\n            @Override\n            public void run() {\n                while (true) {\n                    synchronized (s2) {\n                        System.out.println(getName() + \":拿到s2\");\n                        synchronized (s1) {\n                            System.out.println(getName() + \":拿到s1   哲学家开始吃饭\");\n                        }\n                    }\n                }\n            }\n        }.start();\n    }\n}\n```\n\n#### 5.11 三种单例设计模式\n\n> jdk中单例模式的类:Runtime,Timer\n\n#### 5.12线程之间的通讯\n\n> * wait() 当前线程等待\n> * notify() 随机唤醒一个等待的线程\n> * notifyAll()   唤醒所有等待线程\n\n```java\npackage thread;\n\npublic class Demo09 {\n    public static void main(String[] args) {\n        test t = new test();\n        new Thread() {\n            @Override\n            public void run() {\n                while (true)\n                    t.method();\n            }\n        }.start();\n        new Thread() {\n            @Override\n            public void run() {\n                while (true)\n\n                    t.method2();\n            }\n        }.start();\n    }\n}\n\nclass test {\n    private boolean flag;\n\n    public synchronized void method() {\n        if (flag != true) {\n            try {\n                this.wait();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        System.out.println(\"111111\");\n        flag = false;\n        this.notify();\n    }\n\n    public synchronized void method2() {\n        if (flag != false) {\n            try {\n                this.wait();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        System.out.println(\"222222\");\n        flag = true;\n        this.notify();\n    }\n}\n```\n\n#### 5.12ReentrantLock\n\n#### 5.13 线程组\n\n#### 5.14线程的五种状态\n\n![1540126331767](C:\\Users\\JIA\\AppData\\Roaming\\Typora\\typora-user-images\\1540126331767.png)\n\n#### 5.15线程池\n\n> 创建线程时需要耗费许多资源,线程池可以先创建几个线程,其他线程需要就过来用\n>\n>  **ExecutorService pool = Executors.newFixedThreadPool(2);**\n\n```java\npackage thread;\n\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class Demo10 {\n    public static void main(String[] args) {\n        ExecutorService pool = Executors.newFixedThreadPool(2);\n        pool.submit(new Runnable() {\n            @Override\n            public void run() {\n                for (int i = 0; i < 10; i++)\n                    System.out.println(Thread.currentThread().getName() + \"   \" + i);\n            }\n        });\n        pool.submit(new Runnable() {\n            @Override\n            public void run() {\n                for (int i = 0; i < 10; i++)\n                    System.out.println(Thread.currentThread().getName() + \"   \" + i);\n            }\n        });\n        pool.submit(new Runnable() {\n            @Override\n            public void run() {\n                for (int i = 0; i < 10; i++)\n                    System.out.println(Thread.currentThread().getName() + \"   \" + i);\n            }\n        });\n        pool.submit(new Runnable() {\n            @Override\n            public void run() {\n                for (int i = 0; i < 10; i++)\n                    System.out.println(Thread.currentThread().getName() + \"   \" + i);\n            }\n        });\n        pool.shutdownNow();\n    }\n}\n\n```\n\n#### 5.15 Callable\n\n> 线程的第三种实现方法\n\n```java\n// 创建线程池对象\n\t\tExecutorService pool = Executors.newFixedThreadPool(2);\n\n\t\t// 可以执行Runnable对象或者Callable对象代表的线程\n\t\tFuture<Integer> f1 = pool.submit(new MyCallable(100));\n\t\tFuture<Integer> f2 = pool.submit(new MyCallable(200));\n\t\n\t\t// V get()\n\t\tInteger i1 = f1.get();\n\t\tInteger i2 = f2.get();\n\t\n\t\tSystem.out.println(i1);\n\t\tSystem.out.println(i2);\n\t\n\t\t// 结束\n\t\tpool.shutdown();\n\t\n\t\tpublic class MyCallable implements Callable<Integer> {\n\t\n\t\t\tprivate int number;\n\t\t\n\t\t\tpublic MyCallable(int number) {\n\t\t\t\tthis.number = number;\n\t\t\t}\n\t\t\n\t\t\t@Override\n\t\t\tpublic Integer call() throws Exception {\n\t\t\t\tint sum = 0;\n\t\t\t\tfor (int x = 1; x <= number; x++) {\n\t\t\t\t\tsum += x;\n\t\t\t\t}\n\t\t\t\treturn sum;\n\t\t\t}\n\t\t\n\t\t}\n```\n\n### 6.反射\n\n#### 6.1 获取Class的三种方式\n\n> * 根据类名\n> * 根据class\n> * 根据对象的实例\n\n![154018482338](C:\\Users\\JIA\\AppData\\Roaming\\Typora\\typora-user-images\\154018482338.png)\n\n```java\npackage reflect;\n\npublic class Demo01 {\n    public static void main(String[] args) throws ClassNotFoundException {\n        Class clazz1 = Class.forName(\"reflect.Student\");\n        Class clazz2 = Student.class;\n        Student s = new Student();\n        Class clazz3 = s.getClass();\n        System.out.println(clazz1 == clazz2);\n        System.out.println(clazz1 == clazz3);\n    }\n}\n\nclass Student {\n}\n```\n\n#### 6.2 反射+配置 实现动态调用\n\n```properties\nreflect.Orange\n```\n\n```java\npackage reflect;\n\nimport java.io.BufferedReader;\nimport java.io.FileReader;\n\npublic class Demo02 {\n    public static void main(String[] args) throws Exception {\n        BufferedReader br = new BufferedReader(new FileReader(\"E:\\\\idea_workSpace\\\\java_review\\\\src\\\\fruit.properties\"));\n        Class clazz = Class.forName(br.readLine());\n\n        zzj z = new zzj();\n        z.run((Fruit) clazz.newInstance());\n    }\n}\n\nclass zzj {\n    public void run(Fruit r) {\n        r.juice();\n    }\n}\n\nclass Apple extends Fruit {\n    public void juice() {\n        System.out.println(\"苹果汁...\");\n    }\n}\n\nclass Orange extends Fruit {\n    public void juice() {\n        System.out.println(\"橘子汁...\");\n    }\n}\n\nclass Banana extends Fruit {\n    public void juice() {\n        System.out.println(\"香蕉汁...\");\n    }\n}\n\nclass Fruit {\n    public void juice() {\n    }\n}\n\n```\n\n#### 6.3 反射可以拿到私有的属性,方法\n\n#### 6.4 使用反射对泛型进行擦除\n\n````java\npackage reflect;\n\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Demo04 {\n    public static void main(String[] args) throws Exception {\n        List<Integer> list = new ArrayList();\n        list.add(111);\n        list.add(222);\n        System.out.println(list);\n        Class clazz = Class.forName(\"java.util.ArrayList\");\n        Method method = clazz.getMethod(\"add\", Object.class);\n        method.invoke(list, \"aaaa \");\n        System.out.println(list);\n    }\n}\n\n````\n\n#### 6.4 jdk 1,8后接口可以创建普通可执行方法,也可以创建静态方法\n\n```java\npackage reflect;\n\npublic class Demo05 {\n    public static void main(String[] args) {\n\n        new Inter() {\n\n        }.print();\n        Inter.print2();\n    }\n}\n\ninterface Inter {\n    default void print() {\n        System.out.println(\"jdk1.8 新特性\");\n\n    }\n\n    static void print2() {\n        System.out.println(\"jdk1.8 lllllllllllllll\");\n    }\n}\n\n```\n\n### 7.Socket(码头)\n\n#### 7.1 Socket进行消息通信\n\n>\n>1.发送Send\n>\n>- 创建DatagramSocket, 随机端口号\n>- 创建DatagramPacket, 指定数据, 长度, 地址, 端口\n>- 使用DatagramSocket发送DatagramPacket\n>- 关闭DatagramSocket\n>\n>\n>2.接收Receive\n>\n>- 创建DatagramSocket, 指定端口号\n>- 创建DatagramPacket, 指定数组, 长度\n>- 使用DatagramSocket接收DatagramPacket\n>- 关闭DatagramSocket\n>- 从DatagramPacket中获取数据\n>\n\n```java\npackage socket;\n\nimport javax.xml.crypto.Data;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\n/**\n * 1.发送Send\n\n - 创建DatagramSocket, 随机端口号\n - 创建DatagramPacket, 指定数据, 长度, 地址, 端口\n - 使用DatagramSocket发送DatagramPacket\n - 关闭DatagramSocket\n */\npublic class Send {\n    public static void main(String[] args) throws  Exception{\n        String msg=\"正在学习socket编程\";\n        DatagramSocket socket =new DatagramSocket();\n        DatagramPacket  packet=new\n                DatagramPacket(msg.getBytes(),msg.getBytes().length,\n                InetAddress.getLocalHost(),8888);\n        socket.send(packet);\n        socket.close();\n    }\n\n}\n\n```\n\n```java\npackage socket;\n\n\n\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\n/**\n * 2.接收Receive\n\n - 创建DatagramSocket, 指定端口号\n - 创建DatagramPacket, 指定数组, 长度\n - 使用DatagramSocket接收DatagramPacket\n - 关闭DatagramSocket\n - 从DatagramPacket中获取数据\n */\npublic class Receive {\n\n    public static void main(java.lang.String[] args) throws  Exception{\n        byte [] arr=new byte[1024];\n        DatagramSocket socket=new DatagramSocket(8888);\n        DatagramPacket packet=new DatagramPacket(arr,arr.length);\n        socket.receive(packet);\n        byte [] arr2=packet.getData();\n        int len=packet.getLength();\n        System.out.println(new java.lang.String(arr2,0,len));\n        socket.close();\n    }\n}\n\n```\n\n\n\n\n\n\n\n\n\n### 8.异常(Exception)\n\n﻿#### 8.01_异常(异常的概述和分类)\n* A:异常的概述\n  * 异常就是Java程序在运行过程中出现的错误。\n* B:异常的分类\n  * 通过API查看Throwable\n  * Error\n    * 服务器宕机,数据库崩溃等\n  * Exception\n    C:异常的继承体系\n  * Throwable\n    * Error\t\n    * Exception\n      * RuntimeException\n\n#### 8.02_异常(JVM默认是如何处理异常的)\n* A:JVM默认是如何处理异常的\n  * main函数收到这个问题时,有两种处理方式:\n  * a:自己将该问题处理,然后继续运行\n  * b:自己没有针对的处理方式,只有交给调用main的jvm来处理\n  * jvm有一个默认的异常处理机制,就将该异常进行处理.\n  * 并将该异常的名称,异常的信息.异常出现的位置打印在了控制台上,同时将程序停止运行\n* B:案例演示\n  * JVM默认如何处理异常\n\n#### 8.03_异常(try...catch的方式处理异常1)\n* A:异常处理的两种方式\n  * a:try…catch…finally\n    * try catch\n    * try catch finally\n    * try finally \n  * b:throws\n* B:try...catch处理异常的基本格式\n  * try…catch…finally\n* C:案例演示\n  * try...catch的方式处理1个异常\n\n#### 8.04_异常(try...catch的方式处理异常2)\n* A:案例演示\n  * try...catch的方式处理多个异常\n  * JDK7以后处理多个异常的方式及注意事项\n\n#### 8.05_异常(编译期异常和运行期异常的区别)\n* A:编译期异常和运行期异常的区别\n  * Java中的异常被分为两大类：编译时异常和运行时异常。\n  * 所有的RuntimeException类及其子类的实例被称为运行时异常，其他的异常就是编译时异常\n\n  * 编译时异常\n    * Java程序必须显示处理，否则程序就会发生错误，无法通过编译\n  * 运行时异常\n    * 无需显示处理，也可以和编译时异常一样处理\n* B:案例演示\n  * 编译期异常和运行期异常的区别\n\n#### 8.06_异常(Throwable的几个常见方法)\n* A:Throwable的几个常见方法\n  * a:getMessage()\n    * 获取异常信息，返回字符串。\n  * b:toString()\n    * 获取异常类名和异常信息，返回字符串。\n  * c:printStackTrace()\n    * 获取异常类名和异常信息，以及异常出现在程序中的位置。返回值void。\n* B:案例演示\n  * Throwable的几个常见方法的基本使用\n\n#### 8.07_异常(throws的方式处理异常)\n* A:throws的方式处理异常\n  * 定义功能方法时，需要把出现的问题暴露出来让调用者去处理。\n  * 那么就通过throws在方法上标识。\n* B:案例演示\n  * 举例分别演示编译时异常和运行时异常的抛出\n\n#### 8.08_异常(throw的概述以及和throws的区别)\n* A:throw的概述\n  * 在功能方法内部出现某种情况，程序不能继续运行，需要进行跳转时，就用throw把异常对象抛出。\n* B:案例演示\t\n  * 分别演示编译时异常对象和运行时异常对象的抛出\n* C:throws和throw的区别\n  * a:throws\n    * 用在方法声明后面，跟的是异常类名\n    * 可以跟多个异常类名，用逗号隔开\n    * 表示抛出异常，由该方法的调用者来处理\n  * b:throw\n    * 用在方法体内，跟的是异常对象名\n    * 只能抛出一个异常对象名\n    * 表示抛出异常，由方法体内的语句处理\n\n#### 8.09_异常(finally关键字的特点及作用)\n* A:finally的特点\n  * 被finally控制的语句体一定会执行\n  * 特殊情况：在执行到finally之前jvm退出了(比如System.exit(0))\n* B:finally的作用\n  * 用于释放资源，在IO流操作和数据库操作中会见到\n* C:案例演示\n  * finally关键字的特点及作用\n\n#### 8.10_异常(finally关键字的面试题)\n* A:面试题1\n  * final,finally和finalize的区别\n* B:面试题2\n  * 如果catch里面有return语句，请问finally的代码还会执行吗?如果会，请问是在return前还是return后。\n\n#### 8.11_异常(自定义异常概述和基本使用)\n* A:为什么需要自定义异常\n  * 举例：人的年龄\n* B:自定义异常概述\n  * 继承自Exception\n  * 继承自RuntimeException\n* C:案例演示\n  * 自定义异常的基本使用\n\n#### 8.12_异常(异常的注意事项及如何使用异常处理)\n* A:异常注意事项\n  * a:子类重写父类方法时，子类的方法必须抛出相同的异常或父类异常的子类。(父亲坏了,儿子不能比父亲更坏)\n  * b:如果父类抛出了多个异常,子类重写父类时,只能抛出相同的异常或者是他的子集,子类不能抛出父类没有的异常\n  * c:如果被重写的方法没有异常抛出,那么子类的方法绝对不可以抛出异常,如果子类方法内有异常发生,那么子类只能try,不能throws\n* B:如何使用异常处理\n  * 原则:如果该功能内部可以将问题处理,用try,如果处理不了,交由调用者处理,这是用throws\n  * 区别:\n    * 后续程序需要继续运行就try\n    * 后续程序不需要继续运行就throws\n\n  * 如果JDK没有提供对应的异常，需要自定义异常。\n\n#### 8.13_异常(练习)\n* 键盘录入一个int类型的整数,对其求二进制表现形式\n   * 如果录入的整数过大,给予提示,录入的整数过大请重新录入一个整数BigInteger\n    * 如果录入的是小数,给予提示,录入的是小数,请重新录入一个整数\n    * 如果录入的是其他字符,给予提示,录入的是非法字符,请重新录入一个整数\n\n### 9.File\n#### 9.1_File类(File类的概述和构造方法)\n* A:File类的概述\n  * File更应该叫做一个路径\n    * 文件路径或者文件夹路径  \n    * 路径分为绝对路径和相对路径\n    * 绝对路径是一个固定的路径,从盘符开始\n    * 相对路径相对于某个位置,在eclipse下是指当前项目下,在dos下\n  * 查看API指的是当前路径\n  * 文件和目录路径名的抽象表示形式\n* B:构造方法\n  * File(String pathname)：根据一个路径得到File对象\n  * File(String parent, String child):根据一个目录和一个子文件/目录得到File对象\n  * File(File parent, String child):根据一个父File对象和一个子文件/目录得到File对象\n* C:案例演示\n  * File类的构造方法\n\n#### 9.2_File类(File类的创建功能)\n* A:创建功能\n  * public boolean createNewFile():创建文件 如果存在这样的文件，就不创建了\n  * public boolean mkdir():创建文件夹 如果存在这样的文件夹，就不创建了\n  * public boolean mkdirs():创建文件夹,如果父文件夹不存在，会帮你创建出来\n* B:案例演示\n  * File类的创建功能\n\n  * 注意事项：\n    * 如果你创建文件或者文件夹忘了写盘符路径，那么，默认在项目路径下。\n\n#### 9.3_File类(File类的重命名和删除功能)\n* A:重命名和删除功能\n  * public boolean renameTo(File dest):把文件重命名为指定的文件路径\n  * public boolean delete():删除文件或者文件夹\n* B:重命名注意事项\n  * 如果路径名相同，就是改名。\n  * 如果路径名不同，就是改名并剪切。\n* C:删除注意事项：\n  * Java中的删除不走回收站。\n  * 要删除一个文件夹，请注意该文件夹内不能包含文件或者文件夹\n\n\n#### 9.4_File类(File类的判断功能)\n* A:判断功能\n  * public boolean isDirectory():判断是否是目录\n  * public boolean isFile():判断是否是文件\n  * public boolean exists():判断是否存在\n  * public boolean canRead():判断是否可读\n  * public boolean canWrite():判断是否可写\n  * public boolean isHidden():判断是否隐藏\n* B:案例演示\n  * File类的判断功能\n\n#### 9.5_File类(File类的获取功能)\n* A:获取功能\n  * public String getAbsolutePath()：获取绝对路径\n  * public String getPath():获取路径\n  * public String getName():获取名称\n  * public long length():获取长度。字节数\n  * public long lastModified():获取最后一次的修改时间，毫秒值\n  * public String[] list():获取指定目录下的所有文件或者文件夹的名称数组\n  * public File[] listFiles():获取指定目录下的所有文件或者文件夹的File数组 \n* B:案例演示\n  * File类的获取功能\n\n#### 9.6_File类(输出指定目录下指定后缀的文件名)\n* A:案例演示\n  * 需求：判断E盘目录下是否有后缀名为.jpg的文件，如果有，就输出该文件名称\n\n#### 9.7_File类(文件名称过滤器的概述及使用)\n* A:文件名称过滤器的概述\n  * public String[] list(FilenameFilter filter)\n  * public File[] listFiles(FileFilter filter)\n* B:文件名称过滤器的使用\n  * 需求：判断E盘目录下是否有后缀名为.jpg的文件，如果有，就输出该文件名称\n* C:源码分析\n  * 带文件名称过滤器的list()方法的源码\n\n### 10.IO\n\n####   10.01_IO流(IO流概述及其分类)\n\n* 1.概念\n  * IO流用来处理设备之间的数据传输\n  * Java对数据的操作是通过流的方式\n  * Java用于操作流的类都在IO包中\n  * 流按流向分为两种：输入流，输出流。\n  * 流按操作类型分为两种：\n    * 字节流 : 字节流可以操作任何数据,因为在计算机中任何数据都是以字节的形式存储的\n    * 字符流 : 字符流只能操作纯字符数据，比较方便。\n* 2.IO流常用父类\n  * 字节流的抽象父类：\n    * InputStream \n    * OutputStream\n  * 字符流的抽象父类：\n    * Reader \n    * Writer\t\t\n* 3.IO程序书写\n  * 使用前，导入IO包中的类\n  * 使用时，进行IO异常处理\n  * 使用后，释放资源\n\n####   10.02_IO流(FileInputStream)\n\n* read()一次读取一个字节\n* \n   FileInputStream fis = new FileInputStream(\"aaa.txt\");\t//创建一个文件输入流对象,并关联aaa.txt\n   ​\tint b;\t\t\t\t\t\t\t\t\t\t\t\t\t//定义变量,记录每次读到的字节\n   ​\twhile((b = fis.read()) != -1) {\t\t\t\t\t\t\t//将每次读到的字节赋值给b并判断是否是-1\n   ​\t\tSystem.out.println(b);\t\t\t\t\t\t\t\t//打印每一个字节\n   ​\t}\n   ​\t\n   ​\tfis.close();\t\t\t\t\t\t\t\t\t\t\t//关闭流释放资源\n\n####   10.03_IO流(read()方法返回值为什么是int)\n* read()方法读取的是一个字节,为什么返回是int,而不是byte\n* 因为字节输入流可以操作任意类型的文件,比如图片音频等,这些文件底层都是以二进制形式的存储的,如果每次读取都返回byte,有可能在读到中间的时候遇到111111111\n   ​\t那么这11111111是byte类型的-1,我们的程序是遇到-1就会停止不读了,后面的数据就读不到了,所以在读取的时候用int类型接收,如果11111111会在其前面补上\n   ​\t24个0凑足4个字节,那么byte类型的-1就变成int类型的255了这样可以保证整个数据读完,而结束标记的-1就是int类型\n####  10.04_IO流(FileOutputStream)\n* write()一次写出一个字节\n* FileOutputStream fos = new FileOutputStream(\"bbb.txt\");\t//如果没有bbb.txt,会创建出一个\n   ​\t//fos.write(97);\t\t\t\t\t\t//虽然写出的是一个int数,但是在写出的时候会将前面的24个0去掉,所以写出的是一个byte\n   ​\tfos.write(98);\n   ​\tfos.write(99);\n   ​\tfos.close();\n\n####   10.05_IO流(FileOutputStream追加)\n* A:案例演示\n\n  * FileOutputStream的构造方法写出数据如何实现数据的追加写入\n* \n   FileOutputStream fos = new FileOutputStream(\"bbb.txt\",true);\t//如果没有bbb.txt,会创建出一个\n   ​\t//fos.write(97);\t\t\t\t\t\t//虽然写出的是一个int数,但是在写出的时候会将前面的24个0去掉,所以写出的一个byte\n   ​\tfos.write(98);\n   ​\tfos.write(99);\n   ​\tfos.close();\n\n####   10.06_IO流(拷贝图片)\n* FileInputStream读取\n* FileOutputStream写出\n\n   FileInputStream fis = new FileInputStream(\"致青春.mp3\");\t//创建输入流对象,关联致青春.mp3\n   ​\tFileOutputStream fos = new FileOutputStream(\"copy.mp3\");//创建输出流对象,关联copy.mp3\n   ​\t\n   ​\tint b;\n   ​\twhile((b = fis.read()) != -1) {\n   ​\t\tfos.write(b);\n   ​\t}\n   ​\t\n   ```java\n   fis.close();\n   fos.close();\n   ```\n\n\n####  10.07_IO流(拷贝音频文件画原理图)\n* A:案例演示\n  * 字节流一次读写一个字节复制音频\n* 弊端:效率太低\n\n####  10.08_IO流(字节数组拷贝之available()方法)\n* A:案例演示\n  * int read(byte[] b):一次读取一个字节数组\n  * write(byte[] b):一次写出一个字节数组\n  * available()获取读的文件所有的字节个数\n* 弊端:有可能会内存溢出 \n\n   FileInputStream fis = new FileInputStream(\"致青春.mp3\");\n   ​\tFileOutputStream fos = new FileOutputStream(\"copy.mp3\");\n   ​\tbyte[] arr = new byte[fis.available()];\t\t\t\t\t//根据文件大小做一个字节数组\n   ​\tfis.read(arr);\t\t\t\t\t\t\t\t\t\t\t//将文件上的所有字节读取到数组中\n   ​\tfos.write(arr);\t\t\t\t\t\t\t\t\t\t\t//将数组中的所有字节一次写到了文件上\n   ​\tfis.close();\n   ​\tfos.close();\n   ​\t\n####  10.09_IO流(定义小数组)\n* write(byte[] b)\n* write(byte[] b, int off, int len)写出有效的字节个数\n\n  ​\t\n####  10.10_IO流(定义小数组的标准格式)\n* A:案例演示\n  * 字节流一次读写一个字节数组复制图片和视频\n    FileInputStream fis = new FileInputStream(\"致青春.mp3\");\n    FileOutputStream fos = new FileOutputStream(\"copy.mp3\");\n    int len;\n    byte[] arr = new byte[1024 * 8];\t\t\t\t\t//自定义字节数组\n\n    while((len = fis.read(arr)) != -1) {\n    ​\t//fos.write(arr);\n    ​\tfos.write(arr, 0, len);\t\t\t\t\t\t\t//写出字节数组写出有效个字节个数\n    }\n```java\n    fis.close();\n    fos.close();\n```\n\n    ####  10.11_IO流(BufferedInputStream和BufferOutputStream拷贝)\n* A:缓冲思想\n  * 字节流一次读写一个数组的速度明显比一次读写一个字节的速度快很多，\n  * 这是加入了数组这样的缓冲区效果，java本身在设计的时候，\n  * 也考虑到了这样的设计思想(装饰设计模式后面讲解)，所以提供了字节缓冲区流\n* B.BufferedInputStream\n  * BufferedInputStream内置了一个缓冲区(数组)\n  * 从BufferedInputStream中读取一个字节时\n  * BufferedInputStream会一次性从文件中读取8192个, 存在缓冲区中, 返回给程序一个\n  * 程序再次读取时, 就不用找文件了, 直接从缓冲区中获取\n  * 直到缓冲区中所有的都被使用过, 才重新从文件中读取8192个\n* C.BufferedOutputStream\n  * BufferedOutputStream也内置了一个缓冲区(数组)\n  * 程序向流中写出字节时, 不会直接写到文件, 先写到缓冲区中\n  * 直到缓冲区写满, BufferedOutputStream才会把缓冲区中的数据一次性写到文件里\n* D.拷贝的代码 \n\n   FileInputStream fis = new FileInputStream(\"致青春.mp3\");\t\t\t//创建文件输入流对象,关联致青春.mp3\n   ​\tBufferedInputStream bis = new BufferedInputStream(fis);\t\t\t//创建缓冲区对fis装饰\n   ​\tFileOutputStream fos = new FileOutputStream(\"copy.mp3\");\t\t//创建输出流对象,关联copy.mp3\n   ​\tBufferedOutputStream bos = new BufferedOutputStream(fos);\t\t//创建缓冲区对fos装饰\n   ​\t\n   ​\tint b;\n   ​\twhile((b = bis.read()) != -1) {\t\t\n   ​\t\tbos.write(b);\n   ​\t}\n   ​\t\n   ​\tbis.close();\t\t\t\t\t\t//只关装饰后的对象即可\n   ​\tbos.close();\n\n* E.小数组的读写和带Buffered的读取哪个更快?\n  * 定义小数组如果是8192个字节大小和Buffered比较的话\n  * 定义小数组会略胜一筹,因为读和写操作的是同一个数组\n  * 而Buffered操作的是两个数组\n\n####  10.12_IO流(flush和close方法的区别)\n* flush()方法\n\n  * 用来刷新缓冲区的,刷新后可以再次写出 \n* close()方法\n  * 用来关闭流释放资源的的,如果是带缓冲区的流对象的close()方法,不但会关闭流,还会再关闭流之前刷新缓冲区,关闭后不能再写出 \n\n    ####  10.13_IO流(字节流读写中文) \n* 字节流读取中文的问题\n\n  * 字节流在读中文的时候有可能会读到半个中文,造成乱码 \n* 字节流写出中文的问题\n  * 字节流直接操作的字节,所以写出中文必须将字符串转换成字节数组 \n  * 写出回车换行 write(\"\\r\\n\".getBytes());\n\n####  10.14_IO流(流的标准处理异常代码1.6版本及其以前)\n* try finally嵌套\n\n```java\n   FileInputStream fis = null;\n   \tFileOutputStream fos = null;\n   \ttry {\n   \t\tfis = new FileInputStream(\"aaa.txt\");\n   \t\tfos = new FileOutputStream(\"bbb.txt\");\n   \t\tint b;\n   \t\twhile((b = fis.read()) != -1) {\n   \t\t\tfos.write(b);\n   \t\t}\n   \t} finally {\n   \t\ttry {\n   \t\t\tif(fis != null)\n   \t\t\t\tfis.close();\n   \t\t}finally {\n   \t\t\tif(fos != null)\n   \t\t\t\tfos.close();\n   \t\t}\n   \t}\n  ```\n\n\n####  10.15_IO流(流的标准处理异常代码1.7版本)\n* try close\n\n   try(\n   ​\t\tFileInputStream fis = new FileInputStream(\"aaa.txt\");\n   ​\t\tFileOutputStream fos = new FileOutputStream(\"bbb.txt\");\n   ​\t\tMyClose mc = new MyClose();\n   ​\t){\n   ​\t\tint b;\n   ​\t\twhile((b = fis.read()) != -1) {\n   ​\t\t\tfos.write(b);\n   ​\t\t}\n   ​\t}\n* 原理\n\n  * 在try()中创建的流对象必须实现了AutoCloseable这个接口,如果实现了,在try后面的{}(读写代码)执行后就会自动调用,流对象的close方法将流关掉 \n\n####  10.16_IO流(图片加密)\n* 给图片加密\n\n   BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"a.jpg\"));\n   ​\tBufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"b.jpg\"));\n   ​\t\n   ​\tint b;\n   ​\twhile((b = bis.read()) != -1) {\n   ​\t\tbos.write(b ^ 123);\n   ​\t}\n   ​\t\n   ​\tbis.close();\n   ​\tbos.close();\n\n####  10.17_IO流(拷贝文件)\n* 在控制台录入文件的路径,将文件拷贝到当前项目下\n\n   ```java\n   Scanner sc = new Scanner(System.in);\n   \tSystem.out.println(\"请输入一个文件路径\");\n   \tString line = sc.nextLine();\t\t\t\t//将键盘录入的文件路径存储在line中\n   \tFile file = new File(line);\t\t\t\t\t//封装成File对象\n   \tFileInputStream fis = new FileInputStream(file);\n   \tFileOutputStream fos = new FileOutputStream(file.getName());\n   \t\n   \tint len;\n   \tbyte[] arr = new byte[8192];\t\t\t\t//定义缓冲区\n   \twhile((len = fis.read(arr)) != -1) {\n   \t\tfos.write(arr,0,len);\n   \t}\n   \t\n   \tfis.close();\n   \tfos.close();\n   ```\n\n\n####  10.18_IO流(录入数据拷贝到文件)\n* 将键盘录入的数据拷贝到当前项目下的text.txt文件中,键盘录入数据当遇到quit时就退出\n\n\n\n   ```java\n   Scanner sc = new Scanner(System.in);\n   \tFileOutputStream fos = new FileOutputStream(\"text.txt\");\n   \tSystem.out.println(\"请输入:\");\n       while(true) {\n   \t\tString line = sc.nextLine();\n   \t\tif(\"quit\".equals(line))\n   \t\t\tbreak;\n   \t\tfos.write(line.getBytes());\n   \t\tfos.write(\"\\r\\n\".getBytes());\n   \t}\n    \t\n   fos.close();\n   ```\n\n   ####  10.19_day20总结\n\n### 11.字符流(字符流FileReader)\n\n- 1.字符流是什么\n\n  - 字符流是可以直接读写字符的IO流\n  - 字符流读取字符, 就要先读取到字节数据, 然后转为字符. 如果要写出字符, 需要把字符转为字节再写出.    \n\n- 2.FileReader\n\n  - FileReader类的read()方法可以按照字符大小读取\n\n- \n  ​\t\n\n  ```java\n  FileReader fr = new FileReader(\"aaa.txt\");\t\t\t\t//创建输入流对象,关联aaa.txt\n  int ch;\n  while((ch = fr.read()) != -1) {\t\t\t\t\t\t\t//将读到的字符赋值给ch\n  \tSystem.out.println((char)ch);\t\t\t\t\t\t//将读到的字符强转后打印\n  }\n  fr.close();\t\t\t\t\t\t\t\t\t\t\t\t//关流 \n  ```\n\n####  11.02_IO流(字符流FileWriter)\n\n- FileWriter类的write()方法可以自动把字符转\n\n- \n\n- 为字节写出\n\n  FileWriter fw = new FileWriter(\"aaa.txt\");\n  ​\tfw.write(\"aaa\");\n  ​\tfw.close();\n\n####  11.03_IO流(字符流的拷贝)\n​\t\n​\t\n\n```java\nFileReader fr = new FileReader(\"a.txt\");\nFileWriter fw = new FileWriter(\"b.txt\");\nint ch;\nwhile((ch = fr.read()) != -1) {\n\tfw.write(ch);\n}\n\nfr.close();\nfw.close();\n```\n\n####  11.04_IO流(什么情况下使用字符流)\n\n- 字符流也可以拷贝文本文件, 但不推荐使用. 因为读取时会把字节转为字符, 写出时还要把字符转回字节.\n- 程序需要读取一段文本, 或者需要写出一段文本的时候可以使用字符流\n- 读取的时候是按照字符的大小读取的,不会出现半个中文\n- 写出的时候可以直接将字符串写出,不用转换为字节数组\n\n####  11.05_IO流(字符流是否可以拷贝非纯文本的文件)\n\n- 不可以拷贝非纯文本的文件\n- 因为在读的时候会将字节转换为字符,在转换过程中,可能找不到对应的字符,就会用?代替,写出的时候会将字符转换成字节写出去\n- 如果是?,直接写出,这样写出之后的文件就乱了,看不了了  \n\n####  11.06_IO流(自定义字符数组的拷贝)\n\n- ​\t\n  FileReader fr = new FileReader(\"aaa.txt\");\t\t\t//创建字符输入流,关联aaa.txt\n  ​\tFileWriter fw = new FileWriter(\"bbb.txt\");\t\t\t//创建字符输出流,关联bbb.txt\n  ​\t\n\n  ```java\n  int len;\n  char[] arr = new char[1024*8];\t\t\t\t\t\t//创建字符数组\n  while((len = fr.read(arr)) != -1) {\t\t\t\t\t//将数据读到字符数组中\n  \tfw.write(arr, 0, len);\t\t\t\t\t\t\t//从字符数组将数据写到文件上\n  }\n  \n  fr.close();\t\t\t\t\t\t\t\t\t\t\t//关流释放资源\n  fw.close();\t\n  ```\n\n####  11.07_IO流(带缓冲的字符流) \n\n- BufferedReader的read()方法读取字符时会一次读取若干字符到缓冲区, 然后逐个返回给程序, 降低读取文件的次数, 提高效率\n\n- BufferedWriter的write()方法写出字符时会先写到缓冲区, 缓冲区写满时才会写到文件, 降低写文件的次数, 提高效率\n\n- BufferedReader br = new BufferedReader(new FileReader(\"aaa.txt\"));\t//创建字符输入流对象,关联aaa.txt\n  ​\tBufferedWriter bw = new BufferedWriter(new FileWriter(\"bbb.txt\"));\t//创建字符输出流对象,关联bbb.txt\n  ​\t\n\n  ```java\n  int ch;\t\t\t\t\n  while((ch = br.read()) != -1) {\t\t//read一次,会先将缓冲区读满,从缓冲去中一个一个的返给临时变量ch\n  \tbw.write(ch);\t\t\t\t\t//write一次,是将数据装到字符数组,装满后再一起写出去\n  }\n  \n  br.close();\t\t\t\t\t\t\t//关流\n  bw.close();  \n  ```\n\n####  11.08_IO流(readLine()和newLine()方法)\t\n\n- \n  ​\t\n\n  ```java\n   BufferedReader的readLine()方法可以读取一行字符(不包含换行符号)\n   BufferedWriter的newLine()可以输出一个跨平台的换行符号\"\\r\\n\"\n   BufferedReader br = new BufferedReader(new FileReader(\"aaa.txt\"));\n  BufferedWriter bw = new BufferedWriter(new FileWriter(\"bbb.txt\"));\n  String line;\n  \twhile((line = br.readLine()) != null) {\n  \tbw.write(line);\n  //bw.write(\"\\r\\n\");\t\t\t\t\t//只支持windows系统\n  \tbw.newLine();\t\t\t\t\t\t//跨平台的\n  \t}\n  br.close();\n  bw.close(); \n  ```\n\n\n####  11.09_IO流(将文本反转)\n\n- 将一个文本文档上的文本反转,第一行和倒数第一行交换,第二行和倒数第二行交换\n\n####  11.10_IO流(LineNumberReader) \n\n- LineNumberReader是BufferedReader的子类, 具有相同的功能, 并且可以统计行号\n\n  - 调用getLineNumber()方法可以获取当前行号\n  - 调用setLineNumber()方法可以设置当前行号\n\n- LineNumberReader lnr = new LineNumberReader(new FileReader(\"aaa.txt\"));\n  ​\tString line;\n  ​\tlnr.setLineNumber(100);\t\t\t\t\t\t\t\t\t//设置行号\n  ​\twhile((line = lnr.readLine()) != null) {\n  ​\t\tSystem.out.println(lnr.getLineNumber() + \":\" + line);//获取行号\n  ​\t}\n  ​\t\n\n  ```\n  lnr.close(); \n  ```\n\n####  11.11_IO流(装饰设计模式)\n\n- interface Coder {\n  ​\t\tpublic void code();\n  ​\t}\n  ​\t\n\n  ```java\n  class Student implements Coder {\n  \n  \t@Override\n  \tpublic void code() {\n  \t\tSystem.out.println(\"javase\");\n  \t\tSystem.out.println(\"javaweb\");\n  \t}\n  \t\n  }\n  \n  class HeiMaStudent implements Coder {\n  \tprivate Student s;\t\t\t\t\t\t//获取到被包装的类的引用\n  \tpublic HeiMaStudent(Student s) {\t\t//通过构造函数创建对象的时候,传入被包装的对象\n  \t\tthis.s = s;\n  \t}\n  \t@Override\n  \tpublic void code() {\t\t\t\t\t//对其原有功能进行升级\n  \t\ts.code();\n  \t\tSystem.out.println(\"数据库\");\n  \t\tSystem.out.println(\"ssh\");\n  \t\tSystem.out.println(\"安卓\");\n  \t\tSystem.out.println(\".....\");\n  \t}\n  \t\n  } \n  ```\n\n####  11.12_IO流(使用指定的码表读写字符) \n\n- FileReader是使用默认码表读取文件, 如果需要使用指定码表读取, 那么可以使用InputStreamReader(字节流,编码表)\n\n- FileWriter是使用默认码表写出文件, 如果需要使用指定码表写出, 那么可以使用OutputStreamWriter(字节流,编码表)\n\n- \n  ​\t\n\n  ```java\n  BufferedReader br = \t\t\t\t\t\t\t\t\t//高效的用指定的编码表读\n  \t\t\tnew BufferedReader(new InputStreamReader(new FileInputStream(\"UTF-8.txt\"), \"UTF-8\"));\n  \tBufferedWriter bw = \t\t\t\t\t\t\t\t\t//高效的用指定的编码表写\n  \t\t\tnew BufferedWriter(new OutputStreamWriter(new FileOutputStream(\"GBK.txt\"), \"GBK\"));\n  \tint ch;\n  \twhile((ch = br.read()) != -1) {\n  \t\tbw.write(ch);\n  \t}\n  br.close();\n  bw.close();\n  ```\n\n  ####  11.13_IO流(转换流图解)\n\n- 画图分析转换流\n\n####  11.14_IO流(获取文本上字符出现的次数)\n\n- 获取一个文本上每个字符出现的次数,将结果写在times.txt上\n\n####  11.15_IO流(试用版软件)\n\n- 当我们下载一个试用版软件,没有购买正版的时候,每执行一次就会提醒我们还有多少次使用机会用学过的IO流知识,模拟试用版软件,试用10次机会,执行一次就提示一次您还有几次机会,如果次数到了提示请购买正版\n\n####  11.16_File类(递归)\n\n- 5的阶乘\t\n\n####  11.17_File类(练习)\n\n- 需求:从键盘输入接收一个文件夹路径,打印出该文件夹下所有的.java文件名\n\n####  11.18_IO流(总结)\n\n- 1.会用BufferedReader读取GBK码表和UTF-8码表的字符\n- 2.会用BufferedWriter写出字符到GBK码表和UTF-8码表的文件中\n- 3.会使用BufferedReader从键盘读取一行\n- \n\n### 12.其他流\n\n﻿####  12.01_IO流(序列流)(了解)\n\n- 1.什么是序列流\n\n  - 序列流可以把多个字节输入流整合成一个, 从序列流中读取数据时, 将从被整合的第一个流开始读, 读完一个之后继续读第二个, 以此类推.\n\n- 2.使用方式\n\n  - 整合两个: SequenceInputStream(InputStream, InputStream)\n\n  - \n\n    ```java\n    FileInputStream fis1 = new FileInputStream(\"a.txt\");\t\t\t//创建输入流对象,关联a.txt\n    \tFileInputStream fis2 = new FileInputStream(\"b.txt\");\t\t\t//创建输入流对象,关联b.txt\n    \tSequenceInputStream sis = new SequenceInputStream(fis1, fis2);\t//将两个流整合成一个流\n    \tFileOutputStream fos = new FileOutputStream(\"c.txt\");\t\t\t//创建输出流对象,关联c.txt\n    \t\n    int b;\n    while((b = sis.read()) != -1) {\t\t\t\t\t\t\t\t\t//用整合后的读\n    \tfos.write(b);\t\t\t\t\t\t\t\t\t\t\t\t//写到指定文件上\n    }\n    \n    sis.close();\n    fos.close(); \n    ```\n\n    ####  12.02_IO流(序列流整合多个)(了解)\n\n- 整合多个: SequenceInputStream(Enumeration)\n\n\n\n  ```java\n  FileInputStream fis1 = new FileInputStream(\"a.txt\");\t//创建输入流对象,关联a.txt\n  \tFileInputStream fis2 = new FileInputStream(\"b.txt\");\t//创建输入流对象,关联b.txt\n  \tFileInputStream fis3 = new FileInputStream(\"c.txt\");\t//创建输入流对象,关联c.txt\n  \tVector<InputStream> v = new Vector<>();\t\t\t\t\t//创建vector集合对象\n  \tv.add(fis1);\t\t\t\t\t\t\t\t\t\t\t//将流对象添加\n  \tv.add(fis2);\n  \tv.add(fis3);\n  \tEnumeration<InputStream> en = v.elements();\t\t\t\t//获取枚举引用\n  \tSequenceInputStream sis = new SequenceInputStream(en);\t//传递给SequenceInputStream构造\n  \tFileOutputStream fos = new FileOutputStream(\"d.txt\");\n  \tint b;\n  \twhile((b = sis.read()) != -1) {\n  \t\tfos.write(b);\n  \t}\n  sis.close();\n  fos.close();\n  ```\n\n\n####  12.03_IO流(内存输出流*****)(掌握)\n\n- 1.什么是内存输出流\n\n  - 该输出流可以向内存中写数据, 把内存当作一个缓冲区, 写出之后可以一次性获取出所有数据\n\n- 2.使用方式\n\n  - 创建对象: new ByteArrayOutputStream()\n\n  - 写出数据: write(int), write(byte[])\n\n  - 获取数据: toByteArray()\n\n  - FileInputStream fis = new FileInputStream(\"a.txt\");\n    ​\tByteArrayOutputStream baos = new ByteArrayOutputStream();\n    ​\tint b;\n    ​\twhile((b = fis.read()) != -1) {\n    ​\t\tbaos.write(b);\n    ​\t}\n    ​\t\n\n    ```java\n    //byte[] newArr = baos.toByteArray();\t\t\t\t//将内存缓冲区中所有的字节存储在newArr中\n    //System.out.println(new String(newArr));\n    System.out.println(baos);\n    fis.close();\n    ```\n\n    ####  12.04_IO流(内存输出流之黑马面试题)(掌握)\n\n- 定义一个文件输入流,调用read(byte[] b)方法,将a.txt文件中的内容打印出来(byte数组大小限制为5)\n\n- FileInputStream fis = new FileInputStream(\"a.txt\");\t\t\t\t//创建字节输入流,关联a.txt\n  ​\t\tByteArrayOutputStream baos = new ByteArrayOutputStream();\t\t//创建内存输出流\n  ​\t\tbyte[] arr = new byte[5];\t\t\t\t\t\t\t\t\t\t//创建字节数组,大小为5\n  ​\t\tint len;\n  ​\t\twhile((len = fis.read(arr)) != -1) {\t\t\t\t\t\t\t//将文件上的数据读到字节数组中\n  ​\t\t\tbaos.write(arr, 0, len);\t\t\t\t\t\t\t\t\t//将字节数组的数据写到内存缓冲区中\n  ​\t\t}\n  ​\t\tSystem.out.println(baos);\t\t\t\t\t\t\t\t\t\t//将内存缓冲区的内容转换为字符串打印\n  ​\t\tfis.close();\n\n  ####  12.05_IO流(随机访问流概述和读写数据)(了解)\n\n- A:随机访问流概述\n\n  - RandomAccessFile概述\n  - RandomAccessFile类不属于流，是Object类的子类。但它融合了InputStream和OutputStream的功能。\n  - 支持对随机访问文件的读取和写入。\n\n- B:read(),write(),seek()\n\n####  12.06_IO流(对象操作流ObjecOutputStream)(了解)\n\n- 1.什么是对象操作流\n\n  - 该流可以将一个对象写出, 或者读取一个对象到程序中. 也就是执行了序列化和反序列化的操作.\n\n- 2.使用方式\n\n  - 写出: new ObjectOutputStream(OutputStream), writeObject()\n\n    public class Demo3_ObjectOutputStream {\n\n    ```java\n    \t/**\n    \t * @param args\n    \t * @throws IOException \n    \t * 将对象写出,序列化\n    \t */\n    \tpublic static void main(String[] args) throws IOException {\n    \t\tPerson p1 = new Person(\"张三\", 23);\n    \t\tPerson p2 = new Person(\"李四\", 24);\n    //\t\tFileOutputStream fos = new FileOutputStream(\"e.txt\");\n    //\t\tfos.write(p1);\n    //\t\tFileWriter fw = new FileWriter(\"e.txt\");\n    //\t\tfw.write(p1);\n    \t\t//无论是字节输出流,还是字符输出流都不能直接写出对象\n    \t\tObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"e.txt\"));//创建对象输出流\n    \t\toos.writeObject(p1);\n    \t\toos.writeObject(p2);\n    \t\toos.close();\n    \t}\n    \n    }\n    ```\n\n    ####  12.07_IO流(对象操作流ObjectInputStream)(了解)\n\n- 读取: new ObjectInputStream(InputStream), readObject()\n\n  - public class Demo3_ObjectInputStream {\n\n    ```java\n    \t/**\n    \t * @param args\n    \t * @throws IOException \n    \t * @throws ClassNotFoundException \n    \t * @throws FileNotFoundException \n    \t * 读取对象,反序列化\n    \t */\n    \tpublic static void main(String[] args) throws IOException, ClassNotFoundException {\n    \t\tObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"e.txt\"));\n    \t\tPerson p1 = (Person) ois.readObject();\n    \t\tPerson p2 = (Person) ois.readObject();\n    \t\tSystem.out.println(p1);\n    \t\tSystem.out.println(p2);\n    \t\tois.close();\n    \t}\n    \n    }\n    ```\n\n\n####  12.08_IO流(对象操作流优化)(了解)\n\n- 将对象存储在集合中写出\n\n\n  ​\t\n\n  ```java\n  - Person p1 = new Person(\"张三\", 23);\n    Person p2 = new Person(\"李四\", 24);\n    Person p3 = new Person(\"马哥\", 18);\n    Person p4 = new Person(\"辉哥\", 20);\n  \n    ArrayList<Person> list = new ArrayList<>();\n    list.add(p1);\n    list.add(p2);\n    list.add(p3);\n    list.add(p4);\n  \n    ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"f.txt\"));\n    oos.writeObject(list);\t\t\t\t\t\t\t\t\t//写出集合对象\n  \n    oos.close();\n  \n  - 读取到的是一个集合对象\n  \n    ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"f.txt\"));\n    \tArrayList<Person> list = (ArrayList<Person>)ois.readObject();\t//泛型在运行期会被擦除,索引运行期相当于没有泛型\n    \t//想去掉黄色可以加注解\t\t\t\n    \t@SuppressWarnings(\"unchecked\")\n    \t\tfor (Person person : list) {\n    \t\tSystem.out.println(person);\n    \t\t}\n  ois.close();\n  ```\n\n  ####  12.09_IO流(加上id号)(了解)\n\n- 注意\n\n  - 要写出的对象必须实现Serializable接口才能被序列化\n  - 不用必须加id号\n\n####  12.10_IO流(数据输入输出流)(了解)\n\n- 1.什么是数据输入输出流\n\n  - DataInputStream, DataOutputStream可以按照基本数据类型大小读写数据\n  - 例如按Long大小写出一个数字, 写出时该数据占8字节. 读取的时候也可以按照Long类型读取, 一次读取8个字节.\n\n- 2.使用方式\n\n  - \n    ​\t\n\n    ```java\n    DataOutputStream(OutputStream), writeInt(), writeLong() \n    \n    DataOutputStream dos = new DataOutputStream(new FileOutputStream(\"b.txt\"));\n    \tdos.writeInt(997);\n    \tdos.writeInt(998);\n    \tdos.writeInt(999);\n    dos.close();\n    DataInputStream(InputStream), readInt(), readLong()\n    \n    DataInputStream dis = new DataInputStream(new FileInputStream(\"b.txt\"));\n    \tint x = dis.readInt();\n    \tint y = dis.readInt();\n    \tint z = dis.readInt();\n    \tSystem.out.println(x);\n    \tSystem.out.println(y);\n    \tSystem.out.println(z);\n    \tdis.close();\n    ```\n\n  - \n\n####  12.11_IO流(打印流的概述和特点)(掌握)\n\n- 1.什么是打印流\n\n  - 该流可以很方便的将对象的toString()结果输出, 并且自动加上换行, 而且可以使用自动刷出的模式\n\n  - System.out就是一个PrintStream, 其默认向控制台输出信息\n\n    PrintStream ps = System.out;\n    ​\tps.println(97);\t\t\t\t\t//其实底层用的是Integer.toString(x),将x转换为数字字符串打印\n    ​\tps.println(\"xxx\");\n    ​\tps.println(new Person(\"张三\", 23));\n    ​\tPerson p = null;\n    ​\tps.println(p);\t\t\t\t\t//如果是null,就返回null,如果不是null,就调用对象的toString()\n\n- 2.使用方式\n\n  - 打印: print(), println()\n\n  - 自动刷出: PrintWriter(OutputStream out, boolean autoFlush, String encoding) \n\n  - 打印流只操作数据目的\n\n    PrintWriter pw = new PrintWriter(new FileOutputStream(\"g.txt\"), true);\n    ​\tpw.write(97);\n    ​\tpw.print(\"大家好\");\n    ​\tpw.println(\"你好\");\t\t\t\t//自动刷出,只针对的是println方法\n    ​\tpw.close();\n\n####  12.12_IO流(标准输入输出流概述和输出语句)\n\n- 1.什么是标准输入输出流(掌握)\n\n  - System.in是InputStream, 标准输入流, 默认可以从键盘输入读取字节数据\n  - System.out是PrintStream, 标准输出流, 默认可以向Console中输出字符和字节数据\n\n- 2.修改标准输入输出流(了解)\n\n  - 修改输入流: System.setIn(InputStream)\n\n  - 修改输出流: System.setOut(PrintStream)\n\n  - \n    ​\t\n\n    ```java\n    System.setIn(new FileInputStream(\"a.txt\"));\t\t\t\t//修改标准输入流System.setOut(new PrintStream(\"b.txt\"));\t\t\t\t//修改标准输出流\n    InputStream in = System.in;\t\t\t\t\t\t\t\t//获取标准输入流\n    PrintStream ps = System.out;\t\t\t\t\t\t\t//获取标准输出流\n    int b;\n    while((b = in.read()) != -1) {\t\t\t\t\t\t\t//从a.txt上读取数据\n    \tps.write(b);\t\t\t\t\t\t\t\t\t\t//将数据写到b.txt上\n    }\n    \n    in.close();\n    ps.close();\n    ```\n\n####  12.13_IO流(修改标准输入输出流拷贝图片)(了解)\n​\t\t\n​\t\t\n\n```java\nSystem.setIn(new FileInputStream(\"IO图片.png\"));\t\t//改变标准输入流\nSystem.setOut(new PrintStream(\"copy.png\")); \t\t//改变标准输出流\nInputStream is = System.in;\t\t\t\t\t\t\t//获取标准输入流\n\tPrintStream ps = System.out;\t\t\t\t\t\t//获取标准输出流\n\t\n\tint len;\n\tbyte[] arr = new byte[1024 * 8];\n\t\n\twhile((len = is.read(arr)) != -1) {\n\t\tps.write(arr, 0, len);\n\t}\n\t\n\tis.close();\n\tps.close();\n```\n\n####  12.14_IO流(两种方式实现键盘录入)(了解)\n\n- A:BufferedReader的readLine方法。\n  - BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n- B:Scanner\n\n####  12.15_IO流(Properties的概述和作为Map集合的使用)(了解)\n\n- A:Properties的概述\n  - Properties 类表示了一个持久的属性集。\n  - Properties 可保存在流中或从流中加载。\n  - 属性列表中每个键及其对应值都是一个字符串。 \n- B:案例演示\n  - Properties作为Map集合的使用\n\n####  12.16_IO流(Properties的特殊功能使用)(了解)\n\n- A:Properties的特殊功能\n  - public Object setProperty(String key,String value)\n  - public String getProperty(String key)\n  - public Enumeration<String> stringPropertyNames()\n- B:案例演示\n  - Properties的特殊功能\n\n####  12.17_IO流(Properties的load()和store()功能)(了解)\n\n- A:Properties的load()和store()功能\n- B:案例演示\n  - Properties的load()和store()功能\n\n####  12.18_day22总结\n\n- 把今天的知识点总结一遍。\n\n\n\n\n\n\n\n","tags":["java"],"categories":["开发工具"]},{"title":"用第三方sdk解决微信授权","url":"/2018/10/22/用第三方sdk解决微信授权/","content":" **好身材才是男人最美丽的衣服**<Excerpt in index | 首页摘要>\n 运用sdk快速解决微信授权,解决大量的微信文档!\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 1.引入依赖:\n```xml\n        <dependency>\n\t\t\t<groupId>com.github.binarywang</groupId>\n\t\t\t<artifactId>weixin-java-mp</artifactId>\n\t\t\t<version>2.7.0</version>\n\t\t</dependency>\n```\n\n## 2.建立一个Controller\n```java\npackage com.imooc.controller;\n\nimport com.imooc.config.ProjectUrlConfig;\nimport com.imooc.enums.ResultEnum;\nimport com.imooc.exception.SellException;\nimport lombok.extern.slf4j.Slf4j;\nimport me.chanjar.weixin.common.api.WxConsts;\nimport me.chanjar.weixin.common.exception.WxErrorException;\nimport me.chanjar.weixin.mp.api.WxMpService;\nimport me.chanjar.weixin.mp.bean.result.WxMpOAuth2AccessToken;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\n\nimport java.net.URLEncoder;\n\n/**\n * Created by 廖师兄\n * 2017-07-03 01:20\n */\n@Controller\n@RequestMapping(\"/wechat\")\n@Slf4j\npublic class WechatController {\n\n    @Autowired\n    private WxMpService wxMpService;\n\n    @Autowired\n    private WxMpService wxOpenService;\n\n    @Autowired\n    private ProjectUrlConfig projectUrlConfig;\n\n    @GetMapping(\"/authorize\")\n    public String authorize(@RequestParam(\"returnUrl\") String returnUrl) {\n        //1. 配置\n        //2. 调用方法\n        String url = projectUrlConfig.getWechatMpAuthorize() + \"/sell/wechat/userInfo\";\n        String redirectUrl = wxMpService.oauth2buildAuthorizationUrl(url, WxConsts.OAUTH2_SCOPE_BASE, URLEncoder.encode(returnUrl));\n        return \"redirect:\" + redirectUrl;\n    }\n\n    @GetMapping(\"/userInfo\")\n    public String userInfo(@RequestParam(\"code\") String code,\n                         @RequestParam(\"state\") String returnUrl) {\n        WxMpOAuth2AccessToken wxMpOAuth2AccessToken = new WxMpOAuth2AccessToken();\n        try {\n            wxMpOAuth2AccessToken = wxMpService.oauth2getAccessToken(code);\n        } catch (WxErrorException e) {\n            log.error(\"【微信网页授权】{}\", e);\n            throw new SellException(ResultEnum.WECHAT_MP_ERROR.getCode(), e.getError().getErrorMsg());\n        }\n\n        String openId = wxMpOAuth2AccessToken.getOpenId();\n\n        return \"redirect:\" + returnUrl + \"?openid=\" + openId;\n    }\n\n    @GetMapping(\"/qrAuthorize\")\n    public String qrAuthorize(@RequestParam(\"returnUrl\") String returnUrl) {\n        String url = projectUrlConfig.getWechatOpenAuthorize() + \"/sell/wechat/qrUserInfo\";\n        String redirectUrl = wxOpenService.buildQrConnectUrl(url, WxConsts.QRCONNECT_SCOPE_SNSAPI_LOGIN, URLEncoder.encode(returnUrl));\n        return \"redirect:\" + redirectUrl;\n    }\n\n    @GetMapping(\"/qrUserInfo\")\n    public String qrUserInfo(@RequestParam(\"code\") String code,\n                             @RequestParam(\"state\") String returnUrl) {\n        WxMpOAuth2AccessToken wxMpOAuth2AccessToken = new WxMpOAuth2AccessToken();\n        try {\n            wxMpOAuth2AccessToken = wxOpenService.oauth2getAccessToken(code);\n        } catch (WxErrorException e) {\n            log.error(\"【微信网页授权】{}\", e);\n            throw new SellException(ResultEnum.WECHAT_MP_ERROR.getCode(), e.getError().getErrorMsg());\n        }\n        log.info(\"wxMpOAuth2AccessToken={}\", wxMpOAuth2AccessToken);\n        String openId = wxMpOAuth2AccessToken.getOpenId();\n\n        return \"redirect:\" + returnUrl + \"?openid=\" + openId;\n    }\n}\n\n```\n## 3.配置文件\n```java\nimport me.chanjar.weixin.mp.api.WxMpConfigStorage;\nimport me.chanjar.weixin.mp.api.WxMpInMemoryConfigStorage;\nimport me.chanjar.weixin.mp.api.WxMpService;\nimport me.chanjar.weixin.mp.api.impl.WxMpServiceImpl;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.stereotype.Component;\n\n/**\n * Created by 廖师兄\n * 2017-07-03 01:25\n */\n@Component\npublic class WechatMpConfig {\n\n    @Autowired\n    private WechatAccountConfig accountConfig;\n\n    @Bean\n    public WxMpService wxMpService() {\n        WxMpService wxMpService = new WxMpServiceImpl();\n        wxMpService.setWxMpConfigStorage(wxMpConfigStorage());\n        return wxMpService;\n    }\n\n    @Bean\n    public WxMpConfigStorage wxMpConfigStorage() {\n        WxMpInMemoryConfigStorage wxMpConfigStorage = new WxMpInMemoryConfigStorage();\n        wxMpConfigStorage.setAppId(accountConfig.getMpAppId());\n        wxMpConfigStorage.setSecret(accountConfig.getMpAppSecret());\n        return wxMpConfigStorage;\n    }\n}\n\n```\n","tags":["java"],"categories":["开发工具"]},{"title":"并查集(Union Find)","url":"/2018/10/22/并查集(Union Find)/","content":" **仰望星空,脚踏实地,暗无天日,登峰造极**<Excerpt in index | 首页摘要>\n学习算法思想,修炼编程内功!\n\n<!-- more -->\n<The rest of contents | 余下全文>\n# 并查集(Union Find)\n\n## 1.什么是并查集\n\n> * 是一种很不一样的树形结构\n> * 适合解决链接问题\n> * 网络中节点的链接状态\n> * 数学中集合类的实现(并集)\n>\n>\n\n## 2.并查集1.0版本的实现(Quick find 查的快,并的慢)\n\n```c++\n#include <iostream>\n#include <cassert>\n\nusing namespace std;\n\nclass UnionFind {\nprivate :\n    int *id;\n    int count;\npublic:\n    UnionFind(int n) {\n        count = n;\n        id = new int[n];\n        for (int i = 0; i < n; i++)\n            id[i] = i;\n    }\n\n    ~UnionFind() {\n        delete[]id;\n    }\n    int find(int p){\n        assert(p>=0&&p<count);\n        return id[p];\n    }\n    bool isConnected(int p,int q){\n        return find(p)==find(q);\n    }\n    void unionElements(int p ,int q){\n        int pid=find(p);\n        int qid=find(q);\n        if(q!=p){\n            for(int i=0;i<count;i++){\n                if(id[i]==pid)\n                    id[i]=qid;\n            }\n        }\n    }\n};\n```\n\n## 3.使用指向父亲节点实现并查集\n\n![1539598030956](/img/1539598030956.png)\n\n```c++\n#include <assert.h>\n#ifndef ARITHMETIC_IMOOC_UNIONFIND2_H\n#define ARITHMETIC_IMOOC_UNIONFIND2_H\n\n#endif //ARITHMETIC_IMOOC_UNIONFIND2_H\nnamespace UP2 {\n\n    class UnionFind {\n    private:\n        int *parent;\n        int count;\n    public:\n        UnionFind(int count) {\n            parent = new int[count];\n            this->count = count;\n            for (int i = 0; i < count; i++) {\n                parent[i] = i;\n            }\n        }\n        ~UnionFind() {\n            delete[] parent;\n        }\n        int find(int p){\n            assert(p>=0&&p<count);\n            while(p!=parent[p])\n                p=parent[p];\n            return p;\n        }\n        bool isConnection(int p,int q){\n            return find(p)==find(q);\n        }\n        void unionElements(int p,int q){\n            int pRoot=find(p);\n            int qRoot=find(q);\n            if(pRoot!=qRoot)\n                parent[pRoot]=parent[qRoot];\n        }\n    };\n}\n```\n\n## 4.并查集的优化(判断元素的层级尺寸再合并)\n\n```c++\n//\n// Created by JIA on 2018/10/15.\n//\n#include <assert.h>\n#ifndef ARITHMETIC_IMOOC_UNIONFIND2_H\n#define ARITHMETIC_IMOOC_UNIONFIND2_H\n\n#endif //ARITHMETIC_IMOOC_UNIONFIND2_H\nnamespace UP3 {\n\n    class UnionFind {\n    private:\n        int *parent;\n        int *sz;\n        int count;\n    public:\n        UnionFind(int count) {\n            parent = new int[count];\n            sz=new int[count];\n            this->count = count;\n            for (int i = 0; i < count; i++) {\n                parent[i] = i;\n                sz[i]=1;\n            }\n        }\n        ~UnionFind() {\n            delete[] parent;\n        }\n        int find(int p){\n            assert(p>=0&&p<count);\n            while(p!=parent[p])\n                p=parent[p];\n            return p;\n        }\n        bool isConnection(int p,int q){\n            return find(p)==find(q);\n        }\n        void unionElements(int p,int q){\n            int pRoot=find(p);\n            int qRoot=find(q);\n            if(pRoot==qRoot)\n                return ;\n            if(sz[pRoot]<sz[qRoot]){\n                parent[pRoot]=qRoot;\n                sz[qRoot]+=sz[pRoot];\n            }else{\n                parent[qRoot]=pRoot;\n                sz[pRoot]+=sz[qRot];\n            }\n\n        }\n    };\n}\n```\n\n## 5.通过路径压缩算法实现并查集的优化\n\n```c++\n      int find(int p){\n            assert(p>=0&&p<count);\n            while(p!=parent[p]){\n                p=parent[p];\n                parent[p]=parent[parent[p]];//路径压缩的实现\n            }\n            return p;     \n          //第二个版本的路径压缩算法,使用递归实现\n            if (p != parent[p])\n                parent[p] != find(parent[p]);\n            return parent[p];\n        }\n\n```\n\n\n\n\n\n ","tags":["算法"],"categories":["算法学习"]},{"title":"SpringMvc的一些方法","url":"/2018/10/22/SpringMvc的一些方法/","content":"\n** 失败者找理由,成功者找方法!** <Excerpt in index | 首页摘要>\n对SpringMvc的一些常用方法\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 1.Spring-mvc中关于表单中String日期转换为Date的工具类(实现*Converter*接口)\n> 需要实现一个接口,并重写一个方法,如下:\n\n```java\npackage com.itheima.springmvc.utils;\n\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\nimport org.springframework.core.convert.converter.Converter;\n\npublic class DateConvert2 implements Converter<String, Date>{\n\n\t@Override\n\tpublic Date convert(String arg0) {\n\t\tDate date=null;\n\t\ttry {\n\t\t\tSimpleDateFormat df=new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n\t\t\tdate=df.parse(arg0);\n\t\t} catch (ParseException e) {\n\t\t\te.printStackTrace();\n\t\t}\t\t\n\t\treturn date;\n\t}\n}\n```\n> 使用这个转换器需要在spring的配置文件中添加相应的bean,如下:\n\n     <!-- 配置注解驱动，相当于同时使用最新处理器映射跟处理器适配器,对json数据响应提供支持 -->\n\t<!-- 使用自定义转换器 -->\n\t<mvc:annotation-driven conversion-service=\"MyConvert\" />\n\t\n\t<!-- 定义转换器 -->\n\t<bean id=\"MyConvert\" class=\"org.springframework.format.support.FormattingConversionServiceFactoryBean\">\n\t\t<property name=\"converters\">\n\t\t\t<set>\n\t\t\t\t<bean class=\"com.itheima.springmvc.utils.DateConvert\" />\n\t\t\t</set>\n\t\t</property>\n\t</bean>\n## 2.web端关于get和post请求乱码的解决方案(web.xml中添加过滤器)\n\t\t<!-- 解决post乱码问题 -->\n\t<filter>\n\t\t<filter-name>encoding</filter-name>\n\t\t<filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>\n\t\t<!-- 设置编码参是UTF8 -->\n\t\t<init-param>\n\t\t\t<param-name>encoding</param-name>\n\t\t\t<param-value>UTF-8</param-value>\n\t\t</init-param>\n\t</filter>\n\t<filter-mapping>\n\t\t<filter-name>encoding</filter-name>\n\t\t<url-pattern>/*</url-pattern>\n\t</filter-mapping>\n***\n>修改tomcat中server.xml 文件解决get请求乱码(最方便的方法)\n>- **URLEncoding=\"utf-8\"** 为添加部分\n```xml\n  <Connector URLEncoding=\"utf-8\" connectionTimeout=\"20000\" port=\"8080\" protocol=\"HTTP/1.1\" redirectPort=\"8443\"/>\n```\n***\n\n>也可以使用自定义的拦截器实现(get和post请求均解决乱码问题):\n>- 运用动态代理的设计模式\n\n```java\npackage com.jia.filter;\n\nimport java.io.IOException;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\n\nimport javax.servlet.Filter;\nimport javax.servlet.FilterChain;\nimport javax.servlet.FilterConfig;\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.annotation.WebFilter;\nimport javax.servlet.http.HttpServletRequest;\n\npublic class Filter04 implements Filter {\n\n\tpublic void destroy() {\n\t}\n\n\tpublic void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n\t\tHttpServletRequest req=(HttpServletRequest)request;\n\t\tProxy.newProxyInstance(Filter04.class.getClassLoader(), xxx.class.getInterfaces(), new InvocationHandler() {\n\n\t\t\t@Override\n\t\t\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\t\t\t\tif(method.getName().equalsIgnoreCase(\"getAttribute\")) {\n\t\t\t\t\tString md=req.getMethod();\n\t\t\t\t\tif(\"get\".equals(md)) {\n\t\t\t\t\t\tString reuslt=(String)method.invoke(req, args);\n\t\t\t\t\t\tString str=new String(reuslt.getBytes(\"iso-8858-1\"),\"utf-8\");\n\t\t\t\t\t\treturn str;\n\n\t\t\t\t\t}else {\n\t\t\t\t\t\treq.setCharacterEncoding(\"utf-8\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t});\n\t}  \n\tpublic void init(FilterConfig fConfig) throws ServletException {\n\t}\n}\n```\n##3.在Controller中返回值为String时可以跳转到相应的页面\n>直接跳转到固定页面:\n```java\nRequestMapping(\"itemEdit\")\n\tpublic String itemEdit(Model model, @RequestParam(value = \"id\", required = true, defaultValue = \"1\") Integer ids) {\n\t\t// 查询商品信息\n\t\tItem item = itemService.getItemById(ids);\n\t\t// model返回数据模型\n\t\tmodel.addAttribute(\"item\", item);\n\t\t// mav.addObject(\"item\", item);\n\t\treturn \"itemEdit\";\n\t}\n```\n***\n>请求跳转到其他页面\n>- \"forward:xxx.action\"\n>\n>重定向到其他页面\n>- \"redirect:yyy.action\"\n***\n## 4.HandlerExceptionResolver 接口处理全局异常\n***\n## 5.springmvc上传文件写法(图片)\n![Alt text](/img/1534579880860.png)\n>需要加载的jar包\n![Alt text](/img/1534579925554.png)\n>配置多媒体解析器\n```\n<!-- 配置多媒体处理器 -->\n\t<!-- 注意：这里id必须填写：multipartResolver -->\n\t<bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\">\n\t\t<!-- 最大上传文件大小 -->\n\t\t<property name=\"maxUploadSize\" value=\"8388608\" />\n\t</bean>\n\n```\n>前端代码\n```xml\n<!-- 上传图片是需要指定属性 enctype=\"multipart/form-data\" -->\n\t<!-- <form id=\"itemForm\" action=\"\" method=\"post\" enctype=\"multipart/form-data\"> -->\n\t<form id=\"itemForm\"\taction=\"${pageContext.request.contextPath }/updateItem.action\" enctype=\"multipart/form-data\" method=\"post\">\n\t\t<input type=\"hidden\" name=\"id\" value=\"${item.id }\" /> 修改商品信息：\n\t\t<table width=\"100%\" border=1>\t\t\t\n\t\t\t<tr>\n\t\t\t\t<td>商品图片</td>\n\t\t\t\t<td>\n\t\t\t\t\t<c:if test=\"${item.pic !=null}\">\n\t\t\t\t\t\t<img src=\"/pic/${item.pic}\" width=100 height=100/>\n\t\t\t\t\t\t<br/>\n\t\t\t\t\t</c:if>\n\t\t\t\t\t<input type=\"file\"  name=\"pictureFile\"/> \n\t\t\t\t</td>\n\t\t\t</tr>\t\t\t\n\t\t</table>\n\t</form>\n```\n>上传文件后端代码\n```java\n//图片上传用MultipartFile接收文件\n\t@RequestMapping(value = \"updateItem\", method = { RequestMethod.POST, RequestMethod.GET })\n\tpublic String updateItem(Item item, Model model, MultipartFile picFile) throws Exception {\n\n\t\t// 图片新名字\n\t\tString name = UUID.randomUUID().toString();\n\t\t// 图片原名字\n\t\tString oldName = picFile.getOriginalFilename();\n\t\t// 后缀名\n\t\tString exeName = oldName.substring(oldName.lastIndexOf(\".\"));\n\n\t\tFile pic = new File(\"D:\\\\WebWork\\\\\" + name + exeName);\n\t\t// 保存图片到本地磁盘\n\t\tpicFile.transferTo(pic); \n\t\t// 更新商品图片信息\n\t\titem.setPic(name + exeName);\n\n\t\titemServices.update(item);\n\t\tmodel.addAttribute(\"item\", item);\n\t\tmodel.addAttribute(\"msg\", \"修改商品成功\");\n\t\treturn \"itemEdit\";\n\t}\n\n```","tags":["java"],"categories":["开源框架"]},{"title":"二分搜索树(Binary Seacher  Tree)","url":"/2018/10/14/二分搜索树(Binary Seacher  Tree)/","content":" **仰望星空,脚踏实地,暗无天日,登峰造极**<Excerpt in index | 首页摘要>\n学习算法思想,修炼编程内功!\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n### 1.二分查找\n\n> 一份为二,折半查找\n>\n> **要求**:待查找数组必须有序\n\n```c++\nusing namespace std;\ntemplate <typename T>\nint binarySearch(T arr[],int n,T target){\n    int l=0,r=n-1;\n    while(l<=r){\n        //int mid=(l+r)/2;  这样写存在bug,可能会溢出\n        int mid=l+(r-l)/2;\n        if(arr[mid]==target)\n            return mid;\n        if(target<mid)\n            r=mid-1;\n        else\n            l=mid+1;\n    }\n    return -1;\n}\n```\n\n> 递归实现二分查找\n\n```c++\ntemplate<typename T>\nint reBinarySearch(T arr[], T k, int l, int r) {\n    int mid = (l + r) / 2;\n    if (l > r)\n        return -1;\n    if (arr[mid] == k)\n        return mid;\n    else if (k < arr[mid])\n        reBinarySearch(arr, k, l, mid - 1);\n    else\n        reBinarySearch(arr, k, mid + 1, r);\n}\n```\n\n### 2.二分搜索树\n\n#### 2.1二分搜索树的优势:\n\n- 高效:\n\n  ​\t在查找,插入,删除都能以O(lgn)的时间复杂度完成\n\n- min,max,floor,ceil,rank,select 实现都将很方便\n\n- 在实际应用中,比如要查找一篇文章中某个词出现的次数,用二分搜索树效率将会异常的高\n\n![1539167904772](/img/1539167904772.png)\n\n#### 2.2 二分搜索树的定义:\n\n> - 在定义中天然的包括了递归结构\n> - 二分搜索树不一定是一颗完全二叉树\n\n![1539168446767](/img/1539168446767.png)\n\n#### 2.3向二叉搜索树中插入新的健值对的实现\n\n```c++\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <ctime>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\ntemplate<typename Key, typename Value>\nclass BST {\nprivate:\n    struct Node {\n        Key key;\n        Value value;\n        Node *left;\n        Node *right;\n\n        Node(Key key, Value value) {\n            this->key = key;\n            this - value = value;\n            this->right = this->left = NULL;\n        }\n    };\n    Node *root;//存根\n    int count;//存一共有的节点个数\n\npublic:\n    BST() {\n        root = NULL;\n        count = 0;\n    }\n    ~BST(){\n        //TODO\n    }\n    int size(){\n        return count;\n    }\n    bool isEmpty(){\n        return count==0;\n    }\n    void insert(Key key,Value value){\n        root = insert(root ,key,value);\n    }\nprivate:\n    //以node为根的二叉搜索树中插入节点(key,value)\n    //放回插入新节点后的二叉搜索树的根\n    Node* insert(Node *node,Key key,Value value){\n        if(node->key==NULL){\n            count++;\n//            node->key=key;\n//            node->value=value;\n            return new Node(key,value);\n        }\n        if(node->key==key)\n            node->value=value;\n        else if(node->key<key)\n            node->left=insert(node->left,key,value);\n        else\n            node->right=insert(node->right,key,value);\n        return node;\n    }\n};\n```\n\n### 2.4二分搜索树实现搜素和是否存在某个值得函数\n\n```c++\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <ctime>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\ntemplate<typename Key, typename Value>\nclass BST {\nprivate:\n    struct Node {\n        Key key;\n        Value value;\n        Node *left;\n        Node *right;\n\n        Node(Key key, Value value) {\n            this->key = key;\n            this - value = value;\n            this->right = this->left = NULL;\n        }\n    };\n    Node *root;//存根\n    int count;//存一共有的节点个数\n\npublic:\n    BST() {\n        root = NULL;\n        count = 0;\n    }\n    ~BST(){\n        //TODO\n    }\n    int size(){\n        return count;\n    }\n    bool isEmpty(){\n        return count==0;\n    }\n    void insert(Key key,Value value){\n        root = insert(root ,key,value);\n    }\n    //查找二叉搜索树是否存在key\n    bool contain(Key key){\n        return contain(root,key);\n    }\n    //查找key相应节点所对应的Value地址\n    Value* search(Key key){\n        return search(root,key);\n    }\nprivate:\n    //以node为根的二叉搜索树中插入节点(key,value)\n    //放回插入新节点后的二叉搜索树的根\n    Node* insert(Node *node,Key key,Value value){\n        if(node->key==NULL){\n            count++;\n//            node->key=key;\n//            node->value=value;\n            return new Node(key,value);\n        }\n        if(node->key==key)\n            node->value=value;\n        else if(node->key<key)\n            node->left=insert(node->left,key,value);\n        else\n            node->right=insert(node->right,key,value);\n        return node;\n    }\n    bool contain(Node* node ,Key key){\n        if(node==NULL)\n            return false;\n        if(node->key==key)\n            return true;\n        else if(key<node->key)\n            return contain(node->key,key);\n        else\n            return contain(node->right.key);\n    }\n    Value* search(Node* node,Key key){\n        if(node==NULL)\n            return NULL;\n        if(node->key==key)\n            return &(node->value);\n        else if(key<node->key)\n            return search(node->left,key);\n        else\n            return search(node->right,key);\n\n    }\n};\n```\n\n### 2.5二分搜索树的前,中,后序遍历,以及二分搜素树的销毁\n\n```c++\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <ctime>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\ntemplate<typename Key, typename Value>\nclass BST {\nprivate:\n    struct Node {\n        Key key;\n        Value value;\n        Node *left;\n        Node *right;\n        Node(Key key, Value value) {\n            this->key = key;\n            this - value = value;\n            this->right = this->left = NULL;\n        }\n    };\n    Node *root;//存根\n    int count;//存一共有的节点个数\npublic:\n    BST() {\n        root = NULL;\n        count = 0;\n    }\n    ~BST() {\n        destory(root);\n    }\n    int size() {\n        return count;\n    }\n    bool isEmpty() {\n        return count == 0;\n    }\n    void insert(Key key, Value value) {\n        root = insert(root, key, value);\n    }\n    //查找二叉搜索树是否存在key\n    bool contain(Key key) {\n        return contain(root, key);\n    }\n    //查找key相应节点所对应的Value地址\n    Value *search(Key key) {\n        return search(root, key);\n    }\n    //前序遍历\n    void preOreder() {\n        preOreder(root);\n    }\n    //中序遍历\n    void inOrder() {\n        inOrder(root);\n    }\n    //后序遍历\n    void postOrder() {\n        postOrder(root);\n    }\nprivate:\n//以node为根的二叉搜索树中插入节点(key,value)\n//放回插入新节点后的二叉搜索树的根\n    Node *insert(Node *node, Key key, Value value) {\n        if (node->key == NULL) {\n            count++;\n//            node->key=key;\n//            node->value=value;\n            return new Node(key, value);\n        }\n        if (node->key == key)\n            node->value = value;\n        else if (node->key < key)\n            node->left = insert(node->left, key, value);\n        else\n            node->right = insert(node->right, key, value);\n        return node;\n    }\n    bool contain(Node *node, Key key) {\n        if (node == NULL)\n            return false;\n        if (node->key == key)\n            return true;\n        else if (key < node->key)\n            return contain(node->key, key);\n        else\n            return contain(node->right.key);\n    }\n    Value *search(Node *node, Key key) {\n        if (node == NULL)\n            return NULL;\n        if (node->key == key)\n            return &(node->value);\n        else if (key < node->key)\n            return search(node->left, key);\n        else\n            return search(node->right, key);\n    }\n    void preOrder(Node *node) {\n        if (node != NULL) {\n            cout << node.key << \" \";\n            preOreder(node->left);\n            preOrder(node->right);\n        }\n    }\n    void inOrder(Node *node) {\n        if (node != NULL) {\n            inOrder(node->left);\n            cout << node->key << \" \";\n            inOrder(node->right);\n        }\n    }\n    void postOrder(Node *node) {\n        if (node != NULL) {\n            postOrder(node->left);\n            postOrder(node->right);\n            cout << node->key << \" \";\n        }\n    }\n    void destory(Node *node) {\n        if (node != NULL) {\n            destory(node->left);\n            destory(node->right);\n            delete node;\n            count--;\n        }\n    }\n};\n```\n\n### 2.6二分搜索树的广度优先遍历(层序遍历)\n\n![1539226708430](/img/1539226708430.png)\n\n> 代码实现\n\n```c++\n//二叉搜索树的程序遍历\n    void levelOrder() {\n        queue<Node *> q;\n        q.push(root);\n        while (!q.empty()) {\n            Node node = q.front();\n            q.pop();\n            count << node->key << \" \" << node->value << \"  \";\n            if (node.left)\n                q.push(node.left);\n            if (node.right)\n                q.push(node.left);\n        }\n    }\n\n```\n\n### 2.7找出最大值和最小值函数实现\n\n```c++\n Key minimum() {\n        assert(count != 0);\n        Node node = root;\n        while (node.left != NULL)\n            node = node.left;\n        return node.key;\n    }\n\n    Key maximum() {\n        assert(count != 0);\n        Node node = root;\n        while (node.right != NULL)\n            node = node.right;\n        return node;\n    }\n```\n\n### 2.8二分搜素树的删除节点\n> 删除最大值和最小值函数的实现:\n\n```c++\n//删除二分搜索树的最小节点\n    void removeMin(){\n        if(root)\n            root = removeMin(root);\n    }\n    //删除二分搜索树的最大节点\n    void removeMax(){\n        if(root)\n            root=removeMax(root);\n    }\nprivate:\nNode* removeMin(Node* node){\n        if(node->left==NULL){\n           Node* rightNode=node->right;\n           delete  node;\n           count--;\n           return rightNode;\n        }\n        node->left=removeMin(node->left);\n        return node;\n    }\n    Node* removeMax(Node* node){\n        if(node->right==NULL){\n            Node* leftNode=node->left;\n            delete node;\n            count--;\n            return leftNode;\n        }\n        node->right=removeMax(node->right);\n        return node;\n    }\n```\n\n> 二分搜索树删除指定节点:\n\n![1539588249714](/img/1539588249714.png)\n\n```c++\n //删除二叉树的指定节点\n    void remove(Key key) {\n        root = remove(root, key);\n    }\nprivate:    \n    Node *remove(Node *node, Key key) {\n        if (node == NULL)\n            return NULL;\n        if (key < node->key) {\n            node->left = remove(node->left, key);\n            return node;\n        } else if (key > node->key) {\n            node->right = remove(node->right, key);\n            return node;\n        } else {   //key=node.key的情况\n            if (node->left == NULL) {\n                Node *rightNode = node->right;\n                delete node;\n                count--;\n                return rightNode;\n            }\n            if (node->right == NULL) {\n                Node *leftNode = node->left;\n                delete node;\n                count--;\n                return leftNode;\n            }\n            //node.left!=null&&node.right!=null;\n            Node *successor = new Node(minimum(node->right));\n            count++;\n            successor->right = removeMin(node->right);\n            successor->left = node->left;\n            delete node;\n            count--;\n            return successor;\n        }\n    }\n```\n\n### 2.9二分查找树的局限性\n\n\n\n\n","tags":["算法"],"categories":["算法学习"]},{"title":"堆排序(heapSort)","url":"/2018/10/13/堆排序(heapSort)/","content":" **仰望星空,脚踏实地,暗无天日,登峰造极**<Excerpt in index | 首页摘要>\n学习算法思想,修炼编程内功!\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n## 堆排序(heapSort)\n\n### 1.堆排序的实现:\n\n```c++\n#include <string>\n#include <ctime>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\ntemplate<typename T>\n\nvoid __shiftDown(T arr[],int n,int k){\n    while(2*k+1<n){\n        int j=2*k+1;\n        if(j+1<n&&arr[j+1]>arr[j])\n            j+=1;\n        if(arr[k]>arr[j])\n            break;\n            swap(arr[j],arr[k]);\n            k=j;\n    }\n}\ntemplate<typename T>\nvoid heapSort(T arr[],int n){\n    for(int i=(n-1)/2;i>=0;i--)\n    __shiftDown(arr,n,i);\n    for(int i=n-1;i>0;i--){\n        swap(arr[0],arr[i]);\n        __shiftDown(arr,i,0);\n    }\n}\n```\n\n### 2.排序算法总结:\n\n> 排序苏算法的稳定性:对于相等的元素,在排序后,原来靠前的元素依然靠前.相等元素的相对位置没有发生改变.\n>\n> 在某次场景会考虑到排序算法的稳定性.比如:学生的姓名是按字典序排列的,根据分数排序后,相同分数的学生还应该按照字典序排列.(插入排序和归并排序是稳定的排序算法)\n>\n> ![1539159816193](/img/1539159816193.png)\n\n![1539159633630](/img/1539159633630.png)\n\n","tags":["算法"],"categories":["算法学习"]},{"title":"堆(Heap)","url":"/2018/10/13/堆的学习(Heap)/","content":" **仰望星空,脚踏实地,暗无天日,登峰造极**<Excerpt in index | 首页摘要>\n学习算法思想,修炼编程内功!\n\n<!-- more -->\n<The rest of contents | 余下全文>\n## 堆的学习(Heap)\n\n> 什么是优先队列:\n>\n> > 普通队列:先进先出;后进后出\n> >\n> > 优先队列:出队列和入队列和优先级有关(动态)\n>\n> ![1539084361286](/img/1539084361286.png)\n\n#### 1二叉堆\n\n![1539085506624](/img/1539085506624.png)\n\n### 1.1用数组储存二叉堆\n\n![1539085717026](/img/1539085717026.png)![1539085824560](/img/1539085824560.png)### 1.2定义一个基本的堆\n\n```c++\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <ctime>\n#include <cmath>\n#include <cassert>\nusing namespace std;\ntemplate <typename Item>\nclass Maxheap{\nprivate:\n    Item *data;\n    int count;\npublic:\n    Maxheap(int capacity){\n        data =new Item[capacity+1];\n        count=0;\n    }\n    ~Maxheap(){\n        delete[] data;\n    }\n    int size(){\n        return count;\n    }\n    bool isEmpty(){\n        return count == 0;\n    }\n};\n\nint main() {\n    Maxheap<int> maxheap = Maxheap<int>(100);\n    cout<<maxheap.size()<<endl;\n    return 0;\n}\n```\n\n### 1.3Shit Up的实现(向堆中插入元素)\n\n```c++\n//\n// Created by JIA on 2018/10/9.\n//\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <ctime>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\ntemplate<typename Item>\nclass Maxheap {\nprivate:\n    Item *data;\n    int count;\n\n    void shiftUp(int k) {\n        while (k > 1 && data[k / 2] < data[k]) {\n            swap(data[k / 2, data[k]]);\n\n            k /= 2;\n        }\n    }\n\npublic:\n    Maxheap(int capacity) {\n        data = new Item[capacity + 1];\n        count = 0;\n    }\n\n    ~Maxheap() {\n        delete[] data;\n    }\n\n    int size() {\n        return count;\n    }\n\n    bool isEmpty() {\n        return count == 0;\n    }\n\n    void insert(Item item) {\n        data[count + 1] = item;\n        count++;\n        shiftUp(count);\n    }\n};\n\nint main() {\n    Maxheap<int> maxheap = Maxheap<int>(100);\n    srand(time(NULL));\n    for (int i = 0; i < 15; i++) {\n        maxheap.insert(rand() % 100);\n    }\n    for (int i = 0; i < 15; i++) {\n        cout << maxheap.data[i] << \" \";\n    }\n    return 0;\n}\n```\n\n### 1.4ShiftDown和queryMax()的实现(取出堆中最大的元素)\n\n```c++\n//\n// Created by JIA on 2018/10/9.\n//\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <ctime>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\ntemplate<typename Item>\nclass Maxheap {\nprivate:\n    Item *data;\n    int count;\n\n    void shiftUp(int k) {\n        while (k > 1 && data[k / 2] < data[k]) {\n            swap(data[k / 2, data[k]]);\n\n            k /= 2;\n        }\n    }\n    void shiftDown(int k){\n//        while(data[k]>data[2*k]||data[k]>data[2*k+1])\n          while(2*k<=count){\n              int j=2*k;\n              if(j+1<count&&data[j]<data[j+1])\n                  j+=1;\n              if(data[k]>data[j])\n                  break;\n              swap(data[k],data[j]);\n              k=j;\n          }\n    }\n\n\npublic:\n    Maxheap(int capacity) {\n        data = new Item[capacity + 1];\n        count = 0;\n    }\n\n    ~Maxheap() {\n        delete[] data;\n    }\n\n    int size() {\n        return count;\n    }\n\n    bool isEmpty() {\n        return count == 0;\n    }\n\n    void insert(Item item) {\n        data[count + 1] = item;\n        count++;\n        shiftUp(count);\n    }\n    int queryMax(){\n\n        Item ret=data[1];\n        swap(ret ,data[count]);\n        count--;\n        shiftDown(1);\n        return ret;\n    }\n};\n\nint main() {\n    Maxheap<int> maxheap = Maxheap<int>(100);\n    srand(time(NULL));\n    for (int i = 0; i < 15; i++) {\n        maxheap.insert(rand() % 100);\n    }\n    for (int i = 0; i < 15; i++) {\n        cout << maxheap.data[i] << \" \";\n    }\n    return 0;\n}\n```\n\n## 3.堆排序\n\n> 借助大顶堆,每次将对顶元素取出;\n\n```c++\ntemplate <typename T>\nvoid HeapSort(T arr[],int n){\n    Maxheap<T> maxheap=new Maxheap<T>(n);\n    for (int i =n-1 ; i>=0  ; i--) {\n        arr[i]=maxheap.queryMax();\n    }\n}\n```\n\n### 1.5堆排序的优化\n\n> 直接将待排序的数组初始化成一个大顶堆堆\n\n```c++\nMaxheap(Item arr[],int n){\n        data=new Item[n+1];\n        capacity=n;\n        for (int i = 0; i <n ; i++) {\n            data[i+1]=arr[i];\n            count=n;\n            for(int i=count/2;i>=1;i--)\n                shiftDown(i);\n        }\n    }\n```\n\n### 1.6Heapify的算法复杂度\n\n![1539091417707](/img/1539091417707.png)## 2索引堆(Index Heap)\n\n> Heapify时只讲数组的索引堆化  \n>\n> 为什么使用索引堆:\n>\n>   Heapify的过程会进行频繁的交换,当元素足够复杂时,交换元素将会异常的耗费资源\n\n### 2.1 最大索引堆得代码实现\n\n```c++\nusing namespace std;\n\ntemplate<typename Item>\nclass IndexMaxheap {\nprivate:\n    int* indexes;\n    Item *data;\n    int count;\n    int cacacity;\n    void shiftUp(int k) {\n        while (k > 1 && data[indexes[k / 2]] < data[indexes[k]]) {\n            swap(indexes[k / 2], indexes[k]);\n\n            k /= 2;\n        }\n    }\n    void shiftDown(int k){\n//        while(data[k]>data[2*k]||data[k]>data[2*k+1])\n        while(2*k<=count){\n            int j=2*k;\n            if(j+1<count&&data[indexes[j]]<data[indexes[j+1]])\n                j+=1;\n            if(data[indexes[k]>data[indexes[j]])\n                break;\n            swap(indexes[k],indexes[j]);\n            k=j;\n        }\n    }\n\n\npublic:\n    IndexMaxheap(int capacity) {\n        data = new Item[capacity + 1];\n        this->indexes=new int[capacity];\n        count = 0;\n        this->cacacity=capacity;\n    }\n\n    ~IndexMaxheap() {\n        delete[] data;\n        delete[] indexes;\n    }\n\n    int size() {\n        return count;\n    }\n\n    bool isEmpty() {\n        return count == 0;\n    }\n\n    void insert(int i,Item item) {\n\n        data[i+1]=item;\n        indexes[count+1]=i;\n        count++;\n        shiftUp(count);\n    }\n    Item queryMax(){\n        Item ret=data[indexes[1]];\n        swap(indexes[1] ,indexes[count]);\n        count--;\n        shiftDown(1);\n        return ret;\n    }\n    int queryMaxIdex(){\n        int ret =indexes[1]-1;\n        swap(indexes[1] ,indexes[count]);\n        count--;\n        shiftDown(1);\n        return ret;\n    }\n    Item getItem(int i){\n        return data[i-1];\n    }\n    void change(int i,Item item){\n        i+=1;\n        data[i]=item;\n        for(int j=1;j<=count;j++){\n            if(indexes[j]==i){\n                shiftDown(indexes[j]);\n                shiftUp(indexes[j]);\n                return ;\n            }\n        }\n    }\n};\n```\n\n### 2.2 反向查找","tags":["算法"],"categories":["算法学习"]},{"title":"高级排序算法(n*logN)","url":"/2018/10/11/高级排序算法/","content":" **仰望星空,脚踏实地,暗无天日,登峰造极**<Excerpt in index | 首页摘要>\n学习算法思想,修炼编程内功!\n\n<!-- more -->\n<The rest of contents | 余下全文>\n# 高级排序算法(n*logN)\n## 1.归并排序(Merge Sort)\n\n> 将待排序的数组无数次分成两部分,最后将剩下的排序(减少了时间复杂度,增加了空间复杂度),归并的过程需要开辟新的数组 \n\n![1539061916200](/img/1539061916200.png)\n\n![1539062061025](/img/1539062061025.png)\n\n### 实现代码\n\n* 注释出代码为接近有序的代码进行优化:如果左面比右面小就不用归并操作\n\n```c++\n//将arr[l,mid]和[mid+1,r]进行归并\ntemplate<typename T>\nvoid __marge(T arr[], int l, int mid, int r) {\n    T aux[r - l + 1];\n    for (int i = l; i <= r; i++)\n        aux[i - l] = arr[i];\n\n    int i = l;\n    int j = mid + 1;\n    for (int k = l; k <= r; k++) {\n        if (i > mid) {\n            arr[k] = aux[j - l];\n            j++;\n        } else if (j > r) {\n            arr[k] = aux[i - l];\n            i++;\n        } else if (aux[i - l] < aux[j - l]) {\n            arr[k] = aux[i - l];\n            i++;\n        } else {\n            arr[k] = aux[j - l];\n            j++;\n        }\n    }\n}\n//对arr[l....r]的范围进行排序\ntemplate<typename T>\nvoid __mergeSort(T arr[], int l, int r) {\n    if (l >= r)\n        return;\n    int mid = (l + r) / 2;\n    __mergeSort(arr, l, mid);\n    __mergeSort(arr, mid+1, r);\n    //if (arr[mid] > arr[mid + 1])  //对接近有序的数组进行优化\n    __marge(arr, l, mid, r);\n\n}\ntemplate <typename T>\nvoid mergeSort(T arr[], int n) {\n    __mergeSort(arr, 0, n - 1);\n}\n\n```\n\n### 自底向上实现归并排序(不用进行递归操作)\n\n```c++\n#include <iostream>\n\nusing namespace std;\n\n//将arr[l,mid]和[mid+1,r]进行归并\ntemplate<typename T>\nvoid __marge(T arr[], int l, int mid, int r) {\n    T aux[r - l + 1];\n    for (int i = l; i <= r; i++)\n        aux[i - l] = arr[i];\n    int i = l;\n    int j = mid + 1;\n    for (int k = l; k <= r; k++) {\n        if (i > mid) {\n            arr[k] = aux[j - l];\n            j++;\n        } else if (j > r) {\n            arr[k] = aux[i - l];\n            i++;\n        } else if (aux[i - l] < aux[j - l]) {\n            arr[k] = aux[i - l];\n            i++;\n        } else {\n            arr[k] = aux[j - l];\n            j++;\n        }\n    }\n}\n\ntemplate<typename T>\nvoid mergerSortBU(T arr[], int n) {\n    for (int sz = 1; sz <= n; sz += sz) {\n        for (int i = 0; i + sz < n; i+= sz + sz) {\n            __marge(arr, i, i + sz - 1, min(i + sz + sz - 1, n - 1));\n        }\n    }\n}\n```\n\n## 2.快速排序(Quick Sort)\n\n> 最好理解,实现最容易的排序算法,但是如果数组接近有序时,性能将会异常的差\n>\n> 使用: swap(arr[l],arr[rand()%(h-l+1)+l]);  随机取一个数可以对代码进行优化\n\n```c++\n#include <iostream>\n\nusing namespace std;\n\nint __privo(int arr[], int l, int h) {\n    int p = arr[l];\n    while (l < h) {\n        swap(arr[l],arr[rand()%(h-l+1)+l]);   //对代码的优化\n        while (l < h && arr[h] >= p) --h;\n        swap(arr[l], arr[h]);\n        while (l < h && p > arr[l]) ++l;\n        swap(arr[l], arr[h]);\n    }\n\n    return l;\n}\n\nvoid quickSort(int arr[], int l, int h) {\n    if (l > h){\n        return;}\n    int p = __privo(arr, l, h);\n    quickSort(arr, l, p - 1);\n    quickSort(arr, p + 1, h);\n\n}\n\nint main() {\n    cout << \"abc\" << endl;\n    int a[] = {3,1,2,4,7,8,23,6,0};\n    quickSort(a, 0, 8);\n    for (int i = 0; i < 9; i++) {\n        cout << a[i] << \" \";\n    }\n    cout << endl;\n    cout<<\"))))\";\n    return 0;\n}\n\n\n```\n\n","tags":["算法"],"categories":["算法学习"]},{"title":"基础排序算法","url":"/2018/10/10/基础的排序算法/","content":" **仰望星空,脚踏实地,暗无天日,登峰造极**<Excerpt in index | 首页摘要>\n学习算法思想,修炼编程内功!\n\n<!-- more -->\n<The rest of contents | 余下全文>\n# 基础排序算法\n\n## 1选择排序(Selection Sort)\n\n### 基本思想\n\n> 基本思想,从0开始每一次找第n小的元素与当前第n位置的元素交换.时间复杂度O(n2) ,无论怎样的数组必须都将两层循环跑完.\n\n![1539000224817](/img/1539000224817.png)\n\n### 实现代码\n```c++\n#include<iostream>\nusing namespace std;\nvoid selectionSort( int arr[],int n){\n    for(int i=0; i<n; i++){\n        //寻找[i,n)区间最小值\n        int minIndex=i;\n        for(int j=i+1; j<n; j++){\n            if(arr[minIndex]>arr[j]){\n                minIndex=j;\n            }\n            swap(arr[minIndex],arr[i]);\n        }\n    }\n}\nint main(){\n    int a[]={1,2,3,5,4,6,8,7,9,10};\n    selectionSort(a,10);\n    for(int i=0;i<10;i++){\n        cout<<a[i]<<\" \";\n    }\n    cout<<endl;\n    return 0;\n}\n\n```\n\n### 使用c++模板进行扩展\n\n```c++\n#include<iostream>\n#include \"Student.h\"\nusing namespace std;\n//c++模板,或者泛型\ntemplate<typename T>\nvoid selectionSort( T arr[],int n){\n    for(int i=0; i<n; i++){\n        //寻找[i,n)区间最小值\n        int minIndex=i;\n        for(int j=i+1; j<n; j++){\n            if(arr[j]<arr[minIndex]){\n                minIndex=j;\n            }\n            swap(arr[minIndex],arr[i]);\n        }\n    }\n}\nint main(){\n    int a[]={1,2,3,5,4,6,8,7,9,10};\n    selectionSort(a,10);\n    for(int i=0;i<10;i++){\n        cout<<a[i]<<\" \";\n    }\n    cout<<endl;\n    float b[]={1.2,2.4,5,6,2.2};\n    selectionSort(b,5);\n    for(int i=0;i<5;i++){\n        cout<<b[i]<<\"  \";\n    }\n     cout<<endl;\n     string c[]={\"d\",\"b\",\"c\",\"a\",\"f\"};\n     for(int i=0;i<5;i++){\n        cout<<c[i]<<\"  \";\n     }\n      cout<<endl;\n      Student d[3]={{\"A\",90},{\"B\",80},{\"C\",85}};\n      selectionSort(d,3);\n      for(int i=0;i<3;i++){\n        cout<<d[i]<<\" \";\n      }\n      cout<<endl;\n    return 0;\n}\n\n```\n\n---\n\n```c++\n#ifndef STUDENT_H_INCLUDED\n#define STUDENT_H_INCLUDED\n\n\n#include<iostream>\n#include<string>\nusing namespace std;\nstruct Student{\n    string name;\n    int score;\n    bool operator<(const Student &otherStudent){\n        return score < otherStudent.score;\n    }\n    friend ostream& operator<<(ostream &os ,const Student &student){\n        os<<\"Student: \"<<student.name<<\" \"<<student.score<<endl;\n        return os;\n    }\n};\n\n\n#endif // STUDENT_H_INCLUDED\n\n```\n\n## 2.插入排序(Insertion Sort)\n\n> 再循环中每次将元素与前面位置元素比较,如果小就交换位置.时间复杂度O(n2).插入排序对接近有序的数组排序性能将会更好\n\n![1539003860047](/img/1539003860047.png)\n\n### 实现代码:\n\n```c++\n#include <iostream>\nusing namespace std;\ntemplate <typename T>\nvoid insertionSort(T arr [],int n){\n\n    for(int i=1;i<n;i++){\n        for(int j=i+1;j>0&&arr[j]<arr[j-1];j--){\n            swap(arr[j],arr[j-1]);\n        }\n    }\n\n}\n\n```\n\n---\n\n### 优化代码:\n\n> 每次循环标记元素的值,将每一次交换改成赋值操作,\n\n```c++\n#include <iostream>\n\nusing namespace std;\ntemplate <typename T>\nvoid insertionSortOpt(T arr[], int n) {\n    for (int i = 1; i < n; i++) {\n        T e = arr[i];\n        int j;\n        for ( j = i; j > 0 && arr[j - 1] > e; j--) {\n            arr[j] = arr[j - 1];\n        }\n        arr[j] = e;\n    }\n}\n\n```\n\n","tags":["算法"],"categories":["算法学习"]},{"title":"SpringCloud微服务学习总结","url":"/2018/10/04/SpringCloud微服务学习总结/","content":"\n** 骗的了别人骗不了自己,做什么都要用心!** <Excerpt in index | 首页摘要>\n对SpringCloud学习做一个总结,供以后应用查看\n<!-- more -->\n<The rest of contents | 余下全文>\n\n微服务的特点:\n\n> * 一系列微小的服务共同组成\n> * 单独部署,跑在自己的进程里\n> * 每个服务为独立的业务开发\n> * 分布式的管理\n\n传统vs微服务\n\n![1538629111529](/img/1538629111529.png)\n\n> 业务形态上不适合微服务的场景\n>\n> * 系统中包含很多很多强事务的场景\n> * 业务相对稳定,迭代周期长\n> * 访问压力不大,可用性要求不高\n> * ...\n\n![1538628687788](/img/1538628687788.png)\n\n![1538628921984](/img/1538628921984.png)\n\n## 1.Eureka服务注册中心\n\n### 1.1构建项目\n\n> 选择eureka Server\n\n![1538625976475](/img/1538625976475.png) \n\n### 1.2 启动类上添加```@EnableEurekaServer```注解\n\n```java\n\npackage com.jia.eureka;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;\n\n@SpringBootApplication\n@EnableEurekaServer\npublic class EurekaApplication {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(EurekaApplication.class, args);\n\t}\n}\n```\n\n### 1.3 application.yml配置\n\n>* register-with-eureka: false       是否注册到服务注册中心,因为自己就是服务注册注册中心,所以false\n>* enable-self-preservation: false      关闭心跳检测保留链接(开发环境为了查看服务状态)\n\n```java\n\neureka:\n  client:\n    service-url:\n      defaultZone: http://localhost:8761/eureka/\n    register-with-eureka: false\n  server:\n    enable-self-preservation: false\nspring:\n  application:\n    name: eureka\nserver:\n  port: 8761\n```\n\n### 1.4启动效果\n\n![1538626591475](/img/1538626591475.png)### 1.5小结\n\n> eureka服务注册中心在生产环境中可以做到高可用,启动多个eureka服务注册中心,彼此相互注册,每个客户端服务再分别注册到这些eureka服务注册中心.即使一个eureka垮掉,整个微服务也可以正常运行.\n>\n> ![1538628284808](/img/1538628284808.png)\n\n## 2.Eureka客户端的使用\n\n### 2.1构建项目\n\n> 选择Eureka Discovery\n\n![1538627464924](/img/1538627464924.png)2.2 启动类上添加@EnableDiscoveryClient注解\n\n```java\npackage com.jia.client;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.cloud.client.discovery.EnableDiscoveryClient;\n\n@SpringBootApplication\n@EnableDiscoveryClient\npublic class ClientApplication {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(ClientApplication.class, args);\n\t}\n}\n\n```\n\n### 2.3 application.yml的配置\n\n>*  instance:\n>\n>  ​        hostname: clientName     客户端服务跳转的名字\n\n```java\neureka:\n  client:\n    service-url:\n      defaultZone: http://localhost:8761/eureka/\n#  instance:\n#    hostname: clientName\nspring:\n  application:\n    name: client\nserver:\n  port: 10001\n```\n\n### 2.4 启动效果\n\n![1538628237602](/img/1538628237602.png)\n\n### 2.5小结\n\n> * @EnableEurekaServer @EnabeEurekaClient\n> * 心跳检测,健康检查,负载均衡等功能\n> * Eureka的高可用,生产上建议使用两台\n> * 分布式系统中,服务注册中心是重要的基础部分\n\n## 3.统一配置中心config\n\n### 3.1.为什么需要统一配置中心\n\n* 不方便维护\n* 配置内容安全与权限\n* 更新配置项目启动\n\n### 3.2.统一配置中心总体架构\n\n![1538630591518](/img/1538630591518.png)\n\n### 3.3.统一配置中心的Server端\n\n> * 项目构建 \n>\n> ![1538630687494](/img/1538630755571.png)\n>\n> * 启动类上添加注解@EnableConfigServer\n>\n>   ```java\n>   package com.jia.config;\n>   \n>   import org.springframework.boot.SpringApplication;\n>   import org.springframework.boot.autoconfigure.SpringBootApplication;\n>   import org.springframework.cloud.client.discovery.EnableDiscoveryClient;\n>   import org.springframework.cloud.config.server.EnableConfigServer;\n>   \n>   @SpringBootApplication\n>   @EnableDiscoveryClient\n>   @EnableConfigServer\n>   public class ConfigApplication {\n>   \n>   \tpublic static void main(String[] args) {\n>   \t\tSpringApplication.run(ConfigApplication.class, args);\n>   \t}\n>   }\n>   ```\n>\n>   * gitee上创建一个仓库用来存放配置文件\n>\n>   * > gitee地址:https://gitee.com/shltj/config-repo\n>\n>     ![1538631315904](/img/1538631315904.png)\n>\n>     * application.yml的配置\n>\n>       ```java\n>       spring:\n>         application:\n>           name: config\n>         cloud:\n>           config:\n>             server:\n>               git:\n>                 uri: https://gitee.com/shltj/config-repo\n>                 username: shltj\n>                 password: xxxxxxxx\n>                 basedir: e:/config\n>       eureka:\n>         client:\n>           service-url:\n>             defaultZone: http://localhost:8761/eureka/\n>       ```\n>\n>       * 启动效果\n>\n>         ![1538633264680](/img/1538633264680.png)\n\n### 3.4统一配置中心Client端\n\n> * 添加依赖\n>   \n>   ```java\n>   \t<dependency>\n>   \t\t\t<groupId>org.springframework.cloud</groupId>\n>   \t\t\t<artifactId>spring-cloud-config-client</artifactId>\n>   \t</dependency>\n>   ```\n>\n>   * gitee上新建client-dev.yml\n>\n>   ```java\n>   eureka:\n>     client:\n>       service-url:\n>         defaultZone: http://localhost:8761/eureka/\n>   #  instance:\n>   #    hostname: clientName\n>   spring:\n>     application:\n>       name: client\n>   server:\n>     port: 10001\n>   ```\n>\n>   * 将applicatiion.yml 修改为bootstrap.yml springboot默认先加载applicatiion.yml \n>\n>     ```java\n>     spring:\n>       cloud:\n>         config:\n>           discovery:\n>             enabled: true\n>             service-id: config\n>           profile: dev\n>       application:\n>         name: client\n>     ```\n>\n\n  ## 4.SpringCloud Bus 自动刷新配置\n\n### 4.1自动刷新配置原理\n\n![1538635206179](/img/1538635206179.png)### 4.2在config服务端添加amqp的依赖\n\n```java\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.cloud</groupId>\n\t\t\t<artifactId>spring-cloud-starter-bus-amqp</artifactId>\n\t\t</dependency>\n```\n\n### 4.3  在application.yml 中添加rabbitmq的配置并且暴露访问端口(后期可由git服务器的webhook 访问)\n\n```java\n  rabbitmq:\n    port: 5672\n    host: 101.200.44.222\n    username: tong\n    password: tong\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: \"*\"    \n```\n\n### 4.4在client服务端添加rabbitmap的依赖\n\n```java\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-bus-amqp</artifactId>\n        </dependency>\n```\n\n### 4.5注意将springboot和springcloud的版本改成BUILD-SNAPSHOT,M3存在bug.\n\n> **别忘记需要在更新配置的地方添加@RefreshScope注解**\n\n> 访问http://localhost:8080/actuator/bus-refresh(用post请求方式)可以实现动态更新配置,github上的webhook已经支持访问改接口\n\n## 5.mq的使用\n\n### 5.1 mq的应用场景\n\n> * 异步处理\n> * 流量削峰\n> * 日志处理\n> * 应用解耦\n\n## 6.服务网关Zuul\n\n### 6.1服务网关所应具备的要素\n\n> * 稳定性,高可用(7*25小时服务)\n> * 性能,并发性\n> * 安全性\n> * 扩展性\n\n### 6.2常见的服务网关\n\n![1538648760855](/img/1538648760855.png)### 6.3Zuul的特点\n\n> * 路由+过滤器=zuul\n>\n> * 核心是一些列的过滤器\n>\n>   ![1538648953468](/img/1538648953468.png)![1538649013623](/img/1538649013623.png)\n\n### 6.4Zuul的使用\n\n> * 项目的构建\n>\n>   ![1538649205460](/img/1538649205460.png)*  再启动类上添加@EnableZuulProxy注解\n>\n>   ```java\n>   package com.jia.apigetway;\n>   \n>   import org.springframework.boot.SpringApplication;\n>   import org.springframework.boot.autoconfigure.SpringBootApplication;\n>   import org.springframework.cloud.client.discovery.EnableDiscoveryClient;\n>   import org.springframework.cloud.netflix.zuul.EnableZuulProxy;\n>   \n>   @SpringBootApplication \n>   @EnableDiscoveryClient\n>   @EnableZuulProxy\n>   public class ApiGetwayApplication {\n>   \n>   \tpublic static void main(String[] args) {\n>   \t\tSpringApplication.run(ApiGetwayApplication.class, args);\n>   \t}\n>   }\n>   \n>   ```\n>\n>   * 经过服务网关和直接访问服务写法对比(网关+服务+方法)\n>\n>\n>\n>     > ![1538650336849](/img/1538650336849.png)\n>     >\n>     > ![1538650399065](/img/1538650399065.png)\n\n>* 自定义路由bootstrap.yml添加配置\n>\n>  ```java\n>  management:\n>    security:\n>      enabled: false\n>  zuul:\n>    routes:\n>      aaaaa:\n>        path: /myclient/**\n>        serviceId: client\n>  ```\n>\n>  ---\n>\n>  简介写法:\n>\n>  ![1538650911129](/img/1538650911129.png)\n\n> * 排除某些路由的写法:\n>\n>   ![1538651042319](/img/1538651042319.png)* Zuul默认服务间不能传递cookie,传递cookId配置方法\n>\n>   ![1538651174961](/img/1538651174961.png)\n\n### 6.5Zuul典型的使用场景\n\n* 前置过滤器: 限流,鉴权,参数校验调整\n* 后置过滤器:统计,日志\n\n### 6.6Zuul的权限校验 \n\n> 规定请求的参数必须带Token.如果Token为空,校验不通过,实现代码如下:\n>\n> > 注意: shouldFilter方法返回值设置为true\n> >\n> > ​         filterType()方法中配置参数类型\n> >\n> > ​          filterOrder()方法中配置拦截器的优先级\n\n```java\npackage com.jia.apigetway.filter;\n\nimport com.netflix.zuul.ZuulFilter;\nimport com.netflix.zuul.context.RequestContext;\nimport org.apache.http.HttpStatus;\nimport org.springframework.stereotype.Component;\nimport org.springframework.util.StringUtils;\n\nimport javax.servlet.http.HttpServletRequest;\n\nimport static org.springframework.cloud.netflix.zuul.filters.support.FilterConstants.PRE_DECORATION_FILTER_ORDER;\nimport static org.springframework.cloud.netflix.zuul.filters.support.FilterConstants.PROXY_KEY;\n\n@Component\npublic class Tocken extends ZuulFilter {\n    @Override\n    public String filterType() {\n        return PROXY_KEY;\n    }\n\n    @Override\n    public int filterOrder() {\n        return PRE_DECORATION_FILTER_ORDER-1;\n    }\n\n    @Override\n    public boolean shouldFilter() {\n        return true;\n    }\n\n    @Override\n    public Object run() {\n        RequestContext requestContext = RequestContext.getCurrentContext();\n        HttpServletRequest request=requestContext.getRequest();\n        String token=request.getParameter(\"token\");\n        if(StringUtils.isEmpty(token)){\n            requestContext.setSendZuulResponse(false);\n            requestContext.setResponseStatusCode(HttpStatus.SC_UNAUTHORIZED);\n        }\n\n        return null;\n    }\n}\n\n```\n\n### 6.7Zuul的限流\n\n> Zuul使用的是Google开发的令牌桶限流,具体如下图:\n>\n> ![1538652781643](/img/1538652781643.png)\n\n> 代码如下\n>\n> ```java\n> package com.jia.apigetway.filter;\n> \n> import com.google.common.util.concurrent.RateLimiter;\n> import com.netflix.zuul.ZuulFilter;\n> import org.springframework.stereotype.Component;\n> \n> import static org.springframework.cloud.netflix.zuul.filters.support.FilterConstants.PRE_TYPE;\n> import static org.springframework.cloud.netflix.zuul.filters.support.FilterConstants.SERVLET_DETECTION_FILTER_ORDER;\n> \n> @Component\n> public class RateLimiterFilter extends ZuulFilter {\n>     //每秒钟放100令牌\n>     private static final RateLimiter RATE_LIMITER=RateLimiter.create(100);\n> \n>     @Override\n>     public String filterType() {\n>         return PRE_TYPE;\n>     }\n> \n>     @Override\n>     public int filterOrder() {\n>         return SERVLET_DETECTION_FILTER_ORDER-1;\n>     }\n> \n>     @Override\n>     public boolean shouldFilter() {\n>         return true;\n>     }\n> \n>     @Override\n>     public Object run() {\n>         if(!RATE_LIMITER.tryAcquire()){\n>            throw new RuntimeException();   //通过令牌桶限流,如果拿不到令牌就抛出一个异常,感觉好像有bug\n>         }\n>         return null;\n>     }\n> }\n> \n> ```\n\n### 6.8Zuul的权限校验\n\n> 通过Zuul的拦截器实现如下鉴权功能\n>\n> ![1538654024968](/img/1538654024968.png)\n>\n> 在拦截器中具体代码实现如下:\n>\n> ![1538654539209](/img/1538654539209.png)\n\n### 6.8Zuul的跨域解决方法\n\n> 基本解决跨域\n\n```java\npackage com.jia.apigetway;\n\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.cors.CorsConfiguration;\nimport org.springframework.web.cors.UrlBasedCorsConfigurationSource;\nimport org.springframework.web.filter.CorsFilter;\n\nimport java.util.Arrays;\n\n/**\n * 跨域配置\n * C-Cross O-Origin  R-Resource S-Sharing\n */\n@Configuration\npublic class CorsConfig  {\n    public CorsFilter corsFilter(){\n        final UrlBasedCorsConfigurationSource source=new UrlBasedCorsConfigurationSource();\n        final CorsConfiguration config=new CorsConfiguration();\n        config.setAllowCredentials(true);\n        config.setAllowedOrigins(Arrays.asList(\"*\")); //http://www.a.com\n        config.setAllowedHeaders(Arrays.asList(\"*\"));\n        config.setAllowedMethods(Arrays.asList(\"*\"));\n        config.setMaxAge(300l);\n        source.registerCorsConfiguration(\"/**\",config);\n        return  new CorsFilter(source)\n    }\n}\n\n```\n\n> 通用跨域解决方案\n>\n> ![1538655791286](/img/1538655791286.png)\n\n## 7.服务容错Hystrix\n\n> 同步等待会造成资源耗尽\n\n### 7,1Hystrix的功能\n\n> * 服务降级\n> * 依赖隔离\n> * 服务熔断\n> * 监控(Hystrix Dashboard)\n\n### 7.2服务降级\n\n> 优先核心服务,非核心服务不可用或若可用\n>\n> 通过HystrixCommand注解指定\n>\n> fallbackMethod(回退函数)中具体实现降级逻辑\n\n### 7,3Hystrix的使用\n\n> 在client服务去访问client2服务的getMessage方法\n>\n> * 在client服务端添加Hystrix依赖\n>\n>   ```java\n>   \t\t<dependency>\n>   \t\t\t<groupId>org.springframework.cloud</groupId>\n>   \t\t\t<artifactId>spring-cloud-starter-hystrix</artifactId>\n>   \t\t</dependency>\n>   ```\n>\n>   * 启动类上添加@EnableCircuitBreaker注解\n>\n>     ```java\n>     package com.jia.client;\n>     \n>     import org.springframework.boot.SpringApplication;\n>     import org.springframework.boot.autoconfigure.SpringBootApplication;\n>     import org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker;\n>     import org.springframework.cloud.client.discovery.EnableDiscoveryClient;\n>     import org.springframework.cloud.netflix.hystrix.EnableHystrix;\n>     \n>     @SpringBootApplication\n>     @EnableDiscoveryClient\n>     @EnableCircuitBreaker\n>     public class ClientApplication {\n>     \n>     \tpublic static void main(String[] args) {\n>     \t\tSpringApplication.run(ClientApplication.class, args);\n>     \t}\n>     }\n>     ```\n>\n>     * 定义HystrixController实验服务降级\n>\n>       >在方法上添加  @HystrixCommand(fallbackMethod = \"fallback\")注解当方法出现异常或者超时会自动调用fallback();\n>       >\n>       >如果想所有的方法都实现服务降级,可以在Controller上添加@DefaultProperties(defaultFallback=\"xxxxx\") xxxxx为自定义服务降级走的方法\n>\n>       ```java\n>       package com.jia.client.controller;\n>       \n>       import com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;\n>       import org.springframework.web.bind.annotation.GetMapping;\n>       import org.springframework.web.bind.annotation.RestController;\n>       import org.springframework.web.client.RestTemplate;\n>       \n>       @RestController\n>       public class HystrixController {\n>       \n>            RestTemplate restTemplate=new RestTemplate();\n>       \n>            @GetMapping(\"/get\")\n>            @HystrixCommand(fallbackMethod = \"fallback\")\n>            public String getMsg(){\n>                String msg=restTemplate.getForObject(\"http://localhost:10005/getMessage\",String.class);\n>                try {\n>                    Thread.sleep(2000);\n>                } catch (InterruptedException e) {\n>                    e.printStackTrace();\n>                }\n>                return \"from client2 message\"+msg;\n>            }\n>            private  String fallback(){\n>                return \"人太多,挤爆了\";\n>            }\n>       \n>       }\n>       \n>       ```\n\n### 7,4Hystrix服务的熔断\n\n> 断路器实现服务熔断:\n>\n> ![1538702279205](/img/1538702279205.png)\n>\n>    访问getMessage方法,当参数为奇数是抛异常,当异常达到一定次数是(60%)启动断路开关\n\n```java\npackage com.imooc.client3.controller;\n\nimport com.netflix.hystrix.contrib.javanica.annotation.DefaultProperties;\nimport com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;\nimport com.netflix.hystrix.contrib.javanica.annotation.HystrixProperty;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.RestController;\nimport org.springframework.web.client.RestTemplate;\n\n@RestController\n@DefaultProperties(defaultFallback = \"defaultFallback\")\npublic class HystrixController {\n    private RestTemplate restTemplate = new RestTemplate();\n//    服务的超时配置\n\n//    @HystrixCommand(fallbackMethod = \"fallback\",commandProperties ={\n//            @HystrixProperty(name = \"execution.isolation.thread.timeoutInMilliseconds\",value=\"3500\")\n//    } )\n    @HystrixCommand(commandProperties = {\n            @HystrixProperty(name=\"circuitBreaker.enabled\",value = \"true\"),   //设置熔断\n            @HystrixProperty(name=\"circuitBreaker.requestVolumeThreshold\",value = \"10\"),\n            @HystrixProperty(name=\"circuitBreaker.sleepWindowInMilliseconds\",value = \"10000\"),\n            @HystrixProperty(name=\"circuitBreaker.errorThresholdPercentage\",value = \"60\")\n    })\n    @GetMapping(\"/messageT\")\n    public String getMessage(@RequestParam(\"number\") Integer number ) {\n        String result=null;\n        if(number%2==0){\n             result = this.restTemplate.getForObject(\"http://localhost:10006/tong\",String.class);\n\n        }else{\n            int a=1/0;\n             result=\"1111\";\n        }\n\n        System.out.println(result);\n        return result;\n    }\n\n    private String fallback() {\n        return \"出故障了!!!\";\n    }\n\n    @HystrixCommand\n    @GetMapping(\"/messageT1\")\n    public String getMessage1() throws RuntimeException {\n        String result = this.restTemplate.getForObject(\"http://localhost:10006/tong\", String.class);\n\n        System.out.println(result);\n        int a = 1 / 0;\n        return result;\n\n\n    }\n\n    private String defaultFallback() {\n        return \"默认方法出故障了!!!!!\";\n    }\n\n}\n\n```\n\n### 7.5feign和Hystrix的使用\n\n> feign的使用(内置ribbon):\n>\n> * 添加依赖\n>\n>   ```java\n>   <dependency>\n>       <groupId>org.springframework.cloud</groupId>\n>       <artifactId>spring-cloud-starter-openfeign</artifactId>\n>   </dependency>\n>   ```\n>\n> * 启动类上添加注解@EnableFeignClients\n>\n>   ```java\n>   package com.jia.client;\n>   \n>   import org.springframework.boot.SpringApplication;\n>   import org.springframework.boot.autoconfigure.SpringBootApplication;\n>   import org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker;\n>   import org.springframework.cloud.client.discovery.EnableDiscoveryClient;\n>   import org.springframework.cloud.openfeign.EnableFeignClients;\n>   \n>   @SpringBootApplication\n>   @EnableDiscoveryClient\n>   @EnableCircuitBreaker\n>   @EnableFeignClients\n>   public class ClientApplication {\n>   \n>   \tpublic static void main(String[] args) {\n>   \t\tSpringApplication.run(ClientApplication.class, args);\n>   \t}\n>   }\n>   ```\n>\n>   * 访问远程服务的方法\n>\n>     ```java\n>     package com.jia.client.controller;\n>     \n>     \n>     import org.springframework.cloud.openfeign.FeignClient;\n>     import org.springframework.web.bind.annotation.PostMapping;\n>     \n>     @FeignClient(\"client2\")\n>     public interface Client2Feign {\n>         @PostMapping(\"/client2/getMessage\")\n>         String get();\n>     }\n>     \n>     ```\n>\n>     ----\n>\n>     feign和Hystrix结合使用:\n>\n>     > bootstrap.yml中添加配置\n>     >\n>     > ```java\n>     > feign:\n>     >   hystrix:\n>     >     enable: true\n>     > ```\n>     >\n>     >\n>\n>     > 如果发生异常执行class中的方法\n>\n>     ```java\n>     package com.jia.client.controller;\n>     \n>     \n>     import org.springframework.cloud.openfeign.FeignClient;\n>     import org.springframework.stereotype.Component;\n>     import org.springframework.web.bind.annotation.PostMapping;\n>     \n>     @FeignClient(value = \"client2\",fallback = Client2Feign.Client2Fallback.class)\n>     public interface Client2Feign {\n>         @PostMapping(\"/client2/getMessage\")\n>         String get();\n>         @Component\n>         class Client2Fallback implements Client2Feign{\n>             @Override\n>             public String get() {\n>                 return null;\n>             }\n>         }\n>     }\n>     \n>     ```\n\n### 7.6Hystrix-dashboard可视化组件的使用\n\n> * 添加依赖\n>\n>   ```java\n>        <dependency>\n>           <groupId>org.springframework.cloud</groupId>\n>           <artifactId>spring-cloud-starter-hystrix-dashboard</artifactId>\n>        </dependency>\n>        <dependency>\n>            <groupId>org.springframework.boot</groupId>\n>            <artifactId>spring-boot-starter-actuator</artifactId>\n>         </dependency>\n>   ```\n>\n>   * 启动类上添加注解@EnableHystrixDashboard\n>\n>     ```java\n>     package com.jia.client;\n>     \n>     import org.springframework.boot.SpringApplication;\n>     import org.springframework.boot.autoconfigure.SpringBootApplication;\n>     import org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker;\n>     import org.springframework.cloud.client.discovery.EnableDiscoveryClient;\n>     import org.springframework.cloud.netflix.hystrix.dashboard.EnableHystrixDashboard;\n>     import org.springframework.cloud.openfeign.EnableFeignClients;\n>     \n>     @SpringBootApplication\n>     @EnableDiscoveryClient\n>     @EnableCircuitBreaker\n>     @EnableFeignClients\n>     @EnableHystrixDashboard\n>     public class ClientApplication {\n>     \n>     \tpublic static void main(String[] args) {\n>     \t\tSpringApplication.run(ClientApplication.class, args);\n>     \t}\n>     }\n>     \n>     ```\n>\n>     * 访问/hystrix路径\n>\n>       ![1538707724714](/img/1538707724714.png)* client服务端添加如下配置:\n>\n>       ```java\n>       management:\n>         context-path: /\n>       ```\n>\n>       * 监控视图\n>\n>         ![1538708343150](/img/1538708343150.png)\n\n## 8.服务的追踪(链路监控Sleuth)\n\n> * 添加依赖\n>\n>   ```java\n>   \t\t<dependency>\n>   \t\t\t<groupId>org.springframework.cloud</groupId>\n>   \t\t\t<artifactId>spring-cloud-starter-sleuth</artifactId>\n>   \t\t</dependency>\n>   ```\n>\n>  * 使用**OpenZIPkin**查看服务的追踪\n>\n>     > * 用docker安装软件\n>     >\n>     >   docker pull openzipkin/zipkin\n>     >\n>     >   docker run -d -p 9411:9411 zipkin\n>     >\n>     >   浏览器访问:http://101.200.44.222:9411/zipkin/\n>     >\n>     >   ![1538710627440](/img/1538710627440.png)\n>\n>  * client服务添加相应依赖\n>\n>     ```java\n>     <dependency>\n>        <groupId>org.springframework.cloud</groupId>\n>        <artifactId>spring-cloud-sleuth-zipkin</artifactId>\n>     </dependency>\n>     ```\n>\n>   * bootstrap.yml中添加配置\n>\n>       ```java\n>       zipkin:\n>         base-url: http://101.200.44.222:9411\n>       ```\n>\n>           * 设置抽样观察百分比为1\n>\n>         ```java\n>         sleuth:\n>           sampler:\n>             percentage: 1f\n>         ```\n>\n> * 展示效果\n>\n>      ![1538711526837](/img/1538711526837.png)\n>\n\n##  9.分布式追踪系统\n\n### 9.1核心步骤(OpenTracing规范)\n\n![1538711826394](/img/1538711826394.png)\n\n> * 数据采集\n> * 数据存储\n> * 查询展示\n\n## 10.使用docker部署项目\n\n### 10.1docker部署eureka服务注册中心\n\n> * Docerfile文件内容\n>\n> ```dockerfile\n> FROM hub.c.163.com/library/java:8-alpine\n> ADD app.jar  app.jar\n> EXPOSE 8761\n> ENTRYPOINT [\"java\",\"-jar\",\"/app.jar\"]\n> ```\n>\n> * 构建命令:docker build -t springcloud2/eureka .\n>\n> * 运行命令:docker run -d -p 8761:8761 springcloud2/eureka\n>\n> * 网易云上传镜像:https://www.163yun.com/help/documents/15587826830438400\n>\n> * 访问成功:\n>\n>   ![1538714796176](/img/1538714796176.png)\n\n### 10.2 rancher的使用\n\n> Rancher是一个开源的企业级全栈化容器部署管理平台(为了更方便的管理docker)\n>\n> > 安装rancher命令:sudo docker run -d --restart=unless-stopped -p 8080:8080 rancher/server:stable\n>\n> ![1538717959699](/img/1538717959699.png)\n>\n>* 需添加一台主机\n","tags":["java"],"categories":["开源框架"]},{"title":"自定义注解+反射实现orm框架的映射与查询功能","url":"/2018/10/04/自定义注解+反射实现orm框架的映射与查询功能/","content":"\n**积极一点,耐心一点,你想要的,时光都会慢慢带到你面前!**<Excerpt in index | 首页摘要>\n对注解和反射的加深学习,对ORM框架的加深理解 \n<!-- more -->\n<The rest of contents | 余下全文>\n\n> **自定义orm框架例如:Mybatis,hibernate的@Table,@Column注解,通过反射解析注解实现对应表的查询功能,对注解加深学习,对orm框架的思想进行理解.**\n*将定义的注解进行解析取出数据库表的名字,表对应字段的名字,以及字段对应的value进行sql的拼装,最后通过jdbc进行查询.* \n具体代码如下:\n\n## 数据表\n\n```java\n@Table(\"user\")\npublic class Filter {\n    @Column(\"id\")\n    private int id;\n    @Column(\"userName\")\n    private String userName;\n    @Column(\"nickName\")\n    private  String nickName;\n    @Column(\"age\")\n    private int age;\n    @Column(\"city\")\n    private String city;\n    @Column(\"email\")\n    private String email;\n    @Column(\"mobile\")\n    private String mobile;\n    public int getId() {\n        return id;\n    }\n\n    public void setId(int id) {\n        this.id = id;\n    }\n\n    public String getUserName() {\n        return userName;\n    }\n\n    public void setUserName(String userName) {\n        this.userName = userName;\n    }\n\n    public String getNickName() {\n        return nickName;\n    }\n\n    public void setNickName(String nickName) {\n        this.nickName = nickName;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public String getCity() {\n        return city;\n    }\n\n    public void setCity(String city) {\n        this.city = city;\n    }\n\n    public String getEmail() {\n        return email;\n    }\n\n    public void setEmail(String email) {\n        this.email = email;\n    }\n\n    public String getMobile() {\n        return mobile;\n    }\n\n    public void setMobile(String mobile) {\n        this.mobile = mobile;\n    }\n}\n\n```\n\n\n\n## 自定义注解\n\n```java\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Table {\n    String value();\n}\n\n```\n\n------\n\n```java\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Target(ElementType.FIELD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Column {\n    String value();\n}\n\n```\n\n## 对注解的解析和测试类\n\n```java\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\n\npublic class Test {\n    public static void main(String[] args) {\n        Filter f1 = new Filter();\n        f1.setAge(10);\n        Filter f2 = new Filter();\n        f2.setNickName(\"congcong\");\n        Filter f3 = new Filter();\n        f3.setEmail(\"111@qq.com,222@163.com,333@outlook.com\");\n        String sql1 = query(f1);\n        String sql2 = query(f2);\n        String sql3 = query(f3);\n        System.out.println(sql1);\n        System.out.println(sql2);\n        System.out.println(sql3);\n    }\n    public static String query(Filter filter) {\n        StringBuilder sb = new StringBuilder();\n        //1.获取Class\n        Class clazz = filter.getClass();\n        //2.获取Table注解\n        if (!clazz.isAnnotationPresent(Table.class)) {\n            return null;\n        }\n        Table table = (Table) clazz.getAnnotation(Table.class);\n        String tableName = table.value();\n        sb.append(\"select * from \").append(tableName).append(\" where 1=1 \");\n        //3.获取表中的字段\n        Field[] fields = clazz.getDeclaredFields();\n        for (Field f : fields) {\n            //4.处理每个字段对应的SQL\n            if (!f.isAnnotationPresent(Column.class)) {\n                continue;\n            }\n            //4.1获取字段上的注解\n            Column column = f.getAnnotation(Column.class);\n            String columnName = column.value();\n            //4.2获取字段的值\n            String fieldName = f.getName();\n            //4.3获取字段的get方法\n            String getMethodName = \"get\" + fieldName.substring(0, 1).toUpperCase()\n                    + fieldName.substring(1);\n            Object fieldValue = null;\n            try {\n                Method getMethod = clazz.getDeclaredMethod(getMethodName);\n                fieldValue = getMethod.invoke(filter);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            //4.4拼装SQL\n            if (fieldValue == null || (fieldValue instanceof Integer && (Integer) fieldValue == 0)) {\n                continue;\n            }\n            if (fieldValue instanceof String) {\n                sb.append(\"and \").append(columnName).append(\"=\");\n                if (((String) fieldValue).contains(\",\")) {\n                    String[] values = ((String) fieldValue).split(\",\");\n                    sb.append(\" in(\");\n                    for (String v : values) {\n                        sb.append(\"'\").append(v).append(\"'\").append(\",\");\n                    }\n                    sb.deleteCharAt(sb.length() - 1);\n                    sb.append(\")\");\n                }\n            } else {\n                sb.append(\"'\").append(fieldValue)\n                        .append(\"'\").append(\" \");\n            }\n            if (fieldValue instanceof Integer) {\n                sb.append(\"and \").append(columnName).append(\"=\").append(fieldValue).append(\" \");\n            }\n        }\n        return sb.toString();\n    }\n}\n```\n\n> 通过jdbc可实现表的完整查询功能功能,在此略过","tags":["java"],"categories":["开源框架"]},{"title":"初识Docker","url":"/2018/10/03/初识Docker/","content":" **读书,健身,努力工作,关心身体,保持好心情,成为最棒的自己!**<Excerpt in index | 首页摘要>\n docker是一个神奇的开发工具!\n\n<!-- more -->\n<The rest of contents | 余下全文>\n## 1.什么是docker\n\n> docker是一个世界领先的容器化平台.网上对他的定义有很多,说法过于复杂化了.我是通过学习springcloud认识的docker的,感觉它就是一个神器.个人理解的docker就是一个背包,你可以把你需要的东西放在这个背包里,然后这个背包你可以分享给任何人.你也可以从免费的商店里获得别人的背包,无论你咋什么样的环境下都可以正常使用这个背包.\n>\n> docker是跨平台的,支持windows,maxos,linux\n\n## 2.docker思想\n\n![1538544866753](/img/1538544866753.png)\n\n## 3.docker解决了哪些问题\n\n### 3.1换一个运行环境程序跑不起来\n\n> 自己本地运行好好的程序放在别人的电脑上就不行了,曾经亲自体会过,非常苦恼.一是苦恼还得在别人的电脑上调bug,更可怕的是时时刻刻担心自己的程序放在第三台电脑上也会down掉了.这种恐惧远胜过修改bug.相信这种问题无论是哪个程序员都或多或少遇到过.docker的出现完美的解决了这个问题,它将你写好的代码,运行环境都放在一个\"集装箱\"里,给别人的不只是代码,而是一整套的程序所需的运行环境.在你的机器上怎们运行,在别人的电脑或者服务器上就会怎样运行.\n\n### 3.2完美实现了隔离\n> docker再启动是为每个容器限定的CPU,硬盘和网络,不会出现一个程序进入了死循环,从而影响到其他程序的事情发生.\n\n### 3.3弹性伸缩变得简单\n> 就电商来说:双十一几亿人同时在线,按照平时的资源配置肯定吃不消.如果按照双十一的业务量来配置资源平时又是极大的浪费.所以就要弹性的加减服务器,写过java程序的小伙伴们到知道,要想在一台电脑上跑java程序需要安装至少需要安装jre,配置环境,再把代码拷过来运行,中间可能还会出现问题.使用docker扩展服务器将变成按一下按钮秒秒钟添加n台服务器那么容易.\n\n## 4.走进docker\n\n> docker的三个关键字:镜像,仓库,容器\n>\n> docker的三个关键单词:Build,Ship,Run\n\n![1538546571188](/img/1538546571188.png)\n\n> -镜像:\n>\n> -容器:\n>\n> -仓库:\n>\n> * 官网仓库:hub.docker.com \n> * 网易仓库:c.163.com\n\n## 5.docker的安装\n\n> 网上教程很多,懒得再详细总结\n\n## 6.第一个docker镜像\n\n###  6.1docker工作流程\n\n![1538548365242](/img/1538548365242.png)\n\n### 6.2常用的命令\n\n> * docker pull [OPTIONS] NAME[:TAG]  拉去镜像   举例:docker pull hello-world\n> * docker images [OPTIONS]_[ REPOSITORY[:TAG]] 查看镜像\n> * docker run hello-world\n> * docker ps\n> * docker exec -it [代号] bash   :进入容器(正在运行的)\n> * which nginx : 查看Nginx的位置\n> * netstat -na|grep 10001 : 检查端口是否开放\n> * docker run -d -p 10001:80 nginx   :开放容器的80端口映射到本机的10001端口\n> * docker run -d -P  nginx :随机开放端口映射过来\n> * docker build .   : 在当前目录运行构建的Dockerfile 文件\n> * docker build  -t  Jpress:latest  .   :给镜像起一个名字和版本\n\n## 7.运行Nginx服务器镜像\n\n![1538548580593](/img/1538548580593.png)\n\n## 8.docker的网络\n\n![1538549437822](/img/1538549437822.png)![1538549459787](./img/1538549459787.png)\n\n## 9.制作自己的镜像\n\n> * Dockerfille : 制作镜像\n> * docker build : 构建镜像","tags":["docker"],"categories":["开发工具"]},{"title":"突破算法第11天-红黑树","url":"/2017/10/30/test2/","content":"** 累了选择休息而不是选择放弃!** <Excerpt in index | 首页摘要>\n红黑树\n<!-- more -->\n<The rest of contents | 余下全文>\n{% blockquote %}\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem.\n{% endblockquote %}\n\n\n\n{% blockquote David Levithan, Wide Awake %}\nDo not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy.\n{% endblockquote %}\n\n\n{% codeblock %}\npublic static void main\n{% endcodeblock %}\n","tags":["开发工具"],"categories":["开发工具"]}]