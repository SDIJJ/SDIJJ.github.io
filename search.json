[{"title":"SpringCloud微服务学习总结","url":"/2018/10/04/SpringCloud微服务学习总结/","content":"\n** 骗的了别人骗不了自己,做什么都要用心!** <Excerpt in index | 首页摘要>\n对SpringCloud学习做一个总结,供以后应用查看\n<!-- more -->\n<The rest of contents | 余下全文>\n\n微服务的特点:\n\n> * 一系列微小的服务共同组成\n> * 单独部署,跑在自己的进程里\n> * 每个服务为独立的业务开发\n> * 分布式的管理\n\n传统vs微服务\n\n![1538629111529](/img/1538629111529.png)\n\n> 业务形态上不适合微服务的场景\n>\n> * 系统中包含很多很多强事务的场景\n> * 业务相对稳定,迭代周期长\n> * 访问压力不大,可用性要求不高\n> * ...\n\n![1538628687788](/img/1538628687788.png)\n\n![1538628921984](/img/1538628921984.png)\n\n## 1.Eureka服务注册中心\n\n### 1.1构建项目\n\n> 选择eureka Server\n\n![1538625976475](/img/1538625976475.png) \n\n### 1.2 启动类上添加```@EnableEurekaServer```注解\n\n```java\n\npackage com.jia.eureka;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;\n\n@SpringBootApplication\n@EnableEurekaServer\npublic class EurekaApplication {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(EurekaApplication.class, args);\n\t}\n}\n```\n\n### 1.3 application.yml配置\n\n>* register-with-eureka: false       是否注册到服务注册中心,因为自己就是服务注册注册中心,所以false\n>* enable-self-preservation: false      关闭心跳检测保留链接(开发环境为了查看服务状态)\n\n```java\n\neureka:\n  client:\n    service-url:\n      defaultZone: http://localhost:8761/eureka/\n    register-with-eureka: false\n  server:\n    enable-self-preservation: false\nspring:\n  application:\n    name: eureka\nserver:\n  port: 8761\n```\n\n### 1.4启动效果\n\n![1538626591475](/img/1538626591475.png)### 1.5小结\n\n> eureka服务注册中心在生产环境中可以做到高可用,启动多个eureka服务注册中心,彼此相互注册,每个客户端服务再分别注册到这些eureka服务注册中心.即使一个eureka垮掉,整个微服务也可以正常运行.\n>\n> ![1538628284808](/img/1538628284808.png)\n\n## 2.Eureka客户端的使用\n\n### 2.1构建项目\n\n> 选择Eureka Discovery\n\n![1538627464924](/img/1538627464924.png)2.2 启动类上添加@EnableDiscoveryClient注解\n\n```java\npackage com.jia.client;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.cloud.client.discovery.EnableDiscoveryClient;\n\n@SpringBootApplication\n@EnableDiscoveryClient\npublic class ClientApplication {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(ClientApplication.class, args);\n\t}\n}\n\n```\n\n### 2.3 application.yml的配置\n\n>*  instance:\n>\n>  ​        hostname: clientName     客户端服务跳转的名字\n\n```java\neureka:\n  client:\n    service-url:\n      defaultZone: http://localhost:8761/eureka/\n#  instance:\n#    hostname: clientName\nspring:\n  application:\n    name: client\nserver:\n  port: 10001\n```\n\n### 2.4 启动效果\n\n![1538628237602](/img/1538628237602.png)\n\n### 2.5小结\n\n> * @EnableEurekaServer @EnabeEurekaClient\n> * 心跳检测,健康检查,负载均衡等功能\n> * Eureka的高可用,生产上建议使用两台\n> * 分布式系统中,服务注册中心是重要的基础部分\n\n## 3.统一配置中心config\n\n### 3.1.为什么需要统一配置中心\n\n* 不方便维护\n* 配置内容安全与权限\n* 更新配置项目启动\n\n### 3.2.统一配置中心总体架构\n\n![1538630591518](/img/1538630591518.png)\n\n### 3.3.统一配置中心的Server端\n\n> * 项目构建 \n>\n> ![1538630687494](/img/1538630755571.png)\n>\n> * 启动类上添加注解@EnableConfigServer\n>\n>   ```java\n>   package com.jia.config;\n>   \n>   import org.springframework.boot.SpringApplication;\n>   import org.springframework.boot.autoconfigure.SpringBootApplication;\n>   import org.springframework.cloud.client.discovery.EnableDiscoveryClient;\n>   import org.springframework.cloud.config.server.EnableConfigServer;\n>   \n>   @SpringBootApplication\n>   @EnableDiscoveryClient\n>   @EnableConfigServer\n>   public class ConfigApplication {\n>   \n>   \tpublic static void main(String[] args) {\n>   \t\tSpringApplication.run(ConfigApplication.class, args);\n>   \t}\n>   }\n>   ```\n>\n>   * gitee上创建一个仓库用来存放配置文件\n>\n>   * > gitee地址:https://gitee.com/shltj/config-repo\n>\n>     ![1538631315904](/img/1538631315904.png)\n>\n>     * application.yml的配置\n>\n>       ```java\n>       spring:\n>         application:\n>           name: config\n>         cloud:\n>           config:\n>             server:\n>               git:\n>                 uri: https://gitee.com/shltj/config-repo\n>                 username: shltj\n>                 password: xxxxxxxx\n>                 basedir: e:/config\n>       eureka:\n>         client:\n>           service-url:\n>             defaultZone: http://localhost:8761/eureka/\n>       ```\n>\n>       * 启动效果\n>\n>         ![1538633264680](/img/1538633264680.png)\n\n### 3.4统一配置中心Client端\n\n> * 添加依赖\n>   \n>   ```java\n>   \t<dependency>\n>   \t\t\t<groupId>org.springframework.cloud</groupId>\n>   \t\t\t<artifactId>spring-cloud-config-client</artifactId>\n>   \t</dependency>\n>   ```\n>\n>   * gitee上新建client-dev.yml\n>\n>   ```java\n>   eureka:\n>     client:\n>       service-url:\n>         defaultZone: http://localhost:8761/eureka/\n>   #  instance:\n>   #    hostname: clientName\n>   spring:\n>     application:\n>       name: client\n>   server:\n>     port: 10001\n>   ```\n>\n>   * 将applicatiion.yml 修改为bootstrap.yml springboot默认先加载applicatiion.yml \n>\n>     ```java\n>     spring:\n>       cloud:\n>         config:\n>           discovery:\n>             enabled: true\n>             service-id: config\n>           profile: dev\n>       application:\n>         name: client\n>     ```\n>\n\n  ## 4.SpringCloud Bus 自动刷新配置\n\n### 4.1自动刷新配置原理\n\n![1538635206179](/img/1538635206179.png)### 4.2在config服务端添加amqp的依赖\n\n```java\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.cloud</groupId>\n\t\t\t<artifactId>spring-cloud-starter-bus-amqp</artifactId>\n\t\t</dependency>\n```\n\n### 4.3  在application.yml 中添加rabbitmq的配置并且暴露访问端口(后期可由git服务器的webhook 访问)\n\n```java\n  rabbitmq:\n    port: 5672\n    host: 101.200.44.222\n    username: tong\n    password: tong\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: \"*\"    \n```\n\n### 4.4在client服务端添加rabbitmap的依赖\n\n```java\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-bus-amqp</artifactId>\n        </dependency>\n```\n\n### 4.5注意将springboot和springcloud的版本改成BUILD-SNAPSHOT,M3存在bug.\n\n> **别忘记需要在更新配置的地方添加@RefreshScope注解**\n\n> 访问http://localhost:8080/actuator/bus-refresh(用post请求方式)可以实现动态更新配置,github上的webhook已经支持访问改接口\n\n## 5.mq的使用\n\n### 5.1 mq的应用场景\n\n> * 异步处理\n> * 流量削峰\n> * 日志处理\n> * 应用解耦\n\n## 6.服务网关Zuul\n\n### 6.1服务网关所应具备的要素\n\n> * 稳定性,高可用(7*25小时服务)\n> * 性能,并发性\n> * 安全性\n> * 扩展性\n\n### 6.2常见的服务网关\n\n![1538648760855](/img/1538648760855.png)### 6.3Zuul的特点\n\n> * 路由+过滤器=zuul\n>\n> * 核心是一些列的过滤器\n>\n>   ![1538648953468](/img/1538648953468.png)![1538649013623](/img/1538649013623.png)\n\n### 6.4Zuul的使用\n\n> * 项目的构建\n>\n>   ![1538649205460](/img/1538649205460.png)*  再启动类上添加@EnableZuulProxy注解\n>\n>   ```java\n>   package com.jia.apigetway;\n>   \n>   import org.springframework.boot.SpringApplication;\n>   import org.springframework.boot.autoconfigure.SpringBootApplication;\n>   import org.springframework.cloud.client.discovery.EnableDiscoveryClient;\n>   import org.springframework.cloud.netflix.zuul.EnableZuulProxy;\n>   \n>   @SpringBootApplication \n>   @EnableDiscoveryClient\n>   @EnableZuulProxy\n>   public class ApiGetwayApplication {\n>   \n>   \tpublic static void main(String[] args) {\n>   \t\tSpringApplication.run(ApiGetwayApplication.class, args);\n>   \t}\n>   }\n>   \n>   ```\n>\n>   * 经过服务网关和直接访问服务写法对比(网关+服务+方法)\n>\n>\n>\n>     > ![1538650336849](/img/1538650336849.png)\n>     >\n>     > ![1538650399065](/img/1538650399065.png)\n\n>* 自定义路由bootstrap.yml添加配置\n>\n>  ```java\n>  management:\n>    security:\n>      enabled: false\n>  zuul:\n>    routes:\n>      aaaaa:\n>        path: /myclient/**\n>        serviceId: client\n>  ```\n>\n>  ---\n>\n>  简介写法:\n>\n>  ![1538650911129](/img/1538650911129.png)\n\n> * 排除某些路由的写法:\n>\n>   ![1538651042319](/img/1538651042319.png)* Zuul默认服务间不能传递cookie,传递cookId配置方法\n>\n>   ![1538651174961](/img/1538651174961.png)\n\n### 6.5Zuul典型的使用场景\n\n* 前置过滤器: 限流,鉴权,参数校验调整\n* 后置过滤器:统计,日志\n\n### 6.6Zuul的权限校验 \n\n> 规定请求的参数必须带Token.如果Token为空,校验不通过,实现代码如下:\n>\n> > 注意: shouldFilter方法返回值设置为true\n> >\n> > ​         filterType()方法中配置参数类型\n> >\n> > ​          filterOrder()方法中配置拦截器的优先级\n\n```java\npackage com.jia.apigetway.filter;\n\nimport com.netflix.zuul.ZuulFilter;\nimport com.netflix.zuul.context.RequestContext;\nimport org.apache.http.HttpStatus;\nimport org.springframework.stereotype.Component;\nimport org.springframework.util.StringUtils;\n\nimport javax.servlet.http.HttpServletRequest;\n\nimport static org.springframework.cloud.netflix.zuul.filters.support.FilterConstants.PRE_DECORATION_FILTER_ORDER;\nimport static org.springframework.cloud.netflix.zuul.filters.support.FilterConstants.PROXY_KEY;\n\n@Component\npublic class Tocken extends ZuulFilter {\n    @Override\n    public String filterType() {\n        return PROXY_KEY;\n    }\n\n    @Override\n    public int filterOrder() {\n        return PRE_DECORATION_FILTER_ORDER-1;\n    }\n\n    @Override\n    public boolean shouldFilter() {\n        return true;\n    }\n\n    @Override\n    public Object run() {\n        RequestContext requestContext = RequestContext.getCurrentContext();\n        HttpServletRequest request=requestContext.getRequest();\n        String token=request.getParameter(\"token\");\n        if(StringUtils.isEmpty(token)){\n            requestContext.setSendZuulResponse(false);\n            requestContext.setResponseStatusCode(HttpStatus.SC_UNAUTHORIZED);\n        }\n\n        return null;\n    }\n}\n\n```\n\n### 6.7Zuul的限流\n\n> Zuul使用的是Google开发的令牌桶限流,具体如下图:\n>\n> ![1538652781643](/img/1538652781643.png)\n\n> 代码如下\n>\n> ```java\n> package com.jia.apigetway.filter;\n> \n> import com.google.common.util.concurrent.RateLimiter;\n> import com.netflix.zuul.ZuulFilter;\n> import org.springframework.stereotype.Component;\n> \n> import static org.springframework.cloud.netflix.zuul.filters.support.FilterConstants.PRE_TYPE;\n> import static org.springframework.cloud.netflix.zuul.filters.support.FilterConstants.SERVLET_DETECTION_FILTER_ORDER;\n> \n> @Component\n> public class RateLimiterFilter extends ZuulFilter {\n>     //每秒钟放100令牌\n>     private static final RateLimiter RATE_LIMITER=RateLimiter.create(100);\n> \n>     @Override\n>     public String filterType() {\n>         return PRE_TYPE;\n>     }\n> \n>     @Override\n>     public int filterOrder() {\n>         return SERVLET_DETECTION_FILTER_ORDER-1;\n>     }\n> \n>     @Override\n>     public boolean shouldFilter() {\n>         return true;\n>     }\n> \n>     @Override\n>     public Object run() {\n>         if(!RATE_LIMITER.tryAcquire()){\n>            throw new RuntimeException();   //通过令牌桶限流,如果拿不到令牌就抛出一个异常,感觉好像有bug\n>         }\n>         return null;\n>     }\n> }\n> \n> ```\n\n### 6.8Zuul的权限校验\n\n> 通过Zuul的拦截器实现如下鉴权功能\n>\n> ![1538654024968](/img/1538654024968.png)\n>\n> 在拦截器中具体代码实现如下:\n>\n> ![1538654539209](/img/1538654539209.png)\n\n### 6.8Zuul的跨域解决方法\n\n> 基本解决跨域\n\n```java\npackage com.jia.apigetway;\n\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.cors.CorsConfiguration;\nimport org.springframework.web.cors.UrlBasedCorsConfigurationSource;\nimport org.springframework.web.filter.CorsFilter;\n\nimport java.util.Arrays;\n\n/**\n * 跨域配置\n * C-Cross O-Origin  R-Resource S-Sharing\n */\n@Configuration\npublic class CorsConfig  {\n    public CorsFilter corsFilter(){\n        final UrlBasedCorsConfigurationSource source=new UrlBasedCorsConfigurationSource();\n        final CorsConfiguration config=new CorsConfiguration();\n        config.setAllowCredentials(true);\n        config.setAllowedOrigins(Arrays.asList(\"*\")); //http://www.a.com\n        config.setAllowedHeaders(Arrays.asList(\"*\"));\n        config.setAllowedMethods(Arrays.asList(\"*\"));\n        config.setMaxAge(300l);\n        source.registerCorsConfiguration(\"/**\",config);\n        return  new CorsFilter(source)\n    }\n}\n\n```\n\n> 通用跨域解决方案\n>\n> ![1538655791286](/img/1538655791286.png)\n\n## 7.服务容错Hystrix\n\n> 同步等待会造成资源耗尽\n\n### 7,1Hystrix的功能\n\n> * 服务降级\n> * 依赖隔离\n> * 服务熔断\n> * 监控(Hystrix Dashboard)\n\n### 7.2服务降级\n\n> 优先核心服务,非核心服务不可用或若可用\n>\n> 通过HystrixCommand注解指定\n>\n> fallbackMethod(回退函数)中具体实现降级逻辑\n\n### 7,3Hystrix的使用\n\n> 在client服务去访问client2服务的getMessage方法\n>\n> * 在client服务端添加Hystrix依赖\n>\n>   ```java\n>   \t\t<dependency>\n>   \t\t\t<groupId>org.springframework.cloud</groupId>\n>   \t\t\t<artifactId>spring-cloud-starter-hystrix</artifactId>\n>   \t\t</dependency>\n>   ```\n>\n>   * 启动类上添加@EnableCircuitBreaker注解\n>\n>     ```java\n>     package com.jia.client;\n>     \n>     import org.springframework.boot.SpringApplication;\n>     import org.springframework.boot.autoconfigure.SpringBootApplication;\n>     import org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker;\n>     import org.springframework.cloud.client.discovery.EnableDiscoveryClient;\n>     import org.springframework.cloud.netflix.hystrix.EnableHystrix;\n>     \n>     @SpringBootApplication\n>     @EnableDiscoveryClient\n>     @EnableCircuitBreaker\n>     public class ClientApplication {\n>     \n>     \tpublic static void main(String[] args) {\n>     \t\tSpringApplication.run(ClientApplication.class, args);\n>     \t}\n>     }\n>     ```\n>\n>     * 定义HystrixController实验服务降级\n>\n>       >在方法上添加  @HystrixCommand(fallbackMethod = \"fallback\")注解当方法出现异常或者超时会自动调用fallback();\n>       >\n>       >如果想所有的方法都实现服务降级,可以在Controller上添加@DefaultProperties(defaultFallback=\"xxxxx\") xxxxx为自定义服务降级走的方法\n>\n>       ```java\n>       package com.jia.client.controller;\n>       \n>       import com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;\n>       import org.springframework.web.bind.annotation.GetMapping;\n>       import org.springframework.web.bind.annotation.RestController;\n>       import org.springframework.web.client.RestTemplate;\n>       \n>       @RestController\n>       public class HystrixController {\n>       \n>            RestTemplate restTemplate=new RestTemplate();\n>       \n>            @GetMapping(\"/get\")\n>            @HystrixCommand(fallbackMethod = \"fallback\")\n>            public String getMsg(){\n>                String msg=restTemplate.getForObject(\"http://localhost:10005/getMessage\",String.class);\n>                try {\n>                    Thread.sleep(2000);\n>                } catch (InterruptedException e) {\n>                    e.printStackTrace();\n>                }\n>                return \"from client2 message\"+msg;\n>            }\n>            private  String fallback(){\n>                return \"人太多,挤爆了\";\n>            }\n>       \n>       }\n>       \n>       ```\n\n### 7,4Hystrix服务的熔断\n\n> 断路器实现服务熔断:\n>\n> ![1538702279205](/img/1538702279205.png)\n>\n>    访问getMessage方法,当参数为奇数是抛异常,当异常达到一定次数是(60%)启动断路开关\n\n```java\npackage com.imooc.client3.controller;\n\nimport com.netflix.hystrix.contrib.javanica.annotation.DefaultProperties;\nimport com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;\nimport com.netflix.hystrix.contrib.javanica.annotation.HystrixProperty;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.RestController;\nimport org.springframework.web.client.RestTemplate;\n\n@RestController\n@DefaultProperties(defaultFallback = \"defaultFallback\")\npublic class HystrixController {\n    private RestTemplate restTemplate = new RestTemplate();\n//    服务的超时配置\n\n//    @HystrixCommand(fallbackMethod = \"fallback\",commandProperties ={\n//            @HystrixProperty(name = \"execution.isolation.thread.timeoutInMilliseconds\",value=\"3500\")\n//    } )\n    @HystrixCommand(commandProperties = {\n            @HystrixProperty(name=\"circuitBreaker.enabled\",value = \"true\"),   //设置熔断\n            @HystrixProperty(name=\"circuitBreaker.requestVolumeThreshold\",value = \"10\"),\n            @HystrixProperty(name=\"circuitBreaker.sleepWindowInMilliseconds\",value = \"10000\"),\n            @HystrixProperty(name=\"circuitBreaker.errorThresholdPercentage\",value = \"60\")\n    })\n    @GetMapping(\"/messageT\")\n    public String getMessage(@RequestParam(\"number\") Integer number ) {\n        String result=null;\n        if(number%2==0){\n             result = this.restTemplate.getForObject(\"http://localhost:10006/tong\",String.class);\n\n        }else{\n            int a=1/0;\n             result=\"1111\";\n        }\n\n        System.out.println(result);\n        return result;\n    }\n\n    private String fallback() {\n        return \"出故障了!!!\";\n    }\n\n    @HystrixCommand\n    @GetMapping(\"/messageT1\")\n    public String getMessage1() throws RuntimeException {\n        String result = this.restTemplate.getForObject(\"http://localhost:10006/tong\", String.class);\n\n        System.out.println(result);\n        int a = 1 / 0;\n        return result;\n\n\n    }\n\n    private String defaultFallback() {\n        return \"默认方法出故障了!!!!!\";\n    }\n\n}\n\n```\n\n### 7.5feign和Hystrix的使用\n\n> feign的使用(内置ribbon):\n>\n> * 添加依赖\n>\n>   ```java\n>   <dependency>\n>       <groupId>org.springframework.cloud</groupId>\n>       <artifactId>spring-cloud-starter-openfeign</artifactId>\n>   </dependency>\n>   ```\n>\n> * 启动类上添加注解@EnableFeignClients\n>\n>   ```java\n>   package com.jia.client;\n>   \n>   import org.springframework.boot.SpringApplication;\n>   import org.springframework.boot.autoconfigure.SpringBootApplication;\n>   import org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker;\n>   import org.springframework.cloud.client.discovery.EnableDiscoveryClient;\n>   import org.springframework.cloud.openfeign.EnableFeignClients;\n>   \n>   @SpringBootApplication\n>   @EnableDiscoveryClient\n>   @EnableCircuitBreaker\n>   @EnableFeignClients\n>   public class ClientApplication {\n>   \n>   \tpublic static void main(String[] args) {\n>   \t\tSpringApplication.run(ClientApplication.class, args);\n>   \t}\n>   }\n>   ```\n>\n>   * 访问远程服务的方法\n>\n>     ```java\n>     package com.jia.client.controller;\n>     \n>     \n>     import org.springframework.cloud.openfeign.FeignClient;\n>     import org.springframework.web.bind.annotation.PostMapping;\n>     \n>     @FeignClient(\"client2\")\n>     public interface Client2Feign {\n>         @PostMapping(\"/client2/getMessage\")\n>         String get();\n>     }\n>     \n>     ```\n>\n>     ----\n>\n>     feign和Hystrix结合使用:\n>\n>     > bootstrap.yml中添加配置\n>     >\n>     > ```java\n>     > feign:\n>     >   hystrix:\n>     >     enable: true\n>     > ```\n>     >\n>     >\n>\n>     > 如果发生异常执行class中的方法\n>\n>     ```java\n>     package com.jia.client.controller;\n>     \n>     \n>     import org.springframework.cloud.openfeign.FeignClient;\n>     import org.springframework.stereotype.Component;\n>     import org.springframework.web.bind.annotation.PostMapping;\n>     \n>     @FeignClient(value = \"client2\",fallback = Client2Feign.Client2Fallback.class)\n>     public interface Client2Feign {\n>         @PostMapping(\"/client2/getMessage\")\n>         String get();\n>         @Component\n>         class Client2Fallback implements Client2Feign{\n>             @Override\n>             public String get() {\n>                 return null;\n>             }\n>         }\n>     }\n>     \n>     ```\n\n### 7.6Hystrix-dashboard可视化组件的使用\n\n> * 添加依赖\n>\n>   ```java\n>        <dependency>\n>           <groupId>org.springframework.cloud</groupId>\n>           <artifactId>spring-cloud-starter-hystrix-dashboard</artifactId>\n>        </dependency>\n>        <dependency>\n>            <groupId>org.springframework.boot</groupId>\n>            <artifactId>spring-boot-starter-actuator</artifactId>\n>         </dependency>\n>   ```\n>\n>   * 启动类上添加注解@EnableHystrixDashboard\n>\n>     ```java\n>     package com.jia.client;\n>     \n>     import org.springframework.boot.SpringApplication;\n>     import org.springframework.boot.autoconfigure.SpringBootApplication;\n>     import org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker;\n>     import org.springframework.cloud.client.discovery.EnableDiscoveryClient;\n>     import org.springframework.cloud.netflix.hystrix.dashboard.EnableHystrixDashboard;\n>     import org.springframework.cloud.openfeign.EnableFeignClients;\n>     \n>     @SpringBootApplication\n>     @EnableDiscoveryClient\n>     @EnableCircuitBreaker\n>     @EnableFeignClients\n>     @EnableHystrixDashboard\n>     public class ClientApplication {\n>     \n>     \tpublic static void main(String[] args) {\n>     \t\tSpringApplication.run(ClientApplication.class, args);\n>     \t}\n>     }\n>     \n>     ```\n>\n>     * 访问/hystrix路径\n>\n>       ![1538707724714](/img/1538707724714.png)* client服务端添加如下配置:\n>\n>       ```java\n>       management:\n>         context-path: /\n>       ```\n>\n>       * 监控视图\n>\n>         ![1538708343150](/img/1538708343150.png)\n\n## 8.服务的追踪(链路监控Sleuth)\n\n> * 添加依赖\n>\n>   ```java\n>   \t\t<dependency>\n>   \t\t\t<groupId>org.springframework.cloud</groupId>\n>   \t\t\t<artifactId>spring-cloud-starter-sleuth</artifactId>\n>   \t\t</dependency>\n>   ```\n>\n>  * 使用**OpenZIPkin**查看服务的追踪\n>\n>     > * 用docker安装软件\n>     >\n>     >   docker pull openzipkin/zipkin\n>     >\n>     >   docker run -d -p 9411:9411 zipkin\n>     >\n>     >   浏览器访问:http://101.200.44.222:9411/zipkin/\n>     >\n>     >   ![1538710627440](/img/1538710627440.png)\n>\n>  * client服务添加相应依赖\n>\n>     ```java\n>     <dependency>\n>        <groupId>org.springframework.cloud</groupId>\n>        <artifactId>spring-cloud-sleuth-zipkin</artifactId>\n>     </dependency>\n>     ```\n>\n>   * bootstrap.yml中添加配置\n>\n>       ```java\n>       zipkin:\n>         base-url: http://101.200.44.222:9411\n>       ```\n>\n>           * 设置抽样观察百分比为1\n>\n>         ```java\n>         sleuth:\n>           sampler:\n>             percentage: 1f\n>         ```\n>\n> * 展示效果\n>\n>      ![1538711526837](/img/1538711526837.png)\n>\n\n##  9.分布式追踪系统\n\n### 9.1核心步骤(OpenTracing规范)\n\n![1538711826394](/img/1538711826394.png)\n\n> * 数据采集\n> * 数据存储\n> * 查询展示\n\n## 10.使用docker部署项目\n\n### 10.1docker部署eureka服务注册中心\n\n> * Docerfile文件内容\n>\n> ```dockerfile\n> FROM hub.c.163.com/library/java:8-alpine\n> ADD app.jar  app.jar\n> EXPOSE 8761\n> ENTRYPOINT [\"java\",\"-jar\",\"/app.jar\"]\n> ```\n>\n> * 构建命令:docker build -t springcloud2/eureka .\n>\n> * 运行命令:docker run -d -p 8761:8761 springcloud2/eureka\n>\n> * 网易云上传镜像:https://www.163yun.com/help/documents/15587826830438400\n>\n> * 访问成功:\n>\n>   ![1538714796176](/img/1538714796176.png)\n\n### 10.2 rancher的使用\n\n> Rancher是一个开源的企业级全栈化容器部署管理平台(为了更方便的管理docker)\n>\n> > 安装rancher命令:sudo docker run -d --restart=unless-stopped -p 8080:8080 rancher/server:stable\n>\n> ![1538717959699](/img/1538717959699.png)\n>\n>* 需添加一台主机\n","tags":["java"],"categories":["开源框架"]},{"title":"自定义注解+反射实现orm框架的映射与查询功能","url":"/2018/10/04/自定义注解+反射实现orm框架的映射与查询功能/","content":"\n**积极一点,耐心一点,你想要的,时光都会慢慢带到你面前!**<Excerpt in index | 首页摘要>\n对注解和反射的加深学习,对ORM框架的加深理解 \n<!-- more -->\n<The rest of contents | 余下全文>\n\n> **自定义orm框架例如:Mybatis,hibernate的@Table,@Column注解,通过反射解析注解实现对应表的查询功能,对注解加深学习,对orm框架的思想进行理解.**\n*将定义的注解进行解析取出数据库表的名字,表对应字段的名字,以及字段对应的value进行sql的拼装,最后通过jdbc进行查询.* \n具体代码如下:\n\n## 数据表\n\n```java\n@Table(\"user\")\npublic class Filter {\n    @Column(\"id\")\n    private int id;\n    @Column(\"userName\")\n    private String userName;\n    @Column(\"nickName\")\n    private  String nickName;\n    @Column(\"age\")\n    private int age;\n    @Column(\"city\")\n    private String city;\n    @Column(\"email\")\n    private String email;\n    @Column(\"mobile\")\n    private String mobile;\n    public int getId() {\n        return id;\n    }\n\n    public void setId(int id) {\n        this.id = id;\n    }\n\n    public String getUserName() {\n        return userName;\n    }\n\n    public void setUserName(String userName) {\n        this.userName = userName;\n    }\n\n    public String getNickName() {\n        return nickName;\n    }\n\n    public void setNickName(String nickName) {\n        this.nickName = nickName;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public String getCity() {\n        return city;\n    }\n\n    public void setCity(String city) {\n        this.city = city;\n    }\n\n    public String getEmail() {\n        return email;\n    }\n\n    public void setEmail(String email) {\n        this.email = email;\n    }\n\n    public String getMobile() {\n        return mobile;\n    }\n\n    public void setMobile(String mobile) {\n        this.mobile = mobile;\n    }\n}\n\n```\n\n\n\n## 自定义注解\n\n```java\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Table {\n    String value();\n}\n\n```\n\n------\n\n```java\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Target(ElementType.FIELD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Column {\n    String value();\n}\n\n```\n\n## 对注解的解析和测试类\n\n```java\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\n\npublic class Test {\n    public static void main(String[] args) {\n        Filter f1 = new Filter();\n        f1.setAge(10);\n        Filter f2 = new Filter();\n        f2.setNickName(\"congcong\");\n        Filter f3 = new Filter();\n        f3.setEmail(\"111@qq.com,222@163.com,333@outlook.com\");\n        String sql1 = query(f1);\n        String sql2 = query(f2);\n        String sql3 = query(f3);\n        System.out.println(sql1);\n        System.out.println(sql2);\n        System.out.println(sql3);\n    }\n    public static String query(Filter filter) {\n        StringBuilder sb = new StringBuilder();\n        //1.获取Class\n        Class clazz = filter.getClass();\n        //2.获取Table注解\n        if (!clazz.isAnnotationPresent(Table.class)) {\n            return null;\n        }\n        Table table = (Table) clazz.getAnnotation(Table.class);\n        String tableName = table.value();\n        sb.append(\"select * from \").append(tableName).append(\" where 1=1 \");\n        //3.获取表中的字段\n        Field[] fields = clazz.getDeclaredFields();\n        for (Field f : fields) {\n            //4.处理每个字段对应的SQL\n            if (!f.isAnnotationPresent(Column.class)) {\n                continue;\n            }\n            //4.1获取字段上的注解\n            Column column = f.getAnnotation(Column.class);\n            String columnName = column.value();\n            //4.2获取字段的值\n            String fieldName = f.getName();\n            //4.3获取字段的get方法\n            String getMethodName = \"get\" + fieldName.substring(0, 1).toUpperCase()\n                    + fieldName.substring(1);\n            Object fieldValue = null;\n            try {\n                Method getMethod = clazz.getDeclaredMethod(getMethodName);\n                fieldValue = getMethod.invoke(filter);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            //4.4拼装SQL\n            if (fieldValue == null || (fieldValue instanceof Integer && (Integer) fieldValue == 0)) {\n                continue;\n            }\n            if (fieldValue instanceof String) {\n                sb.append(\"and \").append(columnName).append(\"=\");\n                if (((String) fieldValue).contains(\",\")) {\n                    String[] values = ((String) fieldValue).split(\",\");\n                    sb.append(\" in(\");\n                    for (String v : values) {\n                        sb.append(\"'\").append(v).append(\"'\").append(\",\");\n                    }\n                    sb.deleteCharAt(sb.length() - 1);\n                    sb.append(\")\");\n                }\n            } else {\n                sb.append(\"'\").append(fieldValue)\n                        .append(\"'\").append(\" \");\n            }\n            if (fieldValue instanceof Integer) {\n                sb.append(\"and \").append(columnName).append(\"=\").append(fieldValue).append(\" \");\n            }\n        }\n        return sb.toString();\n    }\n}\n```\n\n> 通过jdbc可实现表的完整查询功能功能,在此略过","tags":["java"],"categories":["开源框架"]},{"title":"初识Docker","url":"/2018/10/03/初识Docker/","content":" **读书,健身,努力工作,关心身体,保持好心情,成为最棒的自己!**<Excerpt in index | 首页摘要>\n docker是一个神奇的开发工具!\n\n<!-- more -->\n<The rest of contents | 余下全文>\n## 1.什么是docker\n\n> docker是一个世界领先的容器化平台.网上对他的定义有很多,说法过于复杂化了.我是通过学习springcloud认识的docker的,感觉它就是一个神器.个人理解的docker就是一个背包,你可以把你需要的东西放在这个背包里,然后这个背包你可以分享给任何人.你也可以从免费的商店里获得别人的背包,无论你咋什么样的环境下都可以正常使用这个背包.\n>\n> docker是跨平台的,支持windows,maxos,linux\n\n## 2.docker思想\n\n![1538544866753](/img/1538544866753.png)\n\n## 3.docker解决了哪些问题\n\n### 3.1换一个运行环境程序跑不起来\n\n> 自己本地运行好好的程序放在别人的电脑上就不行了,曾经亲自体会过,非常苦恼.一是苦恼还得在别人的电脑上调bug,更可怕的是时时刻刻担心自己的程序放在第三台电脑上也会down掉了.这种恐惧远胜过修改bug.相信这种问题无论是哪个程序员都或多或少遇到过.docker的出现完美的解决了这个问题,它将你写好的代码,运行环境都放在一个\"集装箱\"里,给别人的不只是代码,而是一整套的程序所需的运行环境.在你的机器上怎们运行,在别人的电脑或者服务器上就会怎样运行.\n\n### 3.2完美实现了隔离\n> docker再启动是为每个容器限定的CPU,硬盘和网络,不会出现一个程序进入了死循环,从而影响到其他程序的事情发生.\n\n### 3.3弹性伸缩变得简单\n> 就电商来说:双十一几亿人同时在线,按照平时的资源配置肯定吃不消.如果按照双十一的业务量来配置资源平时又是极大的浪费.所以就要弹性的加减服务器,写过java程序的小伙伴们到知道,要想在一台电脑上跑java程序需要安装至少需要安装jre,配置环境,再把代码拷过来运行,中间可能还会出现问题.使用docker扩展服务器将变成按一下按钮秒秒钟添加n台服务器那么容易.\n\n## 4.走进docker\n\n> docker的三个关键字:镜像,仓库,容器\n>\n> docker的三个关键单词:Build,Ship,Run\n\n![1538546571188](/img/1538546571188.png)\n\n> -镜像:\n>\n> -容器:\n>\n> -仓库:\n>\n> * 官网仓库:hub.docker.com \n> * 网易仓库:c.163.com\n\n## 5.docker的安装\n\n> 网上教程很多,懒得再详细总结\n\n## 6.第一个docker镜像\n\n###  6.1docker工作流程\n\n![1538548365242](/img/1538548365242.png)\n\n### 6.2常用的命令\n\n> * docker pull [OPTIONS] NAME[:TAG]  拉去镜像   举例:docker pull hello-world\n> * docker images [OPTIONS]_[ REPOSITORY[:TAG]] 查看镜像\n> * docker run hello-world\n> * docker ps\n> * docker exec -it [代号] bash   :进入容器(正在运行的)\n> * which nginx : 查看Nginx的位置\n> * netstat -na|grep 10001 : 检查端口是否开放\n> * docker run -d -p 10001:80 nginx   :开放容器的80端口映射到本机的10001端口\n> * docker run -d -P  nginx :随机开放端口映射过来\n> * docker build .   : 在当前目录运行构建的Dockerfile 文件\n> * docker build  -t  Jpress:latest  .   :给镜像起一个名字和版本\n\n## 7.运行Nginx服务器镜像\n\n![1538548580593](/img/1538548580593.png)\n\n## 8.docker的网络\n\n![1538549437822](/img/1538549437822.png)![1538549459787](./img/1538549459787.png)\n\n## 9.制作自己的镜像\n\n> * Dockerfille : 制作镜像\n> * docker build : 构建镜像","tags":["docker"],"categories":["开发工具"]},{"title":"突破算法第11天-红黑树","url":"/2017/10/30/test2/","content":"** 累了选择休息而不是选择放弃!** <Excerpt in index | 首页摘要>\n红黑树\n<!-- more -->\n<The rest of contents | 余下全文>\n{% blockquote %}\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem.\n{% endblockquote %}\n\n\n\n{% blockquote David Levithan, Wide Awake %}\nDo not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy.\n{% endblockquote %}\n\n\n{% codeblock %}\npublic static void main\n{% endcodeblock %}\n","tags":["开发工具"],"categories":["开发工具"]}]